time,personID,problemID,1st,1st_reason,2nd,2nd_reason,3rd,3rd_reason,others,understanding,free
12/13/2022 20:49:40,7,1,8,配列の右側に関してこの行の条件をつけながら探索していくことで，正解を導き出すことができるから．,2,"配列に0が含まれている場合をあらかじめ抜いておくことで，例外なパターンを排除でき，メインとなるアルゴリズムを実装できるから．
一番ではない理由としては，これは0を含むという例外的なパターンのみにしか対応せず，基本的なアルゴリズムとは関連が薄いから．",15,"rightをleftのたびに更新せず，前回のループで計算したものをそのまま利用することで計算量を落とすことが可能となっているから．
1番や2番ではないのは，これは計算量を減らすためであり，この処理がなく，全て計算を行なっても答え自体は導き出せるから．",12: この条件式があることでバグがなくアルゴリズムを実行できるから．,まあ理解できた。,
12/13/2022 21:01:11,7,2,37,この問題の回答ではセグメントツリーと呼ばれるアルゴリズムを用いるということが明示されており，これを思いつけるかどうかが問題を解く鍵だと思うから．,14,"セグメントツリーの基本的な構造が分かり，この構造からどのように問題を解くのかを考えることができるから．
1番でない理由としては，「セグメントツリー」というアルゴリズム名があったほうが問題の全体的な解き方を把握しやすいから．",29,"セグメントツリーでどのように特定の範囲の和を取得するのかということについて，再帰で和を取得するということがこの行でわかるから．
3番である理由としては，この部分だけではどのように値の更新などを行うかといったことについては分からず，問題の解き方に直結していないから．",,まあ理解できた。,
12/13/2022 21:26:16,7,3,12,返す配列のindexを持ち，indexをインクリメントしながら最終的な配列を更新していくことで，問題文の疑似コード部分の「C[i] に i 以下の数の出現数を記録する」操作が必要ないということが分かるから．,11,"配列の要素を一回一回書き換えるのではなく，for文であらかじめ決められた回数繰り返して同じ数を代入すればよいということが分かる．
1番でない理由としては，indexという変数をつかっているおかげで実現できるから．",7,"問題文の疑似コードでの「 C[i] に i の出現数を記録する 」という操作を実行している部分にあたるから．
3番である理由は，ほとんど疑似コード通りであることから．",,まあ理解できた。,
12/13/2022 21:34:08,7,4,32,中間順巡回においては先に各ノードより左に位置するノードを見るということが重要であり，それがここで現れているから．,38,"先行順巡回では先に自分自身のノードを見てからその子のノードへと移っていくことがこの行で現れているから．
1番でない理由は，中間順巡回に比べてこちらの方が直感的だと思ったから．",12,"疑似コードで触れられている二分木のinsertを実際に実装している部分だから．
3番である理由は，この問題では中間順巡回，先行順巡回でのノードの巡り方のアルゴリズムの違いが問われており，ここは本質ではないと思ったから．",,まあ理解できた。,
12/13/2022 21:42:52,7,5,19,深さ優先探索が再帰関数で実現可能であるということがここの一行で現れているから．,20,"その頂点の探索終了時間は，そこに続く頂点の探索が全て終わった後にするため，for文を抜けた後に終了時刻を記録するという間違えやすい条件がここで現れているから．
1番でない理由としては，深さ優先探索自体のアルゴリズムの実現の方が重要であると考えたから．",26,"未発見の頂点がある場合はそこを支点に深さ優先探索を始めていくことで，全ての点を網羅することができるということがこの一行で現れているから．
3番である理由はこのことは問題文でも指摘されていることだから．",17: 一度現れた頂点は無視することで，ループに陥ってしまうことを防いでいる．,まあ理解できた。,
12/13/2022 22:22:39,7,6,10,dpを行うために一番重要となる，値を更新するための条件式が書かれているから．,12,"dpの結果，最終的に求めたい答えはdp[N][W]に現れるということがこの行で現れているから．
1番目でない理由は，dpの更新アルゴリズムが分かればこのことは最終的に分かることであるから．",9,"容量Wに関するdpであることがこの行で確認できるから．
3番目である理由は，特に他のものに注目したdpでも可能であるため．",,まあ理解できた。,
12/13/2022 22:51:14,7,7,9,二部探索で一番重要である，okとngの中間の数と比較し，範囲を狭めていくという工程で重要な中間の数を算出する箇所だから．,8,"探索の終了条件をこの行のように定めることで探索の終了を定めている．
一行目でない理由は，終了条件は二部探索の一番重要な部分ではないから．",12,"答えとしてカウントされるかどうかの判断をしている部分だから．
3番目である理由は，この問題で一番問われているであろう二部探索のアルゴリズム自身とは少し外れた内容であるから．",,まあ理解できた。,
12/13/2022 23:27:20,7,8,5,初期値の段階でheadとtailの位置を決めておくことでqueueのアルゴリズムが簡単に実現できるということがこの初期化関数でわかるから．,19,"queueのアルゴリズムの特徴である，取り出す時は先頭の要素からということがこの行で表されているから．
1番でない理由としては，queueのアルゴリズムの説明は問題中でなされているから．",13,"queueの挿入時は末尾に挿入するということがこの行で表されているから．
3番目である理由は，stackなど他のアルゴリズムでも挿入では末尾に挿入することが多いため，違いがないから．",,まあ理解できた。,
12/13/2022 23:45:05,7,9,25,この問題はコンビネーションによって解くことができるということがこの一行でわかるから．,21,"modありのコンビネーションの計算では，逆元を使うと計算量を抑えてできるということがわかるから．
1番である理由は，これは計算の工夫であり，問題の解法自体とは直接関わることではないため．",7,"累乗の計算が2の累乗に注目することでより計算コストを抑えられるということがしめされているから．
3番である理由は，この行の処理は1番2番で挙げた箇所に関する計算をさらに計算コストを下げるために行なっているものであるため．",,まあ理解できた。,
12/14/2022 0:19:10,7,10,12,dpで必要なdpテーブル更新のための方程式が明示されている部分だから．,4,"どのようなdpテーブルを構築するのかが書かれている部分だから
1番目でない理由は，dpで一番重要なのはどのように更新の条件を立てるかだと思ったから．",14,"最終的にも止まる答えがdpテーブルのどこにあたるのかということを示している部分だから．
3番である理由は，1,2番で示した部分が分かれば，この部分も直感的に分かるのではないかと思うから．",,まあ理解できた。,
12/14/2022 5:25:55,7,11,28,この問題の解法では，クイックソートと呼ばれるアルゴリズムを利用するということがこの一行で分かり，アルゴリズム名が判明すると解く方針も分かりやすくなるから．,19,"クイックソートでは，再起的に領域を狭めながらソートを実現するアルゴリズムであることがこの一行でわかるから．(20行目も同様だと思います．)
1番でない理由は，ここだけではどのようなアルゴリズムなのか全体を把握はできないため．",15,"pivotより小さい数を左に，大きい数を右にという操作を行うというクイックソートのそれぞれの試行で行われている操作がこの一行で分かるから．
3番目である理由は，1番目のクイックソートとアルゴリズム名の判明と2番目の再起的に行うことで高速化していることよりは重要度が低いと考えたため．",2: 再起の終了条件を明示している部分だから．,まあ理解できた。,
12/14/2022 23:45:29,7,12,37,この問題の解法はセグメントツリーと呼ばれるアルゴリズムを用いるということがこの行から読み取れるから．,14,"この行より，どのように問題に適したセグメントツリーを構成するかが分かるから．
1番でない理由は，具体的なアルゴリズム名(セグメントツリー)が分かることよりは重要ではないと考えたから．",29,"どのように最小値を得るのかをこの行で表されているから．
3番目である理由は，セグメントツリーの構造が分かれば，どのように得られるのかは分かる場合が多いと思うから．",,まあ理解できた。,
12/15/2022 0:59:12,7,13,45,この問題の解法ではクラスカル法を用いるということがこの一行で分かるから．,27,"クラスカル法では辺の重みの小さい順に取り出すことで最小全域木を求めることができるということがこの行で分かるから．
1番でない理由は，クラスカル法の解法を知っている人であれば分かることであるから．",28,"クラスカル法の中ではUnionTreeを用いながら同じ集団に属しているかどうかを判断できるということが分かるから．
3番である理由は，最小全域木を求めることに直接関係するわけではなく，どのように取り出した辺がすでに同じ集合に属しているわけではないということを判定するかということを表しているから．",,まあ理解できた。,
12/15/2022 1:55:43,7,14,29,今回の解法ではマージソートとよばれるアルゴリズムを用いるということがこの行で分かるから．,5,"マージソートは再起関数で小さい範囲から徐々に範囲を大きくしていくことで最終的に配列全体をソートできるということが分かるから．(6行目も同様だと思います．)
1番でない理由は，マージソートというアルゴリズムを知っていればどのようにそのアルゴリズムを実現できるかはわからることだから．",11,"マージソートにおいて，二つに分けてソートした配列をどのように1つにマージするかをこの条件分岐で見ることができるから．
3番である理由は，マージソートのアルゴリズムの一部であり，このこと自体がすごく重要であるわけではないから．",,まあ理解できた。,
12/15/2022 2:01:12,7,15,23,この問題を解くために，ベルマンフォード法と呼ばれるアルゴリズムを用いれば良いということがこの行から読み取れるから．,7,"ループの中でどのような条件を満たせば値の更新を行なっていくのかということがこの行で現れているから．
1番でない理由としては，これはベルマンフォード法の一部分であり，この部分だけからではアルゴリズム全体を把握できるわけではないから．",9,"どのように負の経路を見つけるかということがこの条件文に書かれているから．
3番である理由は，負の経路があることは例外的なものであり，問題全体的に関係する部分ではないから．",,まあ理解できた。,
12/15/2022 8:41:24,7,16,15,この問題の解法では，挿入ソートとよばれるアルゴリズムを利用すれば良いということがこの一行で分かるから．,5,"挿入ソートアルゴリズムでは，配列の要素を自分より左側の数字に自分より大きい数がないように要素を挿入していくことをこの文の条件で表しているから．
1番でない理由としては，挿入ソートアルゴリズムを知っている場合はこの操作を行う必要があることを理解できるから．",2,"一番先頭の要素から順に見ていくことで配列全体をソートできるため，どのようにループを回すのかということは重要だと思ったから．
2番ではない理由は，挿入操作自体の方がソートにおいて重要だったと思ったから．",,まあ理解できた。,
12/15/2022 14:37:13,7,17,33,この問題の解法ではダイクストラ法を使うということが分かり，アルゴリズム名を知っている人であれば，ここからどのように解くことができるのか考えることができるから．,10,"ダイクストラ法において，次に更新していく元となる頂点は，まだ見ていない頂点でかつコストが最小である頂点であるということがこの行で分かるから．
1番でない理由は，これはダイクストラ法の具体的な中身であり，ここからアルゴリズム全体が分かるというわけではないから．",18,"ダイクストラ法において，見つけた最小コストを持つ頂点を起点にその周りの頂点のコストを更新していくという操作のための条件がこの行で示されているから．
3番である理由は，2番での頂点を見つける操作を経た上でこの操作を行うから．",,まあ理解できた。,
12/15/2022 14:57:09,7,18,26,この問題の解法では，シェルソートと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,18,"シェルソートでは，間隔hを徐々に小さくしながらソートを行なっていくことで可能なアルゴリズムであり，そこが一番特徴的な部分であると思ったから．
1番ではない理由としては，この部分だけではシェルソートでどのようにソートを行うのかの全体は把握できないから．",14,"間隔hごとに自分より左側に自分より小さい数がないようにソートしていくことでソートが可能であることについて，この条件式で行っているから．
3番である理由は，この部分は挿入ソートなど他のアルゴリズムでも行うものであり，シェルソート特有のものというわけではないから．",,まあ理解できた。,
12/15/2022 15:04:29,7,19,31,この問題ではラビンカープ文字列探索アルゴリズムを用いるということがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,22,"文字列をハッシュにして，それが等しいかどうかを比較することで文字列の探索を行うということがこの行から分かるから．
1番でない理由は，この行だけではどのようにハッシュを形成するかなど全体的なアルゴリズムを把握することができないため．",15,"ハッシュをどのように計算するのか，ハッシュの定義がここで分かるから．
3番目である理由は，2番目で挙げた，ハッシュを比較するという考え方の前提があった上でどのようにハッシュを計算するのかという考えの流れになると思ったから．",21: どのように効率的に部分文字列のハッシュを計算するのかがこの行から分かるから．,まあ理解できた。,
12/15/2022 15:14:06,7,20,25,この問題の解法では，シェーカーソートと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,4,"シェーカーソートでは，右から，左からの2通りの方向からのソートを行い，徐々に左右の範囲を狭めていくことでより効率的にソートを行うものであり，この行で「左右の範囲を絞りながらソートと行っている」ということが読み取れると思うから．
1番でない理由としては，この行だけでは具体的にどのようにそれぞれをソートしているのかといった，アルゴリズム全体を把握するのに不十分であるから．",9,"一回一回のソートアルゴリズムはバブルソートと同様に隣同士の要素を入れ替えていくということであるということがこの行で分かるから．(15行目も同様)
3番である理由は，この行の操作はシェーカーソート特有ではなく，バブルソートなどでも行うことであるから．",,まあ理解できた。,
12/15/2022 16:52:37,7,21,22,問題を解くためにstackのデータ構造を用いるということがこの行から分かり，問題を解くための大きなヒントとなる部分であるから．,27,"演算子が入力であった時は，直前の二つの入力を取り出して計算し，それを再びstackに挿入することで計算が可能であることがこの行で分かるから．(29,31行目も同様)
一番目ではない理由は，stackを利用するということ自体を思いつけないとこの処理を行うことはできないから．",19,"stackでは直前に入れた要素を取り出すようなデータ構造であることがこの行から分かり，この構造を用いることで正答を導き出すことができるから．
3番目である理由は，stackがどのようなデータ構造かをわかっている場合は，既知のことだから．",,まあ理解できた。,
12/15/2022 16:59:44,7,22,6,6行目のような式で最大公約数から最小公倍数を算出することで答えを求められるということが分かるから．,2,"最大公約数はユークリッドのの互除法を再帰関数の形で実装することによって効率的に求められるということがこの行から分かるから．
1番でない理由としては，この問題はそもそも最小公倍数を求めるものであるのにも関わらず，この行では最大公約数の求め方となってしまうため，なぜ最大公約数を求める必要があるのかの方が重要だと思ったから．",5,"すでに選択していない行のうち，関数の定義より入力を受け取る方が重要だと思ったから．
3番目である理由は，この行では入力を受け取っているだけであり，問題の解法には関係ないから．",,まあ理解できた。,
12/15/2022 17:11:06,7,23,28,この行から，あらかじめ求めておいた各値までの「2017に似た数字」の数の総数の配列を用意しておき，それを利用することで各クエリに対してより効率的に答えを返すことができるということが分かるから．,18,"エラトステネスの櫛のアルゴリズムを用いることで，あらかじめ出現する全ての数の素数判定を用意しておくことで素数判定をあとから簡単に行うことができるということがこの行から読み取れるから．
1番でない理由としては，素数判定を簡単に行うだけでは正解を導くということに直結しないから．",11,"このwhile文の中で一度素数だと分かった数の倍数を省いていくことでより効率的に素数判定を行えるようになったことがエラトステネスの櫛のアルゴリズムの一番の利点だと思うから．
3番目である理由としては，これはエラトステネスの櫛のアルゴリズムの一部であり，問題の答えには直結しないから．",8: 条件分をi<=Nではなく，iの二乗がNを超えないところまでと範囲を絞ることでより計算量を抑えているから．,まあ理解できた。,
12/15/2022 17:22:16,7,24,21,すでにソート配列の中に組み込んだ頂点から出る矢印を取り除いていくことで次の「自分を指す矢印がなくなった頂点」が現れ，次にソート配列に挿入されるべき頂点が分かるという，トポロジカルソートの基本的な操作の一つだから．,22,"自分を指す矢印がなくなった頂点から順にソート配列に入れていくことでトポロジカルソートを実現でき，この条件文がその条件を示しているから．
1番でない理由としては，1番に選んだ21行目の操作を行ったおかげで「自分を指す矢印がなくなった頂点」が順番に生まれていき，これが次にソート配列に組み込まれる頂点となるという論理の流れがあるため．",12,"トポロジカルソートはqueueのデータ構造を使うことでより簡単に実現できるということを示しているから．
3番である理由としては，特にqueueを用いなくてもstackなど別のデータ構造でも実現可能であるから．",,まあ理解できた。,
12/15/2022 18:00:18,7,25,26,問題で問われている最短距離を求めるためには幅優先探索を行えばよいということがこの行から分かるから．,7,"queueのデータ構造を用いることは幅優先探索を行うために重要であることだと思うから．
1番でない理由としては，この部分は幅優先探索のアルゴリズムの一部であり，問題を解くことには直結していないから．",11,"次に見る頂点候補(queue)のうち，古いものから順に取り出していくことで幅優先探索を実現できるということが分かるから．
3番である理由としては，古いもの順に取り出すということはqueueの基本的な使い方と合致しており，2番目があれば分かる操作であるから．",,まあ理解できた。,
12/15/2022 18:06:30,7,26,25,ワーシャル・フロイドアルゴリズムを用いることでこの問題を解くことができることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,5,"各頂点間の距離をこの行の式で更新していくことで徐々に最小距離を求めていくことができるから．
1番でない理由としては，これはワーシャル・フロイド法の具体的な方法であり．アルゴリズムについて知っている人にとっては既知のこととなってしまうから．",8,"負の経路の検出の方法がこの行で表されているから．
3番目である理由は，負の経路があることは例外的なパターンであり，全ての問題に共通するものではないから．","2,3,4: どの順番にfor文ループを回すのかということは重要だから．",まあ理解できた。,
12/15/2022 18:17:50,7,27,6,問題を解くために，ハッシュを用いることで効率的に探索を可能にしようとしていることがこの行で分かるから．,2,"ハッシュテーブルとして配列を用意し，そこにどのハッシュの数字が存在していたかを格納していくことで探索を効率的にしようとしていることが，このハッシュテーブルの宣言で読み取れるから．
1番でない理由としては，ハッシュテーブルよりどのようなハッシュを用いて計算していくのを表す6行目の方が重要であると考えたから．",8,"ハッシュの重複があった場合，次に空いているハッシュ値まで値をずらしていく，オープンアドレス法を用いる工夫がこの行から読み取れるから．
3番である理由としては，これは1,2番で挙げた行のハッシュテーブルを利用することに付随するものであり，より重要度は低いと思ったから．",,まあ理解できた。,
12/15/2022 18:33:17,7,28,39,この問題の解法では，SPFAと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,6,"SPFAではqueueを用いることでより効率的に頂点の最短距離を更新していくことができるため，queueを用いるということを表す行は重要であると思ったから．
1番でない理由は，SPDAのアルゴリズム全体をこの行だけで把握できるわけではなく，アルゴリズムの一部にすぎないから．",20,"最短距離を更新できそうなら更新していくという操作を順序に行うことで最終的に全体の最短距離を求めることに繋がるから．
3番である理由は，SPFAにおいてqueueを用いていることの方が重要ではないかと考えたから．","21: すでにqueueに挿入されている頂点はこの行の条件文で除くことで，重複しないようにでき，queueを用いても探索を実現することにつながっているから．
25: 負の経路の存在を判定するのに必要な条件だから．",まあ理解できた。,
12/15/2022 18:42:29,7,29,13,DPでこの行の条件式で値の更新を行っていくことで，最終的に問題で問われている回答を導き出すことが可能だから．,7,"必要なdpテーブルが，何番目の要素で幾つの価値までというdpテーブルであり，その宣言がこの行に書かれているから．特に，価値の総和の最大値が問題文より10000であることを踏まえてdpテーブルの大きさを定義している点が重要であると考えたから．
1番でない理由は，7行目の宣言だけでは，dpテーブルの要素が何を示しているのか分からず，13行目の式を直接見た方がわかりやすいから．",16,"最終的に求めたい答えがどのように得られるのかがこの条件文から分かるから．
三番目である理由は，dpテーブルの定義・更新の方法が分かれば答えの取得方法も分かるから．",,まあ理解できた。,
12/15/2022 18:53:11,7,30,28,この問題はダイクストラ法を用いることで解決できるということがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,8,"ダイクストラ法では優先度付きqueueで最小経路を持つ頂点から順に取り出すことで実現できるアルゴリズムであり，それを用いることが表れているこの行が重要ではないかと考えたから．
1番ではない理由としては，これはダイクストラ法の一部であり，これだけではアルゴリズム全体を把握することはできないため．",14,"この行の条件式で，現在一番最短距離の頂点からの距離を更新していくことで，最終的に最短距離を求めることが可能であるから．
3番である理由としては，ダイクストラ法の中で8行目の優先度付きqueueを用いて常に一番最短の距離の頂点を取り出してこの行の操作を行っていくことで最短距離を求めることが可能であり，8行目の方が重要だと思ったから．",,まあ理解できた。,
