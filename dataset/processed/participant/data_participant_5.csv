time,personID,problemID,1st,1st_reason,2nd,2nd_reason,3rd,3rd_reason,others,understanding,free
12/28/2022 12:33:41,5,1,8,「条件を満たすように範囲を広げる」という、尺取り法を用いた解法を端的に表しているから,7,8行目に右端を動かしていることのほうが本質的だが、左端を走査していることも本質的だから。,2,簡単にコーナーケースを処理できており大切だが、なくても解けること・尺取り法と関係ないため１番ではないと思った,11行：走査しながらのresの逐次更新は競プロなどでよく使う表現だから,とても理解できた。,
12/28/2022 12:52:42,5,2,37,SegmentTreeの典型問題であるため、「SegmentTree」という表記が登場し、セグ木を使用することが最もわかりやすい37行目を選んだ。,42,セグ木の一点更新クエリの仕様について、どのように入力すればよいかがわかりやすいから,44,セグ木の区間加算クエリの仕様について、どのように入力すればよいかがわかりやすいから。関数名が直感的であるため区間加算よりは重要度が低いと考えた。,,まあ理解できた。,"回答とは関係ないのですが、ans01,02のようにしていただけると辞書順になるのでソートが楽になるため、次回以降同様の実験をされる際は変更していただけると嬉しいなと思いました"
12/28/2022 12:59:36,5,3,5,計数ソートの根本的な考え方である、巨大な配列を用意している部分だから,7,計数ソートで実際にどのように配列を更新しているかがわかりやすいから,11,バケットに格納された数だけarrayにpushするという考え方が現れているから,10:計数ソートの計算量がO(n+k)であることを表している行だと思うから,とても理解できた。,
12/28/2022 13:19:47,5,4,19,二分探索木の挿入において、左右がどのように振り分けられるかを表している重要な部分だと思うから,23,左右の振り分けのルールを理解することが大前提だが、その後に疑問となりうる、すでに子ノードに値が振り分けられていた場合、再帰的な処理を行うことが読み取れるコードになっているから。,38,二分探索木の構築のほうが重要だと考えたが、出力における2種類の探索のうち、pre_orderのほうが直感的に捉えられると考え、出力部分を選んだ。,"39,40: pre_orderの巡回において、どの部分で再帰関数を呼び出しているかも重要だと思うから",とても理解できた。,重要性の評価とは関係なく競プロのコードとしてみた時、キーに重複があったときに無限ループが発生するような気がして少し違和感がありました。AOJのこの問題はライブラリの検証のためあると思っているので、コードの汎用性を優先したほうが良いのではないかなと思ってしまいました
12/28/2022 15:11:51,5,5,19,自分自身を呼び出しており、再帰を利用したDFSであることが明確にわかるから,5,DFSの問題なので再帰部分が最も大事だが、それが扱う隣接リストの構造が明確に分かる部分だから,25,頂点で探索を打ち切ることが伝わるため、再帰・隣接リストの構造と合わせてDFSアルゴリズムの全体を理解できるようになるから,"15,20 : 探索開始・終了時刻をどのタイミングで記録しているかがわかりやすいから",とても理解できた。,
12/28/2022 15:18:46,5,6,10,DPの処理がワンライナーで記述されており、どのようにDPテーブルが書き込まれているかわかりやすいから,7,"直感的に理解できる部分ではあるが、DPテーブルの設計について(V,Wに１を加えた大きさであること)の補足知識を得られるから",12,上記２つの行で処理の本質的な部分はすべて網羅しているが、補足として、DPテーブルのどの部分に最終的な結果が書き込まれていることが分かるから,,とても理解できた。,
12/28/2022 15:25:33,5,7,2,二分探索には様々な流派があり、読み手の「ok」の定義が曖昧だとコードの誤読を起こす。２行目を読むことで、「ok ⇔ 値がkey以上の集合」(めぐる式二分探索？)と理解できるため、重要だと考えた。,9,二分探索の基本的な考え方である、ngとokの中点を次回の探索点とするという考え方が分かるから。１番にしなかった理由は、二分探索が既知であればあまり本質的ではないため。,8,while文を使って二分探索を実装する際のテクニックとして学びのある行だから。二分探索の基本的な知識である点と、中点を次回の探索点にするという知識よりは重要度が低いと考え３番めにおいた。,,とても理解できた。,
12/28/2022 15:38:43,5,8,13,データがQueueを模した配列にどのように格納されているかのイメージを掴むことができるから,14,上記のデータの格納について理解することにあわせて、14行目を読むことでtailがどのような挙動をしているか分かるようになるため,19,データ構造についてイメージを掴めていることが前提となるが、popがどちらがわから行われているかを読み取ることができるから,,まあ理解できた。,
12/28/2022 15:46:44,5,9,25,そもそも、この経路パターン数の問題をnCrの形式に落とし込めること自体ある程度の発想と数学力が必要であるため、combination関数を呼び出している部分がもっとも重要であると考えた。,21,Combination関数の実装の本体であり、nCrの求め方を知るための重要なコードであるため、nCrを使う事自体の次に重要だと考えた。,7,"combination関数ではfactorial,power_modの２種類の関数を呼び出しているが、factorial関数はMODを用いていること以外は自然な実装であるのに対し、power_modは繰り返し二乗法を用いており、理解が必要であるため、３番目に重要な部分だと考えた。","8,9: 繰り返し二乗法における実際の計算を担っている部分であるため、再帰の部分の次に大切であると考えた。",まあ理解できた。,
12/28/2022 16:06:12,5,10,12,DPの遷移を端的に表しているため、本質的な部分がすべて集められているから,4,漸化式を見ても意味が汲み取りづらかった場合に、DPテーブルの大きさで、どのような値が格納されるテーブルなのかをある程度推測できるから,6,アルゴリズムとしてさほど重要な部分ではないが、DPの初期化として特殊な行であり、通常のDPとの差異が出ているところだから,,まあ理解できた。,
12/28/2022 16:44:00,5,11,19,クイックソートが再帰的な処理で、左と右にpivot以外を分けて処理しているのだということが、20行目と合わせて理解できるから。,20,クイックソートが再帰的な処理で、左と右にpivot以外を分けて処理しているのだということが、19行目と合わせて理解できるから。(後に登場したので、2番めに大切ということにしました),15,マーカーの移動だけではpivotより大きい/小さいものに分けることはできないが、このSwap処理が入ることで左右に振り分けられるのだということが分かるようになるから,8 ~ 17:クイックソートの根幹部分の実装は全体に意味があり、重要だと感じます,とても理解できた。,問題文の(配列の長さ、配列の要素の値等については特に考えなくて良い)という表現の意味があまり汲み取れなかったです
12/28/2022 16:53:53,5,12,37,Q2同様、SegmentTreeを使うこと自体がもっとも重要であると考えた。,7,SegmentTreeを使うことが最重要な前提であるとした上で、この問題のコードを書く上で気をつけるべき点として、初期化する際に演算minの単位元であるinfや最大の数である2^31-1で埋めている点がある。単にゼロ埋め、と覚えるのではなく、単位元を利用することを強調するという意味で、7行目が重要であると考えた。,39,7行目と同様、初期化のための数が2^31-1という巨大数であることを意識する必要があると考えたから。厳密には単位元ではないため、infよりは重要性が低いと感じた。,,まあ理解できた。,
12/28/2022 17:13:42,5,13,27,最小全域木の問題は、貪欲法で解くことができることが本質的な部分だと考えている。したがって、コストについてグラフをソートしている27行目が最も大切だと考えた。,32,ソートされた辺について、どのような条件で選んでいるかを知ることができるため重要だと考えた。しかし、貪欲法ということがわかればある程度推測可能であるため2番目においた。,12,"UnionFind関数について、唯一外部から呼び出されている関数であるため重要だと考えた。
UnionFIndについての知識があまりなくても、is_sameという命名がされているため起こっていることの想像がし易いと考えた。したがって、UnionFind内部の実装よりもそれを呼び出すkruskal関数のほうが重要だと考えたため、3番目においた。",43:27行目のG.sort()で、どのようにソートされているのか直感的には分かりづらいため、tupleのリストであることを知ることができ重要だと考えた。,とても理解できた。,
12/28/2022 17:19:41,5,14,12,マージソートで実際にマージしている部分であり、15行目とともに最重要だと考えた。,15,マージソートで実際にマージしている部分であり、12行目とともに最重要だと考えた。あとの方に登場していること、else節の中であるため、12行目のほうが重要ということにした。,5,マージ処理を理解するためには、2つの配列がソート済みであることを理解している必要がある。そのため、上記2つの行の補助的な役割として5行目が重要であると考えた。,"6: 5行目と同様の理由。
18 ~ 21:計算量を減らすための工夫であり、本質的ではないが必要。",まあ理解できた。,
12/28/2022 17:29:26,5,15,5,Dijkstra法やBFSなどとベルマンフォード法との大きな差異は、V回のループを回すことだと考えているため、この部分が最も如実に現れた5行目が最重要だと考えた。,9,この問題では、負の閉路検出のためにベルマンフォード法を採用している。したがって、「i回目のループで頂点の更新が起きた」という条件を表している9行目が2番目に重要だと考えた。最重要としなかったのは、9行目の把握のためにはV回ループを回すことを理解している必要があるため。,7,メモの更新という基本的なテクニックであるため上2つと比較して重要性は低いが、最短距離の更新がどのように行われているのかは重要だと考えた。,,とても理解できた。,
12/28/2022 17:38:32,5,16,6,挿入ソートという名前に反し、要素の挿入をswapの連続で実装しているため、理解に時間がかかり、最重要だと考えた。,4,6行目を含むwhile文を読解しているときに、tmpという数値が更新されないことを理解するため、定義文が6行目の次に重要だと考えた。,3,while文の中で、1度目の処理でarr[i]がswapの対象になるようになっている。これはコードを良く読まないとわからず、この手がかりが3行目にあるため3番目に重要だと考えた。,,とても理解できた。,
12/28/2022 19:33:24,5,17,10,結果的にdone[i]がFalseでありdist[i]が最小であるものをtmp_min_distとcurに代入していることが、この行をよく読まないと分からないと感じたから。,17,Djikstra法の本質である、もっとも距離の近い頂点から行ける頂点を全走査する考え方が表現されているから。1番ではないと判断した理由は、Djikstra法の概要を知っていれば読解の必要がなく内容を想像できる点。,31,特殊な入力方法を受け取るための実装であり、上位2つの行と違って直接解法には関わらないが、読解の必要があると考えたから。,,あまり理解できなかった。,
12/28/2022 19:54:47,5,18,15,14行目とあわせ、シェルソートが挿入ソートと類似であるという点を確認できるという意味で重要だと考えた。また、差分がhであることも理解できるためもっとも重要とした。,14,15行目と同様にシェルソートとの類似性がわかるが、hについての言及がなくシェルソートと全く同じ実装であるため2番めに重要だと考えた。,18,シェルソートの本質である、間隔を狭めながらソートしていくという部分を表現していて、重要だと考えた。ただし、読解というより見れば分かる部分であるため、3番めに重要とした。,,まあ理解できた。,
12/28/2022 20:39:25,5,19,21,ローリングハッシュの基本的な式であり、最も本質的だと考えた。,14,15行目とともに、ハッシュの具体的な計算方法がわかりやすく重要だと考えた。ただし、21行目とほぼ同じ処理であるため、1番ではないと考えた 。,7,コーナーケースの処理であり、重要だと考えた。ただしローリングハッシュとは関係ない部分なので3番めに重要だとした。ｌ,,とても理解できた。,
12/28/2022 20:48:53,5,20,9,ソートの中での本質的なSwapであるため、もっとも重要であると考えた。,15,同じくSwapであるため重要だが、9のほうが先に出ているため2番めに重要だと考えた。,12,"特殊な代入演算子を利用しているため、1,2番に置くほど重要ではないがある程度の重要性はあると考えた。",,まあ理解できた。,
12/28/2022 20:57:42,5,21,29,この問題はStackを使用できるという部分が非自明であるため、Stackそのものの実装よりもStackを利用している部分のほうが重要であると考えた。その中で3種類の演算子はほぼ同様の処理で実現できるが、唯一符号が逆になっており注意が必要な29が最も重要であると考えた。,33,+ や × の演算子よりも、数値がpushされたときのStackの扱い(ただpushすればよい)という点が重要だと考え、2番目に重要であるとした。,27,+ や ×の演算子の扱いについても上2つについで重要であると考え、先に登場した27行目が3番めに重要であるとした。,"31行目：*についての処理が書かれており、重要
12行目,18行目: push,popについてlistで実装する際のhead変数の扱いが書かれており、重要",とても理解できた。,
12/28/2022 21:00:34,5,22,2,GCDを再帰を利用して求めるというのは、現実的な計算量で回答を実装するにあたって重要だと考えた。,6,"LCMを求めるにあたって、a * b / GCD(a,b) を計算するという部分であり、この問題の本質的なところだと感じたため。ただし、問題からGCDを計算するという考え方に至るまでさほど遠くないと考え、2番めに重要だと考えた。",5,mapを用いて入力を受け取るための手法が書かれており、3番めに重要だと考えた。,,とても理解できた。,
12/28/2022 21:06:31,5,23,28,この問題は、概ね「累積和リストを利用した区間和」と「エラトステネスの篩を利用した素数の列挙」の2つの要素がある。そのうち、累積和リストを利用した実装のほうが思いつきづらく、より問題を解くのに本質的だと考えたため、累積和をどのように使えばよいかが書かれている28行目がもっとも重要だと考えた。,22,エラトステネスの篩の関数内部については、どの行もひとしく重要であると考え、特定の行を選ぶことはできないと感じた。したがって、この問題の「2017に似た数」という部分を条件式に起こした22行目が、累積和ほど非自明な実装でないにせよ、２番目に重要だと思った。,23,累積和リストの実装の中の一部であり、上２行と違い１行で大きな意味を持っているわけではないため３番めに重要だと考えた。,"4 ~ 15行:典型的だが、エラトステネスの篩の実装であり重要
21: 累積和の更新部分であり、重要",とても理解できた。,
12/28/2022 21:36:26,5,24,8,プログラム内で何度も使用されるin_degreeという配列がどのようなものなのかについて、入次数という概念を知らなくても8行目を読めば理解できるため。逆に、これがわからなければ理解が難しいと考え、もっとも重要だとした。,22,8行目でin_degreeについて理解した事が前提ではあるが、queueにどのようなものが追加されているのかを理解できるため重要だと考えた。,18,上2つとは違い、プログラミングのテクニックとして重要な部分ではあるが、queueの中身がある間実行する というpython特有の書き方なので重要だと考えた。,,まあ理解できた。,
12/28/2022 21:45:56,5,25,15,BFSの本質的な部分であると同時に、この部分をappendleftにするとDFSという別のアルゴリズムになってしまうため、絶対に間違えてはいけない重要な部分だと考えた。,11,15行目をappendleftにしていても、11行目がpopだとDFSになる。appendのほうが本質的に感じたが、15行目と同様にこの部分も非常に大切だと考えた。,13,BFSの更新処理について、実際にdist配列を変更する部分であり、BFS/DFS共通の部分なので上2つより優先度は下がるが重要だと考えた。,6: 初期化しないとBFSを開始できないから,まあ理解できた。,
12/28/2022 21:51:44,5,26,2,"自分がワーシャルフロイド法のコードを書く際に、i,j,kの順番を誤る事が多く、とくに中点であるkについて先に走査するという部分が間違えやすいと感じたので、この部分が最重要だと感じた。",5,一度覚えれば忘れづらいため一番大切ではないと思ったが、ワーシャルフロイド法の本質的な部分であり、2番目に重要だと考えた。,8,ワーシャルフロイド法を調べると2~6行目の部分の情報を得られることが多いが、その他でマイナーな負の閉路検出を行う手法について知ることができる手法が書かれている8行目が3番めに重要だと考えた。,,とても理解できた。,
12/28/2022 22:03:24,5,27,8,insert関数を見ると、10^9までの数を10^4の配列におさめていることがわかり、その手法として8行目の操作をしていることがわかるため、もっとも重要だと考えた。,18,insertではすべてのiについてハッシュを試しており、どのような条件で探索を行うのか想像がつきづらいが、18行目を読むことでhash[index]=-1となるまで探索を進めていることがわかり、どのように数値が格納されているかわかりやすく成るため2番目に重要だと考えた。,9,"8,18行目で行われた処理についての補足として、探索と同様に挿入の際にもhash[i]=-1となるまで右に探索を進めていくということがわかるから。",,あまり理解できなかった。,
12/28/2022 22:13:45,5,28,25,Dijkstra法について知っている前提で考えると、DijkstraでなくSPFAを使う最大の理由であろう負の閉路検出について書かれている25行目がもっとも大切だと考えた。,21,"dijkstra法との違いのない部分なので重要度は落ちるが、queueにappendするかどうかの判断基準の部分なので重要だと考えた。
",23,21行目を理解するにあたって、queue_flagとはどのようなフラグなのかを知るのに必要であるため23行目が3番目に大切だと考えた。,,まあ理解できた。,私の勘違いである可能性もありますが、このコードならqueueの命名はstackが適切なように思えます。
12/28/2022 22:29:52,5,29,7,制約により、実際のvの上限が10000を超えないことがこの問題の最大のポイントであると感じた。したがって、この部分がコードに現れている7行目がもっとも大切だと考えた。食わてinfで初期化していることもわかり、とても多くの情報量を得られる行だと思う。,13,"DPテーブルのi,jの意味が7行目だけでは掴みづらいときに、漸化式を見て何が起こっているのか知ることができるので重要だと考えた。ただし、漸化式の理解の前にvがたかだか1万であることを把握しておく必要があると考えたので2番目に重要だとした。",15,条件を満たす最大のvを出力するため、reversed関数を使用しており、シンプルな実装の鍵になっているため重要だと考えた。ただし問題を解く部分に関連しないため3番目においた。,,とても理解できた。,
12/28/2022 22:32:46,5,30,1,このコードだけでは、Dijkstra法で利用しているheapqが内部でソートが保たれていることが分からない。そこで、heapqについて調べておくことが理解に不可欠であると考え、import文のある1行目を最も大切だと考えた。,16,heapqの挙動(heappushの引数)について理解したのち、queueに何がpushされているのかを理解することができるため、16行目が2番目に大切だと考えた。,15,距離の更新を実際に行っているため、重要だと考えた。ただし、基礎的なものであるため3番目においた。,,とても理解できた。,
