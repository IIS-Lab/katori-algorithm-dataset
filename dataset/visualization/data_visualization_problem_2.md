# 問題番号2
## 基本情報
- トピック : セグ木(RSQ)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7145085#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  class SegmentTree:
2      def __init__(self, size):
3          x = 1
4          while size > x:
5              x *= 2
6          self.n = x
7          self.arr = [0 for _ in range(2 * self.n - 1)]
8  
9      def set(self, i, x):
10         self.arr[i + self.n - 1] = x
11 
12     def build(self):
13         for i in reversed(range(0, self.n - 1)):
14             self.arr[i] = self.arr[2 * i + 1] + self.arr[2 * i + 2]
15 
16     def add(self, i, x):
17         i += self.n - 1
18         self.arr[i] += x
19         while i > 0:
20             i = (i - 1) // 2
21             self.arr[i] = self.arr[2 * i + 1] + self.arr[2 * i + 2]
22 
23     def _get_sum_rec(self, x, y, i, cur_l, cur_r):
24         if cur_r <= x or y <= cur_l:
25             return 0
26         elif x <= cur_l and cur_r <= y:
27             return self.arr[i]
28         else:
29             return self._get_sum_rec(x, y, 2 * i + 1, cur_l, (cur_l + cur_r) // 2) + self._get_sum_rec(x, y, 2 * i + 2, (cur_l + cur_r) // 2, cur_r)
30 
31     def get_sum(self, x, y):
32         return self._get_sum_rec(x, y, 0, 0, self.n)
33 
34 
35 n, q = map(int, input().split())
36 
37 tree = SegmentTree(n)
38 
39 for i in range(q):
40     com, x, y = map(int, input().split())
41     if com == 0:
42         tree.add(x - 1, y)
43     else:
44         print(tree.get_sum(x - 1, y))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
class SegmentTree:                                                                                                                                   1  ▲
    def __init__(self, size):                                                                                                                        2  
        x = 1                                                                                                                                        3  
        while size > x:                                                                                                                              4  
            x *= 2                                                                                                                                   5  
        self.n = x                                                                                                                                   6  
        self.arr = [0 for _ in range(2 * self.n - 1)]                                                                                                7  ★★
                                                                                                                                                     8  
    def set(self, i, x):                                                                                                                             9  
        self.arr[i + self.n - 1] = x                                                                                                                 10 
                                                                                                                                                     11 
    def build(self):                                                                                                                                 12 
        for i in reversed(range(0, self.n - 1)):                                                                                                     13 
            self.arr[i] = self.arr[2 * i + 1] + self.arr[2 * i + 2]                                                                                  14 ●▲
                                                                                                                                                     15 
    def add(self, i, x):                                                                                                                             16 
        i += self.n - 1                                                                                                                              17 ▲
        self.arr[i] += x                                                                                                                             18 
        while i > 0:                                                                                                                                 19 
            i = (i - 1) // 2                                                                                                                         20 ▲
            self.arr[i] = self.arr[2 * i + 1] + self.arr[2 * i + 2]                                                                                  21 ●●●●●●●▲
                                                                                                                                                     22 
    def _get_sum_rec(self, x, y, i, cur_l, cur_r):                                                                                                   23 
        if cur_r <= x or y <= cur_l:                                                                                                                 24 ▲
            return 0                                                                                                                                 25 
        elif x <= cur_l and cur_r <= y:                                                                                                              26 ●
            return self.arr[i]                                                                                                                       27 ●
        else:                                                                                                                                        28 
            return self._get_sum_rec(x, y, 2 * i + 1, cur_l, (cur_l + cur_r) // 2) + self._get_sum_rec(x, y, 2 * i + 2, (cur_l + cur_r) // 2, cur_r) 29 ★★★★★★▲▲▲▲
                                                                                                                                                     30 
    def get_sum(self, x, y):                                                                                                                         31 
        return self._get_sum_rec(x, y, 0, 0, self.n)                                                                                                 32 
                                                                                                                                                     33 
                                                                                                                                                     34 
n, q = map(int, input().split())                                                                                                                     35 
                                                                                                                                                     36 
tree = SegmentTree(n)                                                                                                                                37 ★★★
                                                                                                                                                     38 
for i in range(q):                                                                                                                                   39 
    com, x, y = map(int, input().split())                                                                                                            40 
    if com == 0:                                                                                                                                     41 
        tree.add(x - 1, y)                                                                                                                           42 ●
    else:                                                                                                                                            43 
        print(tree.get_sum(x - 1, y))                                                                                                                44 ▲
```
## 重要な理由の結果
### 1行目
`class SegmentTree:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 4 まずこの問題をセグメント木を使って解こうとする発想が重要だから。ただ重要な処理をしている訳ではない。
### 2行目
`    def __init__(self, size):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`        x = 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`        while size > x:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`            x *= 2`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`        self.n = x`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`        self.arr = [0 for _ in range(2 * self.n - 1)]`
#### 1位 2人
- 8 問題を解くためにセグメント木というデータ構造を使う、というのがよく表れているから。
- 11 問題設定よりセグ木を使うことことで解答可能だと判断できる．セグ木のデータ構造を作成している行だから．
#### 2位 0人
#### 3位 0人
### 8行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    def set(self, i, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`        self.arr[i + self.n - 1] = x`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    def build(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`        for i in reversed(range(0, self.n - 1)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`            self.arr[i] = self.arr[2 * i + 1] + self.arr[2 * i + 2]`
#### 1位 0人
#### 2位 1人
- 7 セグメントツリーの基本的な構造が分かり，この構造からどのように問題を解くのかを考えることができるから．
1番でない理由としては，「セグメントツリー」というアルゴリズム名があったほうが問題の全体的な解き方を把握しやすいから．
#### 3位 1人
- 2 問題を答えるわけでもなく、問題の指示として陽に出ているわけでもないが、これからの計算をするうえでの準備をしている行であるから。
### 15行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`    def add(self, i, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        i += self.n - 1`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 6 うっかり忘れそうな処理だから。1 番や 2 番と比べると、瑣末な番号合わせだと言える。
### 18行目
`        self.arr[i] += x`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`        while i > 0:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`            i = (i - 1) // 2`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 1 子区間から親区間に遡って区間和を求めるという操作であり，セグメント木を成り立たせるための初期化として重要だと考えた．求めたい区間和を複数の区間に分割する操作に比べれば本質的でないと考え，3番目とした．
### 21行目
`            self.arr[i] = self.arr[2 * i + 1] + self.arr[2 * i + 2]`
#### 1位 0人
#### 2位 7人
- 2 問題に答える部分ではないが、問題の指示として出てくる配列の一点更新を行う計算のメインがこの部分であるから。
- 3 一応セグ木というデータ構造における重要なのは更新式をこの式で再帰的に（ここではwhile文だが）行えることだから。
- 4 セグメント木を更新している部分だから。ただそれほど複雑な処理ではないため。
- 6 セグメントツリーにおける更新部分の根幹となる行だから。1 番でないのは、区間和計算ほど複雑ではないから。
- 8 セグメント木を作るための計算をしているところだから。セグメント木を使う、というアイデアの方が重要だと思ったので2番とした。
- 10 addもセグメント木の性質を使っていて、重要だと思いました。1番ではないのは、29行目の方が難しいと思ったため。
- 11 ツリー上で列の和を管理するデータ構造の要となる処理をしているところだと考えました．
#### 3位 1人
- 9 セグメント木においては一点更新の仕方が区間和の処理の仕方の次に重要なポイントであると考えており、21行目はまさしく一点更新の仕方を言い表しているから。
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    def _get_sum_rec(self, x, y, i, cur_l, cur_r):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
`        if cur_r <= x or y <= cur_l:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 10 cur_r <= x or y <= cur_lのような場合分けは、忘れやすいと感じたため。1番2番ほど難しくはないのかなと思ったため。
### 25行目
`            return 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`        elif x <= cur_l and cur_r <= y:`
#### 1位 0人
#### 2位 1人
- 1 現在見ている区間が求めたい区間に含まれている場合はその区間和を返すという部分であり，区間和を再帰的に求める上で重要な操作だと考えた．区間の分割の方がより本質的と考え，2番とした．
#### 3位 0人
### 27行目
`            return self.arr[i]`
#### 1位 0人
#### 2位 1人
- 9 区間和の計算において、今見ている区間が求めるべき区間にすべて含まれる場合は今見ている区間の結果をそのまま返す、ということが計算量削減のために重要であるから。ただし、このことは左半分の結果と右半分の結果をマージする、ということが前提となっているため、あくまで1番ではないという立ち位置でいる。
#### 3位 0人
### 28行目
`        else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`            return self._get_sum_rec(x, y, 2 * i + 1, cur_l, (cur_l + cur_r) // 2) + self._get_sum_rec(x, y, 2 * i + 2, (cur_l + cur_r) // 2, cur_r)`
#### 1位 6人
- 1 現在見ている区間を再帰的に分割することで区間和を求めるというセグメント木の本質部分だと考えたため．
- 2 問題のクエリに答える部分である、区間和を求める計算のメインがこの部分であるから。
- 4 セグメント木の性質を利用して再起的にgetSumを求める関数を呼び出している部分だから。
- 6 セグメントツリーにおいて最も複雑な、区間和を再帰的に計算する部分だから。
- 9 セグメント木における一番大事な要素は、区間和の計算方法であり、中でも左半分の区間の結果と右半分の区間の結果をマージすることを再帰的に繰り返すことで出来る、ということが最も大事な要素と考えている。29行目はまさしくこのことを表している行であるから。
- 10 セグメント木の性質や再帰を使っているところが非常に重要だと思いました。
#### 2位 0人
#### 3位 4人
- 3 一応セグ木というデータ構造における重要なのはクエリをこの式で再帰的に（ここではwhile文だが）行えることだから。
- 7 セグメントツリーでどのように特定の範囲の和を取得するのかということについて，再帰で和を取得するということがこの行でわかるから．
3番である理由としては，この部分だけではどのように値の更新などを行うかといったことについては分からず，問題の解き方に直結していないから．
- 8 部分和を求めるために再帰を用いるというのが重要だと思った。木を作る方が大切だと思ったので3番とした。
- 11 合計の値を取得する操作をしている箇所で，これも2番目に選んだ箇所と同様，データ構造特有の操作であるから．2番目と同列に考えています．2番目が一つしか選べなかったので3番目になりました．
### 30行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`    def get_sum(self, x, y):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`        return self._get_sum_rec(x, y, 0, 0, self.n)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`n, q = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 37行目
`tree = SegmentTree(n)`
#### 1位 3人
- 3 RSQはセグ木を使えば計算量的に効率よく解けることに気付ければ後はセグ木を作れるorとってこれるかだけなので。
- 5 SegmentTreeの典型問題であるため、「SegmentTree」という表記が登場し、セグ木を使用することが最もわかりやすい37行目を選んだ。
- 7 この問題の回答ではセグメントツリーと呼ばれるアルゴリズムを用いるということが明示されており，これを思いつけるかどうかが問題を解く鍵だと思うから．
#### 2位 0人
#### 3位 0人
### 38行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 39行目
`for i in range(q):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 40行目
`    com, x, y = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 41行目
`    if com == 0:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 42行目
`        tree.add(x - 1, y)`
#### 1位 0人
#### 2位 1人
- 5 セグ木の一点更新クエリの仕様について、どのように入力すればよいかがわかりやすいから
#### 3位 0人
### 43行目
`    else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 44行目
`        print(tree.get_sum(x - 1, y))`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 5 セグ木の区間加算クエリの仕様について、どのように入力すればよいかがわかりやすいから。関数名が直感的であるため区間加算よりは重要度が低いと考えた。
## 他の重要部分
- 9 : 3～6行目。セグメント木のサイズを2のべき乗にするという処理を行っている行であるため。
## 自由記述
- 5 : 回答とは関係ないのですが、ans01,02のようにしていただけると辞書順になるのでソートが楽になるため、次回以降同様の実験をされる際は変更していただけると嬉しいなと思いました
## 理解度
- とても理解できた。 : 4人, 4 6 9 11
- まあ理解できた。 : 7人, 1 2 3 5 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
