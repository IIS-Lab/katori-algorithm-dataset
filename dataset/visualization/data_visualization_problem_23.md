# 問題番号23
## 基本情報
- トピック : エラトステネスの篩+累積和
- 問題リンク : https://atcoder.jp/contests/abc084/tasks/abc084_d
- 解答リンク : https://atcoder.jp/contests/abc084/submissions/36922046
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  MAX = int(1e5)
2  
3  
4  def eratosthenes(N):
5      is_prime = [True for _ in range(N + 1)]
6      is_prime[0] = is_prime[1] = False
7      i = 2
8      while i * i <= N:
9          if is_prime[i]:
10             j = i * 2
11             while j <= N:
12                 is_prime[j] = False
13                 j += i
14         i += 1
15     return is_prime
16 
17 
18 is_prime = eratosthenes(MAX)
19 cumulative_sum = [0 for _ in range(MAX + 1)]
20 for i in range(1, MAX + 1):
21     cumulative_sum[i] += cumulative_sum[i - 1]
22     if i % 2 and is_prime[i] and is_prime[(i + 1) // 2]:
23         cumulative_sum[i] += 1
24 
25 Q = int(input())
26 for i in range(Q):
27     l, r = map(int, input().split())
28     print(cumulative_sum[r] - cumulative_sum[l - 1])
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
MAX = int(1e5)                                           1  
                                                         2  
                                                         3  
def eratosthenes(N):                                     4  
    is_prime = [True for _ in range(N + 1)]              5  
    is_prime[0] = is_prime[1] = False                    6  ●▲
    i = 2                                                7  
    while i * i <= N:                                    8  ●●
        if is_prime[i]:                                  9  ▲
            j = i * 2                                    10 
            while j <= N:                                11 ▲▲
                is_prime[j] = False                      12 ★★★●▲
                j += i                                   13 ★●▲
        i += 1                                           14 
    return is_prime                                      15 
                                                         16 
                                                         17 
is_prime = eratosthenes(MAX)                             18 ★★●
cumulative_sum = [0 for _ in range(MAX + 1)]             19 
for i in range(1, MAX + 1):                              20 
    cumulative_sum[i] += cumulative_sum[i - 1]           21 ★●▲▲
    if i % 2 and is_prime[i] and is_prime[(i + 1) // 2]: 22 ★●●●▲
        cumulative_sum[i] += 1                           23 ▲
                                                         24 
Q = int(input())                                         25 
for i in range(Q):                                       26 
    l, r = map(int, input().split())                     27 
    print(cumulative_sum[r] - cumulative_sum[l - 1])     28 ★★★●▲
```
## 重要な理由の結果
### 1行目
`MAX = int(1e5)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def eratosthenes(N):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    is_prime = [True for _ in range(N + 1)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    is_prime[0] = is_prime[1] = False`
#### 1位 0人
#### 2位 1人
- 11 0,1は素数ではないので，初期条件として自分で入れてあげる必要がある．前処理のような意味合いが強く感じるため2番目にしました．
#### 3位 1人
- 8 0と1は素数ではないという記述は、当たり前だが忘れてしまうと、すべて素数でないと判断されてしまうので重要。アルゴリズムというよりはコーナーケースの処理なので3番とした。
### 7行目
`    i = 2`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`    while i * i <= N:`
#### 1位 0人
#### 2位 2人
- 2 1 ~ 10^5の全部の数を素数判定する必要があるが、全部判定していると間に合わない。(10^5) ^ (1/2)までの数で試し割りすればいいという知見が出ている行なので、クエリの高速化に次いで重要だと考えた。
- 10 1番の上で、i * i <= Nとすることで計算量をこの部分の計算量をO(√N)に抑えることができて、重要であると思った。
#### 3位 0人
### 9行目
`        if is_prime[i]:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 6 エラトステネスの篩では、この条件付けによって合成数でない場合は処理をスキップできるため、漸近計算量が最大値 N に対し O(N log N) でなく O(N log log N) となる。計算量の (軽微な) 変化に関わるだけなので、1 番や 2 番ではない。
### 10行目
`            j = i * 2`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`            while j <= N:`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 2 エラトステネスの篩のアイデアで、xが素数ならxの倍数は素数ではない、という操作をしている部分なので、重要。割と自明なアイデアだと感じたので3番目にしました。
- 7 このwhile文の中で一度素数だと分かった数の倍数を省いていくことでより効率的に素数判定を行えるようになったことがエラトステネスの櫛のアルゴリズムの一番の利点だと思うから．
3番目である理由としては，これはエラトステネスの櫛のアルゴリズムの一部であり，問題の答えには直結しないから．
### 12行目
`                is_prime[j] = False`
#### 1位 3人
- 8 素数の倍数を候補から消していくという、エラトステネスのふるいというアルゴリズムを最もよく表した一文だから。
- 10 素数の倍数をFalseにしていて、エラトステネスの篩において重要だと思ったため。
- 11 倍数に対して素数でないことをメモしている箇所が要だと思ったため．
#### 2位 1人
- 1 ある素数の倍数(自身を除く)は合成数であるという事実を利用するアルゴリズムの考え方をよく表していると考えたため．1番目に選択した行の方がより端的に表していると考え，2番目に選択した．
#### 3位 1人
- 4 素数判定を効率的に行なっている部分だから。ただ素数判定はこの問題において道具でしかない。
### 13行目
`                j += i`
#### 1位 1人
- 1 ある素数の倍数(自身を除く)は合成数であるという事実を利用するアルゴリズムの考え方を最も端的に表していると考えたため．
#### 2位 1人
- 6 既に見つかっている素数の倍数を合成数として記録していくという、エラトステネスのふるいの根幹をなす部分である。問題固有の考察が含まれないので、1 番ほど重要でない。
#### 3位 1人
- 3 エラトステネスの篩で一番重要なのはこの特殊な全探索の更新処理だと考えるから。
### 14行目
`        i += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`    return is_prime`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`is_prime = eratosthenes(MAX)`
#### 1位 2人
- 3 この問題のコアは複数の数の素数判定はエラトステネスの篩で前計算すれば高速に処理できることだから。
- 9 エラトステネスの篩で素数判定を行い、それをテーブルに持つ処理を行う行であるから。今回の問題では10^5以下の素数の値が全て求まっている必要があるので、素数判定を行った結果を配列に格納する箇所が、最も重要であると考える。
#### 2位 1人
- 7 エラトステネスの櫛のアルゴリズムを用いることで，あらかじめ出現する全ての数の素数判定を用意しておくことで素数判定をあとから簡単に行うことができるということがこの行から読み取れるから．
1番でない理由としては，素数判定を簡単に行うだけでは正解を導くということに直結しないから．
#### 3位 0人
### 19行目
`cumulative_sum = [0 for _ in range(MAX + 1)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`for i in range(1, MAX + 1):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`    cumulative_sum[i] += cumulative_sum[i - 1]`
#### 1位 1人
- 2 L ~ Rで条件を満たすものの個数、というタイプのクエリに答える問題は累積和で考えると効率的に解けるので、そのアイデアを用いた部分を最重要だと評価した。
#### 2位 1人
- 3 この問題でもう一つの大事なアルゴリズムとして、累積和による区間和高速計算が挙げられるが、それを実現してるのはここのDP遷移式だから。
#### 3位 2人
- 1 累積和を用いて複数のクエリに対応するという考え方を表していると考えたため．一方でエラトステネスのふるいを用いることの方が発想として難易度が高いと考えこちらは3番目とした．
- 10 1番2番に注意して実装した関数を用いて、累積和により、区間の中の条件を満たす数の個数を出していて重要だと感じたため。
### 22行目
`    if i % 2 and is_prime[i] and is_prime[(i + 1) // 2]:`
#### 1位 1人
- 6 累積和配列への加算を条件を示した行で、問題を解くのに必要な前計算の根幹部分である。
#### 2位 3人
- 4 答えを求めるために必要なcumulative_sum[]を作るために重要な条件文だから。重要だが、問題文の条件をそのまま書いているだけであるため。
- 5 エラトステネスの篩の関数内部については、どの行もひとしく重要であると考え、特定の行を選ぶことはできないと感じた。したがって、この問題の「2017に似た数」という部分を条件式に起こした22行目が、累積和ほど非自明な実装でないにせよ、２番目に重要だと思った。
- 9 その数が2017に似た数であるかどうかを判定する箇所であるから。素数判定の結果を用いて2017に似た数かどうかの判定を行うため、素数判定の結果が前提と考え、1番とはしなかった。
#### 3位 1人
- 9 累積和配列を構築するパートであるから。これは素数判定と2017に似た数の判定が前提となっているため、重要度は1番目、2番目に比べると下がると考えた。
### 23行目
`        cumulative_sum[i] += 1`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 5 累積和リストの実装の中の一部であり、上２行と違い１行で大きな意味を持っているわけではないため３番めに重要だと考えた。
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`Q = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`for i in range(Q):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`    l, r = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`    print(cumulative_sum[r] - cumulative_sum[l - 1])`
#### 1位 3人
- 4 答えを求めるときにcumulative_sum[]の性質を利用して効率的に計算しているから。
- 5 この問題は、概ね「累積和リストを利用した区間和」と「エラトステネスの篩を利用した素数の列挙」の2つの要素がある。そのうち、累積和リストを利用した実装のほうが思いつきづらく、より問題を解くのに本質的だと考えたため、累積和をどのように使えばよいかが書かれている28行目がもっとも重要だと考えた。
- 7 この行から，あらかじめ求めておいた各値までの「2017に似た数字」の数の総数の配列を用意しておき，それを利用することで各クエリに対してより効率的に答えを返すことができるということが分かるから．
#### 2位 1人
- 8 累積和を用いて、素数の個数を計算量少なく求めようとしており、アルゴリズム的に重要だから。この方法は必ずしも必須ではないので2番とした。
#### 3位 1人
- 11 累積和を使ってある区間の和を求めている箇所．素数判定の方が重要だと考えたので，3番目にしました．
## 他の重要部分
- 5 : 4 ~ 15行:典型的だが、エラトステネスの篩の実装であり重要
21: 累積和の更新部分であり、重要
- 7 : 8: 条件分をi<=Nではなく，iの二乗がNを超えないところまでと範囲を絞ることでより計算量を抑えているから．
- 9 : 4～15行目：実際にエラトステネスの篩を用いた素数判定を行っている箇所であるため、ここの行も重要だと考えている。
## 自由記述
## 理解度
- とても理解できた。 : 10人, 1 2 3 4 5 6 8 9 10 11
- まあ理解できた。 : 1人, 7
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
