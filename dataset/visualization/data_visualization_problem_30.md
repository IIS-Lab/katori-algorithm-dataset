# 問題番号30
## 基本情報
- トピック : ダイクストラ法(優先度付きqueue)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_12_C&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144840#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  import heapq
2  
3  
4  def dijkstra(G, r):
5      dist = [float("inf") for _ in range(len(G))]
6      dist[r] = 0
7      queue = []
8      heapq.heapify(queue)
9      heapq.heappush(queue, (dist[r], r))
10 
11     while queue:
12         cur_dist, cur = heapq.heappop(queue)
13         for nxt, cost in G[cur]:
14             if dist[nxt] > cur_dist + cost:
15                 dist[nxt] = cur_dist + cost
16                 heapq.heappush(queue, (dist[nxt], nxt))
17 
18     return dist
19 
20 
21 n = int(input())
22 G = [[] for _ in range(n)]
23 for i in range(n):
24     edges = list(map(int, input().split()))
25     for j in range(edges[1]):
26         G[i].append((edges[2 * j + 2], edges[2 * j + 3]))
27 
28 ans = dijkstra(G, 0)
29 for index, cost in enumerate(ans):
30     print(index, cost)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
import heapq                                              1  ★
                                                          2  
                                                          3  
def dijkstra(G, r):                                       4  
    dist = [float("inf") for _ in range(len(G))]          5  ▲
    dist[r] = 0                                           6  
    queue = []                                            7  
    heapq.heapify(queue)                                  8  ●●▲▲
    heapq.heappush(queue, (dist[r], r))                   9  ★▲
                                                          10 
    while queue:                                          11 
        cur_dist, cur = heapq.heappop(queue)              12 ★★★★●
        for nxt, cost in G[cur]:                          13 
            if dist[nxt] > cur_dist + cost:               14 ★★▲
                dist[nxt] = cur_dist + cost               15 ●●▲▲▲
                heapq.heappush(queue, (dist[nxt], nxt))   16 ★●●●●●▲▲
                                                          17 
    return dist                                           18 
                                                          19 
                                                          20 
n = int(input())                                          21 
G = [[] for _ in range(n)]                                22 
for i in range(n):                                        23 ●
    edges = list(map(int, input().split()))               24 
    for j in range(edges[1]):                             25 
        G[i].append((edges[2 * j + 2], edges[2 * j + 3])) 26 ▲
                                                          27 
ans = dijkstra(G, 0)                                      28 ★★
for index, cost in enumerate(ans):                        29 
    print(index, cost)                                    30 
```
## 重要な理由の結果
### 1行目
`import heapq`
#### 1位 1人
- 5 このコードだけでは、Dijkstra法で利用しているheapqが内部でソートが保たれていることが分からない。そこで、heapqについて調べておくことが理解に不可欠であると考え、import文のある1行目を最も大切だと考えた。
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def dijkstra(G, r):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    dist = [float("inf") for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 8 十分に大きな値で初期化しておくというのは、ダイクストラ法の実行において大切だから。アルゴリズムそのものではないので3番とした。
### 6行目
`    dist[r] = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`    queue = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`    heapq.heapify(queue)`
#### 1位 0人
#### 2位 2人
- 3 ダイクストラ法で重要なのはコストが小さいものから探索すれば効率よく探索できることだが、優先度つきQueを使うことでこれを少ない計算量で実装できているから。
- 7 ダイクストラ法では優先度付きqueueで最小経路を持つ頂点から順に取り出すことで実現できるアルゴリズムであり，それを用いることが表れているこの行が重要ではないかと考えたから．
1番ではない理由としては，これはダイクストラ法の一部であり，これだけではアルゴリズム全体を把握することはできないため．
#### 3位 2人
- 1 優先度付きキューを使うという実装の工夫を表しているため選択した．アルゴリズムのロジックの部分ではないため1,2番目よりも重要度は下がると考えた．
- 10 1番2番の次に、ヒープの構造を利用して計算量を下げることが重要だと思ったため。
### 9行目
`    heapq.heappush(queue, (dist[r], r))`
#### 1位 1人
- 8 ヒープを使って最短経路を探索するというのはダイクストラ法の肝であるから。
#### 2位 0人
#### 3位 1人
- 9 最初に始まりの頂点と、距離0のデータを優先度付キューに入れている行であるから。細かい実装上の注意ではあるため、1番や2番ではないと考えているものの、ここを行わないと全く最短経路が更新されないため、重要と考えている。
### 10行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`    while queue:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`        cur_dist, cur = heapq.heappop(queue)`
#### 1位 4人
- 1 これまで見た頂点の中で最も距離が小さい点は距離を確定して良いというダイクストラ法の考え方が表されていると考えたため．
- 2 距離が確定した頂点見つける部分を、priority_queueを用いることにより高速化しているので、これが最重要。
- 4 現在までで最短距離を持つノードをヒープによって取り出すというのがダイクストラ法の本質だから。
- 11 最短距離が最も短い頂点を取り出すことがダイクストラにとって大事だと感じました．
#### 2位 1人
- 6 次に調べる頂点は、現在調査済みの頂点を用いて行ける最も近い頂点であるという、ダイクストラ法の特徴を示している。
#### 3位 0人
### 13行目
`        for nxt, cost in G[cur]:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`            if dist[nxt] > cur_dist + cost:`
#### 1位 2人
- 6 最短距離の更新条件を示している。最短路問題を解くアルゴリズムでは一般にこのような処理が必要。
- 9 最短経路の更新を行う条件を表す行であるから。最短距離の更新を行う条件を指定するため、一番重要と考えている。
#### 2位 0人
#### 3位 1人
- 7 この行の条件式で，現在一番最短距離の頂点からの距離を更新していくことで，最終的に最短距離を求めることが可能であるから．
3番である理由としては，ダイクストラ法の中で8行目の優先度付きqueueを用いて常に一番最短の距離の頂点を取り出してこの行の操作を行っていくことで最短距離を求めることが可能であり，8行目の方が重要だと思ったから．
### 15行目
`                dist[nxt] = cur_dist + cost`
#### 1位 0人
#### 2位 2人
- 2 最短距離が更新できるなら最短距離を更新するのは相変わらず重要アイデアなので、2番目に選んだ。
- 10 1番の工夫に加え、ダイクストラ法のアルゴリズムに基づいた値の更新も重要だと思ったため。
#### 3位 3人
- 3 ダイクストラ法にとってのコアではないが、最短経路探索法としてDPを使っていることは重要で、個々がその遷移式だから。
- 4 答えとなるdistを更新する行だから。ただダイクストラ法の本質ではないため。
- 5 距離の更新を実際に行っているため、重要だと考えた。ただし、基礎的なものであるため3番目においた。
### 16行目
`                heapq.heappush(queue, (dist[nxt], nxt))`
#### 1位 1人
- 10 ヒープを用いて、更新した後、一番小さいものが上に来るようにすることが重要だと思ったため。
#### 2位 5人
- 1 候補となる頂点を優先度付きキューに入れることで，短い順に取り出すことができるという実装上の最も重要な工夫であると考えたため．一方で，アルゴリズムの発想を表現している1番目ほどは重要でないと考えた．
- 4 1番の行で重要な役割を果たすヒープを更新する処理だから。あくまで処理としては更新のみのため。
- 5 heapqの挙動(heappushの引数)について理解したのち、queueに何がpushされているのかを理解することができるため、16行目が2番目に大切だと考えた。
- 8 最短経路が更新されたものはヒープにいれていくというのも、ダイクストラ法を実行する上で重要だから。ヒープを使うという事実の方が本質的だと思ったのでこちらは2番にした。
- 9 距離の情報と、頂点の情報を、（距離、頂点）の順に優先度付キューに入れることで、常に最短距離が最も小さい頂点のデータが取り出されるようになるから。更新を行う部分ではないため、1番ではないと考えている。
#### 3位 2人
- 6 2 番で述べたことを実現するためにここで push を行っている。
- 11 確定済みかを把握しておくのは大事なので選びました．どちらかというと工夫に近いのかなと感じたので，3番目にしました．
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`    return dist`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`n = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`G = [[] for _ in range(n)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`for i in range(n):`
#### 1位 0人
#### 2位 1人
- 11 距離が小さくなっていたら更新する箇所を選びました．どの探索候補を選ぶかの方が自明度が低いと思ったので，比較して2番目にしました．
#### 3位 0人
### 24行目
`    edges = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`    for j in range(edges[1]):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`        G[i].append((edges[2 * j + 2], edges[2 * j + 3]))`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 2 隣接リスト形式でグラフを表現することによりダイクストラ法は早く動くので、高速化のメイン箇所ではないが、残りの中ではここが重要であると考えた。
### 27行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`ans = dijkstra(G, 0)`
#### 1位 2人
- 3 この問題のコアはダイクストラ法で解けることに気付くことだから。
- 7 この問題はダイクストラ法を用いることで解決できるということがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．
#### 2位 0人
#### 3位 0人
### 29行目
`for index, cost in enumerate(ans):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`    print(index, cost)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
## 自由記述
- 9 : このソースコードにあるダイクストラ法だと、途中（12行目と13行目の間）で枝刈りがなされておらず、最短経路でない古いデータに対しても続く箇所での処理を行ってしまっているため、最悪ケースで計算量が二乗オーダーになってしまいます。（もし仮に枝刈りの処理がソースコード内にあった場合、「ここがなくても正しく動作はするものの、最悪ケースでの計算量が悪くなってしまうから」という理由で、2番目に重要な行に選択していました。）
## 理解度
- とても理解できた。 : 8人, 1 2 3 4 5 6 9 11
- まあ理解できた。 : 3人, 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
