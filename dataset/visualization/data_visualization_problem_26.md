# 問題番号26
## 基本情報
- トピック : ワーシャルフロイド法
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_C&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7130708#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  def floyd_warshall(G):
2      for k in range(len(G)):
3          for i in range(len(G)):
4              for j in range(len(G)):
5                  G[i][j] = min(G[i][j], G[i][k] + G[k][j])
6  
7      for i in range(len(G)):
8          if G[i][i] < 0:
9              print("NEGATIVE CYCLE")
10             return
11 
12     G = [["INF" if i == float("inf") else i for i in j] for j in G]
13     for i in range(len(G)):
14         print(*G[i])
15 
16 
17 V, E = map(int, input().split())
18 G = [[float("inf") for _ in range(V)] for _ in range(V)]
19 for i in range(E):
20     s, t, d = map(int, input().split())
21     G[s][t] = d
22 for i in range(V):
23     G[i][i] = 0
24 
25 floyd_warshall(G)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
def floyd_warshall(G):                                              1  
    for k in range(len(G)):                                         2  ★★●●●●●
        for i in range(len(G)):                                     3  
            for j in range(len(G)):                                 4  
                G[i][j] = min(G[i][j], G[i][k] + G[k][j])           5  ★★★★★★★●●●▲
                                                                    6  
    for i in range(len(G)):                                         7  ▲
        if G[i][i] < 0:                                             8  ●▲▲▲▲▲
            print("NEGATIVE CYCLE")                                 9  ●
            return                                                  10 
                                                                    11 
    G = [["INF" if i == float("inf") else i for i in j] for j in G] 12 ▲
    for i in range(len(G)):                                         13 
        print(*G[i])                                                14 
                                                                    15 
                                                                    16 
V, E = map(int, input().split())                                    17 
G = [[float("inf") for _ in range(V)] for _ in range(V)]            18 ▲▲
for i in range(E):                                                  19 
    s, t, d = map(int, input().split())                             20 
    G[s][t] = d                                                     21 ●
for i in range(V):                                                  22 
    G[i][i] = 0                                                     23 ▲
                                                                    24 
floyd_warshall(G)                                                   25 ★★
```
## 重要な理由の結果
### 1行目
`def floyd_warshall(G):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    for k in range(len(G)):`
#### 1位 2人
- 5 自分がワーシャルフロイド法のコードを書く際に、i,j,kの順番を誤る事が多く、とくに中点であるkについて先に走査するという部分が間違えやすいと感じたので、この部分が最重要だと感じた。
- 10 三つのfor文の順番に気をつけることが重要であると思ったため。
#### 2位 5人
- 1 経由頂点のループを一番外側にしなければ計算順序が間違ってしまい，ミスが起こりやすいと考えたため選択した．1番目で選択した箇所ほどアルゴリズムの本質を表している訳ではないので2番目とした．
- 3 ワーシャルフロイド法の肝は中継点から回してノード集合を増やしていくDPの探索順序だと考えているから。
- 6 k のループを外側にしないと酷い目に遭う。1 番に比べれば細かい注意点。
- 9 最初にkに関してループを回すことを表している行であるから。直接最短経路の更新を行う行ではないものの、ここの順番を間違えていると正しく動作しないため、この順番でやることが大切だと考えている。
- 11 kが一番外側に来ることが大事だと思います．実際に更新してる箇所の方がより本質に感じたので2番目にしました．
#### 3位 0人
### 3行目
`        for i in range(len(G)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`            for j in range(len(G)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`                G[i][j] = min(G[i][j], G[i][k] + G[k][j])`
#### 1位 7人
- 1 i, jの距離をkを経由する場合としない場合に分けて計算するというワーシャルフロイド法の重要な考え方を表しているため．
- 2 ぐるぐる回しながら最短距離が更新できるなら更新する、というのがワーシャルフロイド法なので、その更新している行が最重要だと考えた。
- 4 kを経由したほうが良いのかどうかを順番に見ていくというのがこのアルゴリズムの本質だから。
- 6 Warshall-Floyd 法は DP の一種であり、遷移式が最も重要。
- 8 三重ループを使いながら、最短経路を計算していくというのがワーシャルフロイド法の肝だから。
- 9 最短経路の更新を行っている行であるから。ここがなかったり、間違ったりしていると正しく動作しないため、ここが一番大事と考えている。
- 11 i->jの距離を間の中間地点kを確実に通った時に短くなるかどうかを見ていくのは大事な考え方だと思います．
#### 2位 3人
- 5 一度覚えれば忘れづらいため一番大切ではないと思ったが、ワーシャルフロイド法の本質的な部分であり、2番目に重要だと考えた。
- 7 各頂点間の距離をこの行の式で更新していくことで徐々に最小距離を求めていくことができるから．
1番でない理由としては，これはワーシャル・フロイド法の具体的な方法であり．アルゴリズムについて知っている人にとっては既知のこととなってしまうから．
- 10 1番に基づいて、5行目の式で更新することが重要であると思ったため。
#### 3位 1人
- 3 ワーシャルフロイド法に使っているDPの遷移式そのものはここだから。
### 6行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`    for i in range(len(G)):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 6 負閉路の存在条件を示している。1 番や 2 番と比べると最短路計算の文脈からは外れる。
### 8行目
`        if G[i][i] < 0:`
#### 1位 0人
#### 2位 1人
- 8 負の閉路ができていたときにそれを検知するというのも重要だから。最短経路の探索の方が重要だと思ったので2番にした。
#### 3位 5人
- 1 負閉路検出のための条件を表している箇所であるため選択した．1,2番目ほどアルゴリズムの核心部分ではないと考え3番目とした．
- 5 ワーシャルフロイド法を調べると2~6行目の部分の情報を得られることが多いが、その他でマイナーな負の閉路検出を行う手法について知ることができる手法が書かれている8行目が3番めに重要だと考えた。
- 7 負の経路の検出の方法がこの行で表されているから．
3番目である理由は，負の経路があることは例外的なパターンであり，全ての問題に共通するものではないから．
- 9 負閉路検出の条件を表している行であるから。負閉路検出は必ず毎回登場するとは限らないため、ワーシャルフロイドで常時注意する必要がある1番目や2番目よりは重要ではないと考えている。
- 10 1番2番と別に、負の閉路の検出をすることも得られた最短距離が正しいかに関わり、本質ではないが重要であるため。
### 9行目
`            print("NEGATIVE CYCLE")`
#### 1位 0人
#### 2位 1人
- 4 NEGATIVE CYCLEがあったかどうかを判定している部分だから。ただ判定方法は簡単だから。
#### 3位 0人
### 10行目
`            return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    G = [["INF" if i == float("inf") else i for i in j] for j in G]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 4 経路があるのかどうかを判定している部分だから。ただこれは更新も一瞬だから。
### 13行目
`    for i in range(len(G)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        print(*G[i])`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`V, E = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`G = [[float("inf") for _ in range(V)] for _ in range(V)]`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 8 十分に大きな値で初期化しておくことも、問題を正しく解くためには大事だから。アルゴリズムそのものではないので3番にした。
- 11 初期値をINFにしているところが大事だと感じました．前処理感がつよいので3番目にしました．
### 19行目
`for i in range(E):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`    s, t, d = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`    G[s][t] = d`
#### 1位 0人
#### 2位 1人
- 2 行列Gの初期値は基本的にinfだが、辺があるところは辺のコストにしておかないといけないので、アルゴリズムの直接的な部分ではないが、これも重要だと考えた。
#### 3位 0人
### 22行目
`for i in range(V):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    G[i][i] = 0`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 2 同じくある頂点から同じ頂点までの最短距離は自明に0なので、これも例外的に初期化しておかないといけない。2番目の行より後ろの行なので、3番目にした。
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`floyd_warshall(G)`
#### 1位 2人
- 3 ワーシャルフロイド法で解けることに気付くことがこの問題のコアだから。
- 7 ワーシャル・フロイドアルゴリズムを用いることでこの問題を解くことができることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 7 : 2,3,4: どの順番にfor文ループを回すのかということは重要だから．
## 自由記述
## 理解度
- とても理解できた。 : 7人, 2 3 4 5 6 9 11
- まあ理解できた。 : 4人, 1 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
