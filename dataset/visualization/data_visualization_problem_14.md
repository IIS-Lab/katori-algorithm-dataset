# 問題番号14
## 基本情報
- トピック : マージソート
- 問題リンク : https://drive.google.com/file/d/1TIx0AkrxxxW1MZxFGCpplkjHJe4mMUDP/view?usp=share_link
- 解答リンク : https://atcoder.jp/contests/math-and-algorithm/submissions/37034702
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  def merge_sort(arr):
2      if len(arr) <= 1:
3          return arr
4  
5      left_arr = merge_sort(arr[: len(arr) // 2])
6      right_arr = merge_sort(arr[len(arr) // 2 :])
7  
8      mem = []
9      cur_l = cur_r = 0
10     while cur_l < len(left_arr) and cur_r < len(right_arr):
11         if left_arr[cur_l] <= right_arr[cur_r]:
12             mem.append(left_arr[cur_l])
13             cur_l += 1
14         else:
15             mem.append(right_arr[cur_r])
16             cur_r += 1
17 
18     if cur_l < len(left_arr):
19         mem += left_arr[cur_l:]
20     if cur_r < len(right_arr):
21         mem += right_arr[cur_r:]
22 
23     return mem
24 
25 
26 N = int(input())
27 A = list(map(int, input().split()))
28 
29 print(*merge_sort(A))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
def merge_sort(arr):                                        1  
    if len(arr) <= 1:                                       2  ▲
        return arr                                          3  
                                                            4  
    left_arr = merge_sort(arr[: len(arr) // 2])             5  ★★★★★●●●●●▲
    right_arr = merge_sort(arr[len(arr) // 2 :])            6  ●●▲
                                                            7  
    mem = []                                                8  
    cur_l = cur_r = 0                                       9  
    while cur_l < len(left_arr) and cur_r < len(right_arr): 10 ★▲▲
        if left_arr[cur_l] <= right_arr[cur_r]:             11 ★★●●●▲▲▲
            mem.append(left_arr[cur_l])                     12 ★
            cur_l += 1                                      13 
        else:                                               14 
            mem.append(right_arr[cur_r])                    15 ●
            cur_r += 1                                      16 
                                                            17 
    if cur_l < len(left_arr):                               18 ▲▲▲
        mem += left_arr[cur_l:]                             19 
    if cur_r < len(right_arr):                              20 
        mem += right_arr[cur_r:]                            21 
                                                            22 
    return mem                                              23 
                                                            24 
                                                            25 
N = int(input())                                            26 
A = list(map(int, input().split()))                         27 
                                                            28 
print(*merge_sort(A))                                       29 ★★
```
## 重要な理由の結果
### 1行目
`def merge_sort(arr):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    if len(arr) <= 1:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 8 コーナーケースを記述するのも重要だから。あくまでコーナーケースなので3番にした。
### 3行目
`        return arr`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    left_arr = merge_sort(arr[: len(arr) // 2])`
#### 1位 5人
- 1 ソートしたい配列を，2つの配列に分割してソートした結果を利用してソートすることを繰り返すというマージソートの肝となる考え方が表されている部分だと考え1番目とした．
- 2 配列を左右に分けてsortしてmergeするのがマージソートだが、左右に分けている部分だから。
- 8 2分割したものを組み合わせて行ってソートするというマージソートのやり方をよく表している一文だから。
- 10 2つに分割して再帰でマージソートすることが大切であると思ったため。
- 11 リストを分けてそれぞれでソートするという考えが表れているように感じたから．
#### 2位 5人
- 3 マージソートで重要なのは分割統治と尺取り法だが、分割統治の方が本質だと思ったから。
- 4 マージソートの特徴である、まず半分、半分を分けていく処理を行なっているため。ただ、処理としては半分にして再起的に呼び出しているだけ。
- 6 マージソートの再帰的構造が表れている部分である。ソート自体を行うわけではないので 1 番ではない。
- 7 マージソートは再起関数で小さい範囲から徐々に範囲を大きくしていくことで最終的に配列全体をソートできるということが分かるから．(6行目も同様だと思います．)
1番でない理由は，マージソートというアルゴリズムを知っていればどのようにそのアルゴリズムを実現できるかはわからることだから．
- 9 マージソートが再帰的に左半分の要素と右半分の要素を呼び出していることを表す行であるから。配列をソートできることの本質部分ではないため、この部分は1番ではないと考えている。
#### 3位 1人
- 5 マージ処理を理解するためには、2つの配列がソート済みであることを理解している必要がある。そのため、上記2つの行の補助的な役割として5行目が重要であると考えた。
### 6行目
`    right_arr = merge_sort(arr[len(arr) // 2 :])`
#### 1位 0人
#### 2位 2人
- 1 ソートしたい配列を，2つの配列に分割してソートした結果を利用してソートすることを繰り返すというマージソートの肝となる考え方が表されている部分だと考えて選択した．1番目と同等の理由だが便宜上2番目とした．
- 2 配列を左右に分けてsortしてmergeするのがマージソートだが、左右に分けている部分だから。2番目に出てきたので2番目。
#### 3位 1人
- 6 マージソートの再帰的構造が表れている部分である。2 番と同様に重要。
### 7行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`    mem = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    cur_l = cur_r = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`    while cur_l < len(left_arr) and cur_r < len(right_arr):`
#### 1位 1人
- 4 マージソートで適切な順番に並べていくための繰り返し処理だから。
#### 2位 0人
#### 3位 2人
- 3 マージソートで重要なアルゴリズムである尺取り法の実装はこの内部だから。
- 9 左右どちらかの要素がなくなったら処理を終えることを表している行であるから。実装上の問題であり、アルゴリズムの本質部分とは言いにくい部分なので、この順位と考えている。
### 11行目
`        if left_arr[cur_l] <= right_arr[cur_r]:`
#### 1位 2人
- 6 それぞれソート済みの左列と右列から、どちらの先頭を答えの列に append するかを判定するという、ソートの根幹部分である。
- 9 左の値と右の値を比較して、小さいほうを先に配列memに格納することを表しており、この部分が配列をソートできることの本質であるから。
#### 2位 3人
- 8 マージソートにおいて、マージしていく順番を記述した重要な一文だから。1番の方がこのアルゴリズムをよく表していると思ったので2番にした。
- 10 1番ができた上で、小さい方から順に入れていくことが2番目に重要であると思ったため。
- 11 それぞれのリストを見て大小を比較していることがわかる行だから．分けて比べる再帰をしている方がより重要だとおもったので2番目です．
#### 3位 3人
- 1 ソート済の配列2つを使用し，2つの配列を左から見て各要素を比較することでソート済の大きい配列を得るという考え方が表されていると考えたため．配列をより小さな配列に分割するという考え方の方が重要と考え，3番目とした．
- 2 ソート列をマージしている部分なので、これが次に重要だと考えた。
- 7 マージソートにおいて，二つに分けてソートした配列をどのように1つにマージするかをこの条件分岐で見ることができるから．
3番である理由は，マージソートのアルゴリズムの一部であり，このこと自体がすごく重要であるわけではないから．
### 12行目
`            mem.append(left_arr[cur_l])`
#### 1位 1人
- 5 マージソートで実際にマージしている部分であり、15行目とともに最重要だと考えた。
#### 2位 0人
#### 3位 0人
### 13行目
`            cur_l += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`            mem.append(right_arr[cur_r])`
#### 1位 0人
#### 2位 1人
- 5 マージソートで実際にマージしている部分であり、12行目とともに最重要だと考えた。あとの方に登場していること、else節の中であるため、12行目のほうが重要ということにした。
#### 3位 0人
### 16行目
`            cur_r += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`    if cur_l < len(left_arr):`
#### 1位 0人
#### 2位 0人
#### 3位 3人
- 4 残りの部分を「答え」に加える処理をしているため。ただマージソートの本質ではない。
- 10 1番2番ができた上で、余った要素をくっつけることが大切だと思ったため。
- 11 2つのリストを比べた時にどちらかは最後まで見れてないので，その分の処理が必要だとわかる箇所．後処理的な位置付けだと思うので3番目に選びました．
### 19行目
`        mem += left_arr[cur_l:]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`    if cur_r < len(right_arr):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`        mem += right_arr[cur_r:]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    return mem`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`N = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`A = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`print(*merge_sort(A))`
#### 1位 2人
- 3 この問題のコアはマージソートを含めソートアルゴリズムで解けることなので。
- 7 今回の解法ではマージソートとよばれるアルゴリズムを用いるということがこの行で分かるから．
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 3 : 6: 5行目と同様。
- 5 : 6: 5行目と同様の理由。
18 ~ 21:計算量を減らすための工夫であり、本質的ではないが必要。
- 9 : 6行目：5行目と同じく、再帰的に求めることを表しているので、重要だと考えている。
18～21行目：左右どちらかの要素がなくなった場合、なくなっていない方の要素の残りを入れることを表しているため、重要だと考えている。
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 4 6 9 11
- まあ理解できた。 : 4人, 5 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
