# 問題番号4
## 基本情報
- トピック : 二分探索木(挿入・トラバース)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_8_A&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144606#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  class Node:
2      def __init__(self, n):
3          self.number = n
4          self.left = None
5          self.right = None
6  
7  
8  class BinarySearchTree:
9      def __init__(self):
10         self.root = None
11 
12     def insert(self, data):
13         cur = self.root
14         if cur is None:
15             self.root = Node(data)
16             return
17         else:
18             while True:
19                 if data < cur.number:
20                     if cur.left is None:
21                         cur.left = Node(data)
22                         return
23                     cur = cur.left
24                 elif data > cur.number:
25                     if cur.right is None:
26                         cur.right = Node(data)
27                         return
28                     cur = cur.right
29 
30     def in_order(self, node):
31         if node is not None:
32             self.in_order(node.left)
33             print(" " + str(node.number), end="")
34             self.in_order(node.right)
35 
36     def pre_order(self, node):
37         if node is not None:
38             print(" " + str(node.number), end="")
39             self.pre_order(node.left)
40             self.pre_order(node.right)
41 
42 
43 m = int(input())
44 tree = BinarySearchTree()
45 
46 for i in range(m):
47     order = input().split()
48     if order[0] == "insert":
49         tree.insert(int(order[1]))
50     else:
51         tree.in_order(tree.root)
52         print()
53         tree.pre_order(tree.root)
54         print()
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
class Node:                                       1  ●
    def __init__(self, n):                        2  
        self.number = n                           3  
        self.left = None                          4  
        self.right = None                         5  
                                                  6  
                                                  7  
class BinarySearchTree:                           8  
    def __init__(self):                           9  
        self.root = None                          10 
                                                  11 
    def insert(self, data):                       12 ▲
        cur = self.root                           13 
        if cur is None:                           14 ▲
            self.root = Node(data)                15 ●
            return                                16 
        else:                                     17 
            while True:                           18 ★
                if data < cur.number:             19 ★★★★★★★★
                    if cur.left is None:          20 
                        cur.left = Node(data)     21 ●▲
                        return                    22 
                    cur = cur.left                23 ●
                elif data > cur.number:           24 ●
                    if cur.right is None:         25 
                        cur.right = Node(data)    26 
                        return                    27 
                    cur = cur.right               28 
                                                  29 
    def in_order(self, node):                     30 ●
        if node is not None:                      31 
            self.in_order(node.left)              32 ★●●▲▲▲
            print(" " + str(node.number), end="") 33 ★●
            self.in_order(node.right)             34 
                                                  35 
    def pre_order(self, node):                    36 ▲
        if node is not None:                      37 
            print(" " + str(node.number), end="") 38 ●●▲▲▲
            self.pre_order(node.left)             39 ▲
            self.pre_order(node.right)            40 
                                                  41 
                                                  42 
m = int(input())                                  43 
tree = BinarySearchTree()                         44 
                                                  45 
for i in range(m):                                46 
    order = input().split()                       47 
    if order[0] == "insert":                      48 
        tree.insert(int(order[1]))                49 
    else:                                         50 
        tree.in_order(tree.root)                  51 
        print()                                   52 
        tree.pre_order(tree.root)                 53 
        print()                                   54 
```
## 重要な理由の結果
### 1行目
`class Node:`
#### 1位 0人
#### 2位 1人
- 11 木を作る上で大切な右と左の子をもつ要素を定義している箇所であるため．実際に探索している箇所の方が重要かなとおもったので2番目にしました．
#### 3位 0人
### 2行目
`    def __init__(self, n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`        self.number = n`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`        self.left = None`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`        self.right = None`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`class BinarySearchTree:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    def __init__(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`        self.root = None`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    def insert(self, data):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 7 疑似コードで触れられている二分木のinsertを実際に実装している部分だから．
3番である理由は，この問題では中間順巡回，先行順巡回でのノードの巡り方のアルゴリズムの違いが問われており，ここは本質ではないと思ったから．
### 13行目
`        cur = self.root`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        if cur is None:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 2 insertする本質とは関係ないが、実際にはこれがないと一番最初にエラーが起きてしまうので、そのコーナーケースを処理する部分として重要であると考える。
### 15行目
`            self.root = Node(data)`
#### 1位 0人
#### 2位 1人
- 10 self.rootがNoneの時の場合分けも非常に重要だと思ったため。1番ではないのは比較的気付きやすいと感じたため。
#### 3位 0人
### 16行目
`            return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`            while True:`
#### 1位 1人
- 3 この問題のコアは二分探索木というデータ構造そのものだと思うのですが、二分探索木で一番大事なのはまあここのwhileだけでinsert or  検索位置がわかることかなと思ったからです。
#### 2位 0人
#### 3位 0人
### 19行目
`                if data < cur.number:`
#### 1位 8人
- 1 二分探索木の構築において，ある要素Aの左部分木の要素は全てAより小さいという制約を表現しており，24行目も同様に導かれるため，最も重要だと考えた．
- 2 データ構造の重要な部分であるinsertにおいて、値が現在のノードより小さいときは左に入れる、という処理を行なっている部分であるから。
- 4 二分探索木を作成・値を挿入するときに最も重要になる条件分岐だから。
- 5 二分探索木の挿入において、左右がどのように振り分けられるかを表している重要な部分だと思うから
- 8 新たな値の挿入において、二分木の性質を活用しているところだから。
- 9 いま見ているノードよりも値が小さいときには左のノードに進むことを表す処理を表す箇所であり、二分探索木の作り方を分岐によって表現する点で重要であると考えている。
- 10 insertするときに、左右で場合分けすることが重要であると思ったため。
- 11 左の子には小さく，右の子には大きいという木の性質をつかって探索している行だから．
#### 2位 0人
#### 3位 0人
### 20行目
`                    if cur.left is None:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`                        cur.left = Node(data)`
#### 1位 0人
#### 2位 1人
- 9 二分探索木に値をセットするところであり、左のノードに進んだときに値が存在しなければそこに置く、という処理を表す箇所であり、二分探索木の進む方向を決めた後の処理を表現している点で、進む方向を決める処理の次に重要であると考えている。
#### 3位 1人
- 6 二分探索木構築において最も重要な、新たなノードを生成している部分だから。1 番や 2 番ではないのは、これは二分探索木における一般的な処理であり、本問はトラバーサルの部分の方を問われているから。
### 22行目
`                        return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`                    cur = cur.left`
#### 1位 0人
#### 2位 1人
- 5 左右の振り分けのルールを理解することが大前提だが、その後に疑問となりうる、すでに子ノードに値が振り分けられていた場合、再帰的な処理を行うことが読み取れるコードになっているから。
#### 3位 0人
### 24行目
`                elif data > cur.number:`
#### 1位 0人
#### 2位 1人
- 2 データ構造の重要な部分であるinsertにおいて、値が現在のノードより大きいときは右に入れる、という処理を行なっている部分であるから。19行目より後に出てきているので、こちらを2番にした。
#### 3位 0人
### 25行目
`                    if cur.right is None:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`                        cur.right = Node(data)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`                        return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`                    cur = cur.right`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`    def in_order(self, node):`
#### 1位 0人
#### 2位 1人
- 3 問題に効率よくこたえるためには不可欠なメソッドだから。逆に言えばコアな部分ではない。
#### 3位 0人
### 31行目
`        if node is not None:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`            self.in_order(node.left)`
#### 1位 1人
- 7 中間順巡回においては先に各ノードより左に位置するノードを見るということが重要であり，それがここで現れているから．
#### 2位 2人
- 1 中間順巡回のアルゴリズムを表す上で重要だと考え選択した．木の構築の方が本質的であることから2番目とした．
- 4 中間順巡回を行うために、どの引数を用いて再起的に関数を呼び出すかを決めているため。ただ、できている木を見ていくだけの処理。
#### 3位 3人
- 9 二分探索木の巡回を、再帰によって行うことを表しているから。この問題では二分探索木の構成が本質であると考えているため、先述の2つよりは重要度は低いと考えている。
- 10 再帰を使ったり、self.in_order(node.left)とprint(" " + str(node.number), end="")の順番に気をつけたりして、in_orderとpre_orderを実装することが重要だと感じたため。
- 11 nodeの情報を表現する方法としてinorder,preorderという概念があることは大事だと思います．一方で探索木をどう表そうとも載ってる情報の内容が変わるわけではないので3番目にしました．
### 33行目
`            print(" " + str(node.number), end="")`
#### 1位 1人
- 6 出力がこの位置にあることで in order トラバーサルとなっているから。
#### 2位 1人
- 8 中間順巡回と先行順巡回の違いがこのprint関数の位置によく表れているから。二分木の挿入の方が、二分木の本質だと思ったので2番にした。
#### 3位 0人
### 34行目
`            self.in_order(node.right)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
`    def pre_order(self, node):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 問題に効率よくこたえるためには不可欠なメソッドだから。逆に言えばコアな部分ではない。
### 37行目
`        if node is not None:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 38行目
`            print(" " + str(node.number), end="")`
#### 1位 0人
#### 2位 2人
- 6 出力がこの位置にあることで pre order トラバーサルとなっているから。重要度は 1 番と大して変わらないが、こちらの方が若干自明な気もする。
- 7 先行順巡回では先に自分自身のノードを見てからその子のノードへと移っていくことがこの行で現れているから．
1番でない理由は，中間順巡回に比べてこちらの方が直感的だと思ったから．
#### 3位 3人
- 1 行きがけ順のアルゴリズムを表す上で重要だと考え選択した．木の構築の方が本質的であること，行きがけ順ではソートされた列が選ばれないことから2番目とした．
- 5 二分探索木の構築のほうが重要だと考えたが、出力における2種類の探索のうち、pre_orderのほうが直感的に捉えられると考え、出力部分を選んだ。
- 8 2番目に重要だと思ったのと同じ理由。重要度は2番目と同じだと思った。
### 39行目
`            self.pre_order(node.left)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 4 先行順巡回を行うために、再起的に関数を呼び出している部分だから。ただ、この木においては中間順の方が重要な意味を持つ。
### 40行目
`            self.pre_order(node.right)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 41行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 42行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 43行目
`m = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 44行目
`tree = BinarySearchTree()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 45行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 46行目
`for i in range(m):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 47行目
`    order = input().split()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 48行目
`    if order[0] == "insert":`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 49行目
`        tree.insert(int(order[1]))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 50行目
`    else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 51行目
`        tree.in_order(tree.root)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 52行目
`        print()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 53行目
`        tree.pre_order(tree.root)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 54行目
`        print()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 5 : 39,40: pre_orderの巡回において、どの部分で再帰関数を呼び出しているかも重要だと思うから
- 6 : 26。21 行目と同様に重要
- 9 : 15行目。二分探索木に値がまだ入っていないときの処理を、別途場合分けによってあらわしている点で重要だと考えている。
24・26行目。それぞれ「一番大事な処理」「二番目に大事な処理」を左に進む場合で述べたが、右に進むの場合も当然重要である。
33・34・38～40行目。「三番目に大事な処理」を32行目で述べたが、これらの行も同じく二分探索木の巡回を再帰によって行うことを表しており、重要である。
## 自由記述
- 5 : 重要性の評価とは関係なく競プロのコードとしてみた時、キーに重複があったときに無限ループが発生するような気がして少し違和感がありました。AOJのこの問題はライブラリの検証のためあると思っているので、コードの汎用性を優先したほうが良いのではないかなと思ってしまいました
- 9 : 「左と右」や「通りがけ順と行きがけ順」のように、重要な行の中に2つのものが並列で並んでいるような箇所があり、それらの順位付けの扱いをどうするのかが非常に難しいと感じました。
## 理解度
- とても理解できた。 : 7人, 1 3 4 5 6 9 11
- まあ理解できた。 : 3人, 2 7 8
- あまり理解できなかった。 : 1人, 10
- まったく理解できなかった。 : 0人, 
