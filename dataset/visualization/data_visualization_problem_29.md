# 問題番号29
## 基本情報
- トピック : ナップサック問題(重さがでかいDP)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_F&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144833#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  N, W = map(int, input().split())
2  v = [0 for _ in range(N)]
3  w = [0 for _ in range(N)]
4  for i in range(N):
5      v[i], w[i] = map(int, input().split())
6  
7  dp = [[float("inf") for _ in range(10001)] for _ in range(N + 1)]
8  for i in range(N + 1):
9      dp[i][0] = 0
10 
11 for i in range(N):
12     for j in range(10001):
13         dp[i + 1][j] = min(dp[i][j], dp[i][j - v[i]] + w[i]) if j - v[i] >= 0 else dp[i][j]
14 
15 for i in reversed(range(10001)):
16     if dp[N][i] <= W:
17         print(i)
18         break
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
N, W = map(int, input().split())                                                            1  
v = [0 for _ in range(N)]                                                                   2  
w = [0 for _ in range(N)]                                                                   3  
for i in range(N):                                                                          4  
    v[i], w[i] = map(int, input().split())                                                  5  
                                                                                            6  
dp = [[float("inf") for _ in range(10001)] for _ in range(N + 1)]                           7  ★★●●●●●▲
for i in range(N + 1):                                                                      8  
    dp[i][0] = 0                                                                            9  ●●▲▲▲
                                                                                            10 
for i in range(N):                                                                          11 
    for j in range(10001):                                                                  12 ●
        dp[i + 1][j] = min(dp[i][j], dp[i][j - v[i]] + w[i]) if j - v[i] >= 0 else dp[i][j] 13 ★★★★★★★★★●●
                                                                                            14 
for i in reversed(range(10001)):                                                            15 ▲
    if dp[N][i] <= W:                                                                       16 ●▲▲▲▲▲
        print(i)                                                                            17 ▲
        break                                                                               18 
```
## 重要な理由の結果
### 1行目
`N, W = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`v = [0 for _ in range(N)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`w = [0 for _ in range(N)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`for i in range(N):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    v[i], w[i] = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`dp = [[float("inf") for _ in range(10001)] for _ in range(N + 1)]`
#### 1位 2人
- 1 本問題ではDPテーブルを作成する際に価値を軸に作成する工夫が必要であり，この問題を解く上でそこが最も重要だと考えるため．
- 5 制約により、実際のvの上限が10000を超えないことがこの問題の最大のポイントであると感じた。したがって、この部分がコードに現れている7行目がもっとも大切だと考えた。食わてinfで初期化していることもわかり、とても多くの情報量を得られる行だと思う。
#### 2位 5人
- 3 10001をハードコーディングしちゃっているが、普通のナップサックと違い、価値を横軸に取ったほうが計算量が少なくなることが重要だから。
- 4 DPテーブルをどのような構造にするのかを決める部分だから。ただ構造を決めているだけ。
- 7 必要なdpテーブルが，何番目の要素で幾つの価値までというdpテーブルであり，その宣言がこの行に書かれているから．特に，価値の総和の最大値が問題文より10000であることを踏まえてdpテーブルの大きさを定義している点が重要であると考えたから．
1番でない理由は，7行目の宣言だけでは，dpテーブルの要素が何を示しているのか分からず，13行目の式を直接見た方がわかりやすいから．
- 8 dpテーブルを大きな値で初期化しておくというのは、この問題を解く上で注意しなければならない点だから。テーブルを埋める方が本質的だと思ったのでこちらは2番にした。
- 10 1番の値の更新ができるように、dpテーブルを初期化することが重要だと思ったため。
#### 3位 1人
- 11 できるだけ小さい方が嬉しいパラメータの重さをINFで初期化していることが大事だと感じた．あくまで前処理の域を出ないと思うので3番目にしました．
### 8行目
`for i in range(N + 1):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    dp[i][0] = 0`
#### 1位 0人
#### 2位 2人
- 6 ナップサック DP の境界条件であり、遷移式ほど広範囲には影響しないものの必要な部分である。
- 9 DPの初期値を表す行であるから。初期値は遷移に比べると核心の部分ではないが、ここが間違っていると正しく動作しないため、ここは2番目に重要と考えている。
#### 3位 3人
- 2 漸化式にしたがって配列を埋めていくが、適切な初期化をしておかないと面倒なことになるので、若干薄い部分ではあるが、3番目に重要だと考えた。
- 4 DPテーブルの自明な部分を埋めているため。自明な部分なので、処理が単純だから。
- 10 1番2番に加え、最初の状態を0で初期化しておくことが重要だと思ったため。
### 10行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`for i in range(N):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    for j in range(10001):`
#### 1位 0人
#### 2位 1人
- 11 価値の合計値が10000を超えないことを利用して問題を解いているため．DPテーブルを埋めるの方が重要だと感じたので2番目にしました．
#### 3位 0人
### 13行目
`        dp[i + 1][j] = min(dp[i][j], dp[i][j - v[i]] + w[i]) if j - v[i] >= 0 else dp[i][j]`
#### 1位 9人
- 2 動的計画法の漸化式部分であり、この式が建てられれば解けたも同然なので、一番重要。
- 3 このナップサック問題の肝はDPで解けることに気付くことで、その遷移式がここだから。
- 4 DPテーブルを更新するというのがこの問題を解く本質となるから。
- 6 ナップサック DP の遷移式であり、解法そのものと言ってもよい。
- 7 DPでこの行の条件式で値の更新を行っていくことで，最終的に問題で問われている回答を導き出すことが可能だから．
- 8 動的計画法において、テーブルを埋めていく計算は最も重要なところだから。
- 9 DP遷移を表す行であるから。ここが全ての計算の核心の部分であるため、ここが最も大事と考えている。
- 10 動的計画法において、dpテーブルの値の更新が最も重要だと思ったため。
- 11 DP問題で遷移式がかければほぼ解けたような感覚があるので大事だと思います．
#### 2位 2人
- 1 DPの更新式が書かれているため選択した．本問題ではDPテーブルの構築の部分の方が発想としてより工夫が必要だと考え，こちらは2番目とした．
- 5 DPテーブルのi,jの意味が7行目だけでは掴みづらいときに、漸化式を見て何が起こっているのか知ることができるので重要だと考えた。ただし、漸化式の理解の前にvがたかだか1万であることを把握しておく必要があると考えたので2番目に重要だとした。
#### 3位 0人
### 14行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`for i in reversed(range(10001)):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 5 条件を満たす最大のvを出力するため、reversed関数を使用しており、シンプルな実装の鍵になっているため重要だと考えた。ただし問題を解く部分に関連しないため3番目においた。
### 16行目
`    if dp[N][i] <= W:`
#### 1位 0人
#### 2位 1人
- 2 DP[i][j]はi番目までの品物を見たときに、価値jを達成するために必要な重みのminなので、dp[N][i]がW以下の最大のiが答えなので、その答えを求めている部分は重要。さすがに漸化式のほうが重要なので2番目。
#### 3位 5人
- 1 本問題ではdpテーブルを利用し,値が特定の条件を満たすようなインデックスを返すという若干の工夫が必要であるため選択した．DPテーブルの構築，更新ほど重要ではないと考え，3番目とした．
- 3 求めたいのは価値なので、軸の方で適切なものを探索しているのはこの問題において重要かもしれない。
- 6 作成した DP テーブルから答えをどのように判断するかを示している。今回の場合は比較的自明度が高い。
- 7 最終的に求めたい答えがどのように得られるのかがこの条件文から分かるから．
三番目である理由は，dpテーブルの定義・更新の方法が分かれば答えの取得方法も分かるから．
- 8 この問題は必ずしも右下に答えがあるわけではない、というのは注意点で、その答えの探し方をしめしているところだから。テーブルを埋められて初めてここに辿り着くので、3番とした。
### 17行目
`        print(i)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 答えがDPテーブルのどこに現れるかを表す行であるから。直接計算に関わる箇所ではないため、1番目や2番目ではないと考えている。
### 18行目
`        break`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 5 6 9 11
- まあ理解できた。 : 4人, 4 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
