# 問題番号27
## 基本情報
- トピック : ハッシュによる探索
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_A&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7134442#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  MAX = 10000
2  hash = [-1 for _ in range(MAX)]
3  
4  
5  def insert(x):
6      hashed_x = x % MAX
7      for i in range(MAX):
8          index = (hashed_x + i) % MAX
9          if hash[index] == -1:
10             hash[index] = x
11             break
12 
13 
14 def search(x):
15     hashed_x = x % MAX
16     for i in range(MAX):
17         index = (hashed_x + i) % MAX
18         if hash[index] == -1:
19             return False
20         elif hash[index] == x:
21             return True
22     return False
23 
24 
25 n = int(input())
26 S = list(map(int, input().split()))
27 q = int(input())
28 T = list(map(int, input().split()))
29 
30 for s in S:
31     insert(s)
32 ans = 0
33 for t in T:
34     if search(t):
35         ans += 1
36 
37 print(ans)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
MAX = 10000                          1  
hash = [-1 for _ in range(MAX)]      2  ★●
                                     3  
                                     4  
def insert(x):                       5  
    hashed_x = x % MAX               6  ★★▲
    for i in range(MAX):             7  ▲
        index = (hashed_x + i) % MAX 8  ★★★★●●●●▲▲
        if hash[index] == -1:        9  ★▲
            hash[index] = x          10 ★
            break                    11 
                                     12 
                                     13 
def search(x):                       14 
    hashed_x = x % MAX               15 ▲
    for i in range(MAX):             16 
        index = (hashed_x + i) % MAX 17 ★●
        if hash[index] == -1:        18 ★●●●▲
            return False             19 
        elif hash[index] == x:       20 ●●▲▲▲
            return True              21 
    return False                     22 ▲
                                     23 
                                     24 
n = int(input())                     25 
S = list(map(int, input().split()))  26 
q = int(input())                     27 
T = list(map(int, input().split()))  28 
                                     29 
for s in S:                          30 
    insert(s)                        31 
ans = 0                              32 
for t in T:                          33 
    if search(t):                    34 
        ans += 1                     35 
                                     36 
print(ans)                           37 
```
## 重要な理由の結果
### 1行目
`MAX = 10000`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`hash = [-1 for _ in range(MAX)]`
#### 1位 1人
- 3 ハッシュテーブルを使って探索を効率化しているのがこの問題のコアであり、ハッシュテーブルを作っているのはここだから。
#### 2位 1人
- 7 ハッシュテーブルとして配列を用意し，そこにどのハッシュの数字が存在していたかを格納していくことで探索を効率的にしようとしていることが，このハッシュテーブルの宣言で読み取れるから．
1番でない理由としては，ハッシュテーブルよりどのようなハッシュを用いて計算していくのを表す6行目の方が重要であると考えたから．
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`def insert(x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    hashed_x = x % MAX`
#### 1位 2人
- 7 問題を解くために，ハッシュを用いることで効率的に探索を可能にしようとしていることがこの行で分かるから．
- 9 ハッシュ化されたxを求める行であるため。今回のハッシュ探索ではxをある値で割った余りをハッシュの値として用いることを示しているため、全ての前提となっていると考え、一番大事と考えている。
#### 2位 0人
#### 3位 1人
- 10 1番2番より基本的かもしれないが、x % MAXの値をハッシュ値とすることも重要だと思いました。
### 7行目
`    for i in range(MAX):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 ハッシュ化されたxに対して、空きが見つかるまで1を足し続けることで格納する場所を見つけようとしていることを表す行であるから。1を足し続けることは本質ではないため、1番や2番ではないと考えた。
### 8行目
`        index = (hashed_x + i) % MAX`
#### 1位 4人
- 2 探したい数のハッシュ値を計算して、ハッシュ値が存在していれば探したい数も存在する、と考えるアルゴリズムなので、ハッシュ値を計算しているここが重要だと感じた。
- 5 insert関数を見ると、10^9までの数を10^4の配列におさめていることがわかり、その手法として8行目の操作をしていることがわかるため、もっとも重要だと考えた。
- 8 その数字をどのindexに入れるかというハッシュを定義している、ハッシュ探索の肝の部分だから。
- 10 hashが空いてるところまでindexを更新して、xを入れることが重要であると思ったため。
#### 2位 4人
- 3 15行目と合わせてハッシュ値の生成を行っているのはここだから。
- 4 挿入の時にもすでに入っていたらindexをずらすということが大事だから。ただメインは探索の方にあるため。
- 9 ハッシュ化されたxに対して、どこに値を挿入するかを表す行であるため。ハッシュ化されたxが前提となっているため、ハッシュ化されたxを求めることの次に重要であると考えた。
- 11 ハッシュが埋まっていた場合に隣に移動するという考え方が大事だと思いました．必ずしも隣である必要はないので2番目にしました．
#### 3位 2人
- 1 要素を配置したいインデックスに他要素が既にある場合の処理を記載しているため．2番目と処理としては同等であるため，同じくらい重要だが，便宜上3番目とした.
- 7 ハッシュの重複があった場合，次に空いているハッシュ値まで値をずらしていく，オープンアドレス法を用いる工夫がこの行から読み取れるから．
3番である理由としては，これは1,2番で挙げた行のハッシュテーブルを利用することに付随するものであり，より重要度は低いと思ったから．
### 9行目
`        if hash[index] == -1:`
#### 1位 1人
- 6 挿入時に空いているアドレスを探して記録するというオープンアドレス法の特徴を示している。
#### 2位 0人
#### 3位 1人
- 5 8,18行目で行われた処理についての補足として、探索と同様に挿入の際にもhash[i]=-1となるまで右に探索を進めていくということがわかるから。
### 10行目
`            hash[index] = x`
#### 1位 1人
- 11 ハッシュテーブルに登場した要素を持っておくことで高速に調べられるので重要だと思います．
#### 2位 0人
#### 3位 0人
### 11行目
`            break`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`def search(x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`    hashed_x = x % MAX`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 8行目と合わせてハッシュ値の生成を行っているのはここだから。
### 16行目
`    for i in range(MAX):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        index = (hashed_x + i) % MAX`
#### 1位 1人
- 4 探索の時に見つかるまでindexを変えながら調べるというのがこのアルゴリズムの本質だから。
#### 2位 1人
- 2 探したい数のハッシュ値を計算して、ハッシュ値が存在していれば探したい数も存在する、と考えるアルゴリズムなので、ハッシュ値を計算しているここが重要だと感じた。2回目にでてきたところなので2番目。
#### 3位 0人
### 18行目
`        if hash[index] == -1:`
#### 1位 1人
- 1 求めたい要素を変換した先に他の要素が存在しなければ，その要素が記録されていないというハッシュの性質を活かしている部分だと考えたため.
#### 2位 3人
- 5 insertではすべてのiについてハッシュを試しており、どのような条件で探索を行うのか想像がつきづらいが、18行目を読むことでhash[index]=-1となるまで探索を進めていることがわかり、どのように数値が格納されているかわかりやすく成るため2番目に重要だと考えた。
- 6 検索時に空のアドレスにぶつかればその key は入っていないと判断するというオープンアドレス法の特徴を示している。1 番の挿入方法から導かれる検索方法だといえる。
- 10 hash[index] == -1の時は、その後も調べる必要がないので、return Falseする工夫が重要だと思いました。
#### 3位 1人
- 8 2番と同様だが、もしハッシュを計算してそこに値がなければ、その値は「見つからない」ということになるので、これもまた探索で重要だから。重要度は2番と同じ
### 19行目
`            return False`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`        elif hash[index] == x:`
#### 1位 0人
#### 2位 2人
- 1 注目したインデックスに目的の要素がない場合に次に探すインデックスを決定する処理を記載しているため．1番ほどハッシュの性質の根幹にはかかわらないと考え，2番目に選択した．
- 8 ハッシュを計算して、実際に挿入されている値と一致すれば「見つかった」ということになり、探索において重要な部分だから。ハッシュ計算の方が本質的だと思ったのでこちらは2番とした。
#### 3位 3人
- 2 ハッシュ値の一致を持って「見つかった」と判定するアルゴリズムなので、一致かどうかを判定している行がハッシュの計算に次いで重要だと感じた。
- 4 探索が成功したかどうかを判断する部分だから。ただ処理としてはすごく単純のため。
- 11 hashで調べた上で合致していたら同一とみなす手法は高速に調べられるので大事だと思います．ハッシュテーブルを検索するよりも，構築する方法がより大事に感じたので，3番目にしました．
### 21行目
`            return True`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`    return False`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 6 全アドレスを見尽くしても key が見つからない場合もその key 入っていないと判断する。2 番と比べてより自明。
### 23行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`n = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`S = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`q = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`T = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`for s in S:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`    insert(s)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`ans = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
`for t in T:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
`    if search(t):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`        ans += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 37行目
`print(ans)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 9 : 15～17行目：値を格納するだけでなく、検索するときも格納するときと同じ処理を行うことを表しており、格納するとき同様に重要と考えている。
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 3 4 6 8 9 11
- まあ理解できた。 : 3人, 2 7 10
- あまり理解できなかった。 : 1人, 5
- まったく理解できなかった。 : 0人, 
