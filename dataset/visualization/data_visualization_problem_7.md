# 問題番号7
## 基本情報
- トピック : 二分探索
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144715#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  def is_ok(index, key, arr):
2      return True if arr[index] >= key else False
3  
4  
5  def binary_search(key, arr):
6      ng = -1
7      ok = len(S)
8      while abs(ok - ng) > 1:
9          mid = (ok + ng) // 2
10         if arr[mid] == key:
11             return True
12         elif is_ok(mid, key, arr):
13             ok = mid
14         else:
15             ng = mid
16     return False
17 
18 
19 n = int(input())
20 S = list(map(int, input().split()))
21 q = int(input())
22 T = list(map(int, input().split()))
23 
24 ans = 0
25 for t in T:
26     if binary_search(t, S):
27         ans += 1
28 
29 print(ans)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
def is_ok(index, key, arr):                     1  
    return True if arr[index] >= key else False 2  ★★★
                                                3  
                                                4  
def binary_search(key, arr):                    5  
    ng = -1                                     6  ●▲
    ok = len(S)                                 7  
    while abs(ok - ng) > 1:                     8  ★●●●▲▲▲▲▲
        mid = (ok + ng) // 2                    9  ★★★★●●●
        if arr[mid] == key:                     10 ▲▲▲
            return True                         11 
        elif is_ok(mid, key, arr):              12 ●●▲
            ok = mid                            13 ★★
        else:                                   14 
            ng = mid                            15 ●●
    return False                                16 
                                                17 
                                                18 
n = int(input())                                19 
S = list(map(int, input().split()))             20 
q = int(input())                                21 
T = list(map(int, input().split()))             22 
                                                23 
ans = 0                                         24 
for t in T:                                     25 
    if binary_search(t, S):                     26 ★
        ans += 1                                27 ▲
                                                28 
print(ans)                                      29 
```
## 重要な理由の結果
### 1行目
`def is_ok(index, key, arr):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    return True if arr[index] >= key else False`
#### 1位 3人
- 4 答えがリストの右側にあるか左側にあるかを判別するという二分探索の本質的な処理だから。
- 5 二分探索には様々な流派があり、読み手の「ok」の定義が曖昧だとコードの誤読を起こす。２行目を読むことで、「ok ⇔ 値がkey以上の集合」(めぐる式二分探索？)と理解できるため、重要だと考えた。
- 9 二分探索の中において、判定の条件を関数化したものであり、ここが間違っていると二分探索が正しく動作しないという点で一番大事なポイントだと考えているから。
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`def binary_search(key, arr):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    ng = -1`
#### 1位 0人
#### 2位 1人
- 10 while abs(ok - ng) > 1:が最初に成り立つように、ng = -1と初期化することも重要だと思いました。
#### 3位 1人
- 11 ng,okで確実にそうだといえる範囲のインデックスを指すことは重要です．前二つに比べるとちょっとしたポイント感が強くて本質からちょっと離れたところにいるイメージがあります．
### 7行目
`    ok = len(S)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`    while abs(ok - ng) > 1:`
#### 1位 1人
- 10 whileの条件式によって、中の場合分けが変わってきて、ややこしくなる事があるので、重要だと思いました。
#### 2位 3人
- 7 探索の終了条件をこの行のように定めることで探索の終了を定めている．
一行目でない理由は，終了条件は二部探索の一番重要な部分ではないから．
- 9 二分探索における終了条件を明記しており、ここが正しくないと正しく終了しないため。判定の条件とは違い、問題によって異なるような箇所ではなく、常に同じような処理をする箇所であるため、1番ではないと考えた。
- 11 探索を終える条件を把握することは大事だと思います．操作を終える条件であり，操作そのものではないので2番目にしました．
#### 3位 5人
- 1 このように実装することによって,okとngの大小が逆転しても同様に実装できるため，1,2番目として選んだ行ほど重要ではないが，実装の工夫としては重要だと考え3番目として選んだ．
- 2 二分探索は終了条件をきちんと指定しないと正しく収束しなかったり、計算が終わらなかったりするので、細かい部分ではあるが、上の2つの行に次いで重要であると考える。
- 3 上述した区間を半分にすることを繰り返すことで必要なindexを求められるのが二分探索で大事なところなので、繰り返し処理もまあちょっとは大事かもしれない。
- 5 while文を使って二分探索を実装する際のテクニックとして学びのある行だから。二分探索の基本的な知識である点と、中点を次回の探索点にするという知識よりは重要度が低いと考え３番めにおいた。
- 6 あり得る解が 1 つになるまで探索するという終了条件を表す部分だから。解の狭め方に比べると従たる部分であると言える。
### 9行目
`        mid = (ok + ng) // 2`
#### 1位 4人
- 1 
注目している区間の真ん中の要素について確認を行い区間を狭めることにより，確認回数をlogオーダーに抑えるという2分探索の考え方の核となる部分であるため．
- 2 "二分"探索という名前のアルゴリズムなので、変数midを宣言してその判定問題に落とし込んでいる部分が最重要であると考えた。
- 7 二部探索で一番重要である，okとngの中間の数と比較し，範囲を狭めていくという工程で重要な中間の数を算出する箇所だから．
- 11 "2"つにわっているところだから．この操作のおかげで高速に探索できるようになっているため．
#### 2位 3人
- 3 この問題で一番大事なアルゴリズム二分探索の大事な部分は、ここで区間を半分にしながら探索できることだと思うから。
- 4 現在の探索範囲の真ん中の位置を調べるというのは二分探索において重要。ただ処理としては単純。
- 5 二分探索の基本的な考え方である、ngとokの中点を次回の探索点とするという考え方が分かるから。１番にしなかった理由は、二分探索が既知であればあまり本質的ではないため。
#### 3位 0人
### 10行目
`        if arr[mid] == key:`
#### 1位 0人
#### 2位 0人
#### 3位 3人
- 4 2分探索に成功したかを判別する処理だから。比較的重要ではあるが、一致の確認をしているだけ。
- 8 二分探索で、答えが見つかった時の処理も重要だから。探索範囲を狭めていくことの方が二分探索の本質だと思ったので3番にした。
- 9 データが配列の中に見つかった場合にTrueが返せるような処理を別立てで行っている箇所であるから。この部分は今回の問題特有の箇所であり、一般の二分探索の問題で現れる箇所ではないため、1番や2番ではないと考えた。
### 11行目
`            return True`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`        elif is_ok(mid, key, arr):`
#### 1位 0人
#### 2位 2人
- 1 条件を満たす要素があれば探索区間をその右側に，なければ左側に絞るという2分探索の区間削減の考え方を最も端的に表していると考えたため．1番目のように計算量のオーダーに関わる部分ではないため，2番目とした
- 2 その二分探索の判定問題を解いている部分なので、アルゴリズムの本質部分に次いで、問題を解くという意味で重要であると考えた。
#### 3位 1人
- 7 答えとしてカウントされるかどうかの判断をしている部分だから．
3番目である理由は，この問題で一番問われているであろう二部探索のアルゴリズム自身とは少し外れた内容であるから．
### 13行目
`            ok = mid`
#### 1位 2人
- 6 二分探索の根幹である、解の存在範囲を半分に狭める部分だから。
- 8 二分探索で、見つからなかった時にカーソルの位置をずらして、探索範囲を狭めるという処理はとても重要だから。
#### 2位 0人
#### 3位 0人
### 14行目
`        else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`            ng = mid`
#### 1位 0人
#### 2位 2人
- 6 二分探索の根幹である、解の存在範囲を半分に狭める部分だから。1 番と同様に重要。
- 8 1番と同様の理由で、二分探索において重要なところだから。重要度は1番と同じ。
#### 3位 0人
### 16行目
`    return False`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`n = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`S = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`q = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`T = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
`ans = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`for t in T:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`    if binary_search(t, S):`
#### 1位 1人
- 3 この問題の一番コアなところは二分探索を使って効率的に探索できることに気付くことなので。
#### 2位 0人
#### 3位 0人
### 27行目
`        ans += 1`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 10 binary_searchで見つかった分ansに足すことは比較的簡単だが重要だと思いました。
### 28行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`print(ans)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 9 : 16行目。この部分では、データが見つからなかった場合にFalseを返しており、10行目同様に重要だと考えた。
## 自由記述
## 理解度
- とても理解できた。 : 9人, 1 2 3 4 5 6 8 9 11
- まあ理解できた。 : 2人, 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
