# 問題番号24
## 基本情報
- トピック : トポロジカルソート(Kahn)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144846#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  from collections import deque
2  
3  
4  def topological_sort(G, V):
5      in_degree = [0 for _ in range(V)]
6      out_degree = [[] for _ in range(V)]
7      for s, t in G:
8          in_degree[t] += 1
9          out_degree[s].append(t)
10 
11     sorted = []
12     queue = deque()
13     for index, in_deg in enumerate(in_degree):
14         if in_deg == 0:
15             sorted.append(index)
16             queue.append(index)
17 
18     while queue:
19         cur = queue.popleft()
20         for nxt in out_degree[cur]:
21             in_degree[nxt] -= 1
22             if in_degree[nxt] == 0:
23                 sorted.append(nxt)
24                 queue.append(nxt)
25 
26     return sorted
27 
28 
29 V, E = map(int, input().split())
30 G = []
31 for i in range(E):
32     s, t = map(int, input().split())
33     G.append((s, t))
34 
35 print(*topological_sort(G, V), sep="\n")
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
from collections import deque                  1  
                                               2  
                                               3  
def topological_sort(G, V):                    4  
    in_degree = [0 for _ in range(V)]          5  
    out_degree = [[] for _ in range(V)]        6  
    for s, t in G:                             7  ▲
        in_degree[t] += 1                      8  ★▲
        out_degree[s].append(t)                9  ▲
                                               10 
    sorted = []                                11 
    queue = deque()                            12 ▲▲
    for index, in_deg in enumerate(in_degree): 13 
        if in_deg == 0:                        14 ★★★▲
            sorted.append(index)               15 
            queue.append(index)                16 
                                               17 
    while queue:                               18 ●▲
        cur = queue.popleft()                  19 ▲▲
        for nxt in out_degree[cur]:            20 ★●
            in_degree[nxt] -= 1                21 ★★●●●▲
            if in_degree[nxt] == 0:            22 ★★★●●●●
                sorted.append(nxt)             23 ●
                queue.append(nxt)              24 ★●▲
                                               25 
    return sorted                              26 
                                               27 
                                               28 
V, E = map(int, input().split())               29 
G = []                                         30 
for i in range(E):                             31 
    s, t = map(int, input().split())           32 
    G.append((s, t))                           33 
                                               34 
print(*topological_sort(G, V), sep="\n")       35 
```
## 重要な理由の結果
### 1行目
`from collections import deque`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def topological_sort(G, V):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    in_degree = [0 for _ in range(V)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    out_degree = [[] for _ in range(V)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`    for s, t in G:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 しいて言えば最初に入次数とグラフを構築するのは大事かもしれない。
### 8行目
`        in_degree[t] += 1`
#### 1位 1人
- 5 プログラム内で何度も使用されるin_degreeという配列がどのようなものなのかについて、入次数という概念を知らなくても8行目を読めば理解できるため。逆に、これがわからなければ理解が難しいと考え、もっとも重要だとした。
#### 2位 0人
#### 3位 1人
- 11 あらかじめ入次数を数えておくことは大事です．前処理のような雰囲気を感じたので3番目にしました．
### 9行目
`        out_degree[s].append(t)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 2 上で書いたソート済みの頂点から辺を消すための操作には、辺の情報を頂点に持たせておかないといけないので、ここが次に重要であると感じた。
### 10行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`    sorted = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    queue = deque()`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 7 トポロジカルソートはqueueのデータ構造を使うことでより簡単に実現できるということを示しているから．
3番である理由としては，特にqueueを用いなくてもstackなど別のデータ構造でも実現可能であるから．
- 8 キューというデータ構造を使うというのもトポロジカルソートで重要だから。コードの記述としては平易なので3番にした。
### 13行目
`    for index, in_deg in enumerate(in_degree):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        if in_deg == 0:`
#### 1位 3人
- 6 入次数 0 の頂点はトポロジカルソートにおいて先頭としてよいという、Khan のトポロジカルソートの根幹をなす部分である。
- 9 入次数が0の頂点を、ソート済み配列とキューに入れる箇所であるから。トポロジカルソートでまず最初にやるべき要点を記述してある行であると考えており、一番重要だと考えている。
- 11 トポロジカルソートにおいて，入字数が0のものから処理していくことが大事であると感じたから．
#### 2位 0人
#### 3位 1人
- 1 入次数が0の頂点を起点に考えることでトポロジカル順序にソートできるという考え方を表していると考えたため．2と同様の理由であり同等の重要度だと考え，便宜上3番目とした．
### 15行目
`            sorted.append(index)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`            queue.append(index)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`    while queue:`
#### 1位 0人
#### 2位 1人
- 3 Queを用いた全探索及びDPには大体言えるが、探索順序の決定をQueに依存できるのは重要である。
#### 3位 1人
- 5 上2つとは違い、プログラミングのテクニックとして重要な部分ではあるが、queueの中身がある間実行する というpython特有の書き方なので重要だと考えた。
### 19行目
`        cur = queue.popleft()`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 4 queueからどのように取り出すのかを決める行だから。取り出し方を決めているだけなので2番よりは弱い。
- 9 一度見た頂点をキューから取り除いているから。これは実装上の注意点であるため、1,2番目ほどは重要ではないと考えている。
### 20行目
`        for nxt in out_degree[cur]:`
#### 1位 1人
- 8 キューに入ったものを１つずつ取り出してソートしていくのが、トポロジカルソートのやり方をよく表していると思ったから。
#### 2位 1人
- 2 ソート済みの頂点から出ている辺を消していく操作なので、アルゴリズムのメインアイデアではないが、入次数を減らしていく部分なのでこれが2番目に重要だと考えた。
#### 3位 0人
### 21行目
`            in_degree[nxt] -= 1`
#### 1位 2人
- 7 すでにソート配列の中に組み込んだ頂点から出る矢印を取り除いていくことで次の「自分を指す矢印がなくなった頂点」が現れ，次にソート配列に挿入されるべき頂点が分かるという，トポロジカルソートの基本的な操作の一つだから．
- 10 まず入次数0につながるノードの入次数を1減らすことが重要であるから。
#### 2位 3人
- 8 調べたところから繋がっている先の入次数を減らしていくというのもトポロジカルソートの重要な点だから。1番と同じくらい重要だと思う。
- 9 見た頂点の入次数を1減らす処理を行っているから。入次数が0の頂点を入れる次に行うべき処理の要点を記述してある行と考えており、2番目に重要と考えている。
- 11 ノードを見ていくごとに，入次数は減少させる必要があり，その操作を表しているから．1番目の0のものを見ていくという強い意思があっての入次数管理なので2番目にしました．
#### 3位 1人
- 6 トポロジカルソートの先頭にした頂点から辺が伸びている頂点について、入次数を減算するという状態の差分計算を行なっている。 1, 2 番に対して従たる部分。
### 22行目
`            if in_degree[nxt] == 0:`
#### 1位 3人
- 2 入次数が0である頂点を現在1番前の頂点としてsort済みの配列に入れていくというアルゴリズムなので、入次数が0という判定をしている部分が最重要だと考えた。
- 3 トポロジカルソートはこの入次数が0になったノードからQueに突っ込んでくことで実現できるのが重要で、その実装をしているのがこことここの内部だから。
- 4 入次数が0のノードをソート済みにするというのがこのソートの本質であるため。
#### 2位 4人
- 1 入次数が0の頂点を起点に考えることでトポロジカル順序にソートできるという考え方を表していると考えたため選択した．1の方がより考え方を端的に表していると考え2番目とした．
- 5 8行目でin_degreeについて理解した事が前提ではあるが、queueにどのようなものが追加されているのかを理解できるため重要だと考えた。
- 6 入次数 0 の頂点はトポロジカルソートにおいて先頭としてよいという、Khan のトポロジカルソートの根幹をなす部分である。1 番と同様に重要。
- 7 自分を指す矢印がなくなった頂点から順にソート配列に入れていくことでトポロジカルソートを実現でき，この条件文がその条件を示しているから．
1番でない理由としては，1番に選んだ21行目の操作を行ったおかげで「自分を指す矢印がなくなった頂点」が順番に生まれていき，これが次にソート配列に組み込まれる頂点となるという論理の流れがあるため．
#### 3位 0人
### 23行目
`                sorted.append(nxt)`
#### 1位 0人
#### 2位 1人
- 10 1番で入次数を1減らした後、0になったものをsortedに追加することが重要であるから。
#### 3位 0人
### 24行目
`                queue.append(nxt)`
#### 1位 1人
- 1 入次数が0になった頂点を先入先出のキューに入れることによって，トポロジカル順に頂点を取り出すことができるという考えを表しているため，最も重要だと考えた．
#### 2位 1人
- 4 キューを使って次に見るノードを管理するのが重要だから。ただこれはソートに必要な道具にすぎないため。
#### 3位 1人
- 10 1番で入次数を1減らした後、2番と同じように0になったものをqueueに追加することが重要であるから。
### 25行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`    return sorted`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`V, E = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`G = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`for i in range(E):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`    s, t = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
`    G.append((s, t))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`print(*topological_sort(G, V), sep="\n")`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
## 自由記述
## 理解度
- とても理解できた。 : 8人, 1 2 3 4 6 9 10 11
- まあ理解できた。 : 3人, 5 7 8
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
