# 問題番号8
## 基本情報
- トピック : キューの実装
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_3_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144625#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  MAX = 100001
2  
3  
4  class Queue:
5      def __init__(self):
6          self.arr = [None for _ in range(MAX)]
7          self.head = 0
8          self.tail = -1
9  
10     def push(self, x):
11         if (self.tail + 2) % MAX == self.head:
12             return "full"
13         self.arr[(self.tail + 1) % MAX] = x
14         self.tail = (self.tail + 1) % MAX
15 
16     def pop(self):
17         if (self.tail + 1) % MAX == self.head:
18             return "empty"
19         res = self.arr[self.head]
20         self.head = (self.head + 1) % MAX
21         return res
22 
23     def is_empty(self):
24         return (self.tail + 1) % MAX == self.head
25 
26 
27 queue = Queue()
28 
29 n, q = map(int, input().split())
30 for i in range(n):
31     name, time = input().split()
32     queue.push((name, int(time)))
33 
34 sum = 0
35 while not queue.is_empty():
36     name, time = queue.pop()
37     queue.push((name, time - q)) if time > q else print(name, sum + time)
38     sum += min(time, q)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
MAX = 100001                                                              1  
                                                                          2  
                                                                          3  
class Queue:                                                              4  ★
    def __init__(self):                                                   5  ★
        self.arr = [None for _ in range(MAX)]                             6  
        self.head = 0                                                     7  ▲
        self.tail = -1                                                    8  ▲
                                                                          9  
    def push(self, x):                                                    10 
        if (self.tail + 2) % MAX == self.head:                            11 ●
            return "full"                                                 12 
        self.arr[(self.tail + 1) % MAX] = x                               13 ★●●▲
        self.tail = (self.tail + 1) % MAX                                 14 ★★★●●●
                                                                          15 
    def pop(self):                                                        16 
        if (self.tail + 1) % MAX == self.head:                            17 
            return "empty"                                                18 
        res = self.arr[self.head]                                         19 ●▲▲▲
        self.head = (self.head + 1) % MAX                                 20 ●●●▲
        return res                                                        21 
                                                                          22 
    def is_empty(self):                                                   23 
        return (self.tail + 1) % MAX == self.head                         24 ▲
                                                                          25 
                                                                          26 
queue = Queue()                                                           27 ★▲
                                                                          28 
n, q = map(int, input().split())                                          29 
for i in range(n):                                                        30 
    name, time = input().split()                                          31 
    queue.push((name, int(time)))                                         32 
                                                                          33 
sum = 0                                                                   34 
while not queue.is_empty():                                               35 
    name, time = queue.pop()                                              36 
    queue.push((name, time - q)) if time > q else print(name, sum + time) 37 ★★★★●▲
    sum += min(time, q)                                                   38 ▲
```
## 重要な理由の結果
### 1行目
`MAX = 100001`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`class Queue:`
#### 1位 1人
- 11 queueというデータ構造はかなり重要だと思います．クラス名を定義している行を選びました．
#### 2位 0人
#### 3位 0人
### 5行目
`    def __init__(self):`
#### 1位 1人
- 7 初期値の段階でheadとtailの位置を決めておくことでqueueのアルゴリズムが簡単に実現できるということがこの初期化関数でわかるから．
#### 2位 0人
#### 3位 0人
### 6行目
`        self.arr = [None for _ in range(MAX)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`        self.head = 0`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 リングバッファを用いたqueueのどこが一番大事かは少々微妙だがしいて言えば8行と合わせてここのインデックス管理だけでqueueが実装できることかなあ、と思ったから。
### 8行目
`        self.tail = -1`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 11 初期状態をhead>tailなのはこのコードを書く上で間違えやすいかなと思ったので選びました．別の書き方もできるので3番目です．
### 9行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`    def push(self, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`        if (self.tail + 2) % MAX == self.head:`
#### 1位 0人
#### 2位 1人
- 10 queueがいっぱいになった時の場合分けも1番ほどではないが、非常に重要であると思ったため。
#### 3位 0人
### 12行目
`            return "full"`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`        self.arr[(self.tail + 1) % MAX] = x`
#### 1位 1人
- 5 データがQueueを模した配列にどのように格納されているかのイメージを掴むことができるから
#### 2位 2人
- 4 キューにプッシュするときにどのインデックスに入れるかを決めているため。キューとしては重要だが、処理は比較的単純。
- 8 queueにpushするという、データ構造において重要な作業だから。1番目に比べると簡単だと思ったため2番にした。
#### 3位 1人
- 7 queueの挿入時は末尾に挿入するということがこの行で表されているから．
3番目である理由は，stackなど他のアルゴリズムでも挿入では末尾に挿入することが多いため，違いがないから．
### 14行目
`        self.tail = (self.tail + 1) % MAX`
#### 1位 3人
- 1 キューをリングバッファとして実装する際に，headとtailの位置を更新する部分が最も重要だと考えた．
- 2 queueは配列を円環状に使い回しながら先頭と末尾の座標を持って実現するデータ構造であるが、その末尾の座標を円環状に持っていることを表している部分だから。
- 10 pushされたときに、self.tailをずらしているのはqueueの実装において大切だと感じたため。
#### 2位 3人
- 5 上記のデータの格納について理解することにあわせて、14行目を読むことでtailがどのような挙動をしているか分かるようになるため
- 6 リングバッファによるキューの実装で必要な処理だから。問題固有の部分ではないので 1 番ではない。
- 9 リングバッファ方式でキューの末尾を伸ばしていく処理を行っており、この部分が正しくないと正しくキューが動作しないため。キューの実装箇所であるため、この問題特有の処理ではないと考えたため、1番とはしなかった。
#### 3位 0人
### 15行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`    def pop(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        if (self.tail + 1) % MAX == self.head:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`            return "empty"`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`        res = self.arr[self.head]`
#### 1位 0人
#### 2位 1人
- 7 queueのアルゴリズムの特徴である，取り出す時は先頭の要素からということがこの行で表されているから．
1番でない理由としては，queueのアルゴリズムの説明は問題中でなされているから．
#### 3位 3人
- 4 キューのポップを行う本質的な部分。2番のプッシュより処理はもっと単純である。
- 5 データ構造についてイメージを掴めていることが前提となるが、popがどちらがわから行われているかを読み取ることができるから
- 8 queueからpopするというのもデータ構造において大切だから。2番と重要度はほぼ同じ。
### 20行目
`        self.head = (self.head + 1) % MAX`
#### 1位 0人
#### 2位 3人
- 1 キューをリングバッファとして実装する際に，headとtailの位置を更新する部分が最も重要だと考えた．1番目と全く同じ重要度であるが，便宜上2番目とした．
- 2 14行目と同様に、円環状の配列の先頭を持っている部分であるので重要であると考える。20行のほうが後に出てきているので、2番目にした。
- 11 取り出した後インデックスを一つ進めて，先頭を移動させています．modをとって有限のリストを活用しているのも大事だと思います．queueのあくまで一部分なので2番目です．
#### 3位 1人
- 6 リングバッファによるキューの実装で必要な処理だから。2 番と同様に重要。
### 21行目
`        return res`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    def is_empty(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
`        return (self.tail + 1) % MAX == self.head`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 キューが空であることの条件を書いており、この部分が正しくないと正しくプログラムが終了しないため。キューの実装の本質部分ではないと考えたため、1番や2番とはしなかった。
### 25行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`queue = Queue()`
#### 1位 1人
- 3 この問題のコアなところは、データ構造queueを使えば問題の設定をそのままシミュレーションできることに気付くことなので。
#### 2位 0人
#### 3位 1人
- 1 この問題を解く際にキューを使うという発想が重要だと考えた．キューの実装の方がより重要と考え，3番目とした．
### 28行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`n, q = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`    name, time = input().split()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`    queue.push((name, int(time)))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
`sum = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`while not queue.is_empty():`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
`    name, time = queue.pop()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 37行目
`    queue.push((name, time - q)) if time > q else print(name, sum + time)`
#### 1位 4人
- 4 ラウンドロビンスケジューリングを実現するために、キューを更新するか、printするかを決めている部分だから。
- 6 問題固有の本質的な処理を行なっている唯一の部分であると言える。
- 8 問題の要求に応えるために、データ構造そのものだけでなく、その使い方も工夫する必要があるというところだから。
- 9 キューを用いてラウンドロビンのシミュレーションを行う部分であり、この部分の処理が間違っているとシミュレーションがうまくいかないことになり、問題の本質部分に関わっているといえるから。
#### 2位 1人
- 3 queueを使って実際に問題の状況をシミュレートしているところはここだから。
#### 3位 1人
- 2 プロセスの残り時間で場合分けをしながらqueueを操作している部分で、データ構造の実現の方が本質であるとは思うが、問題解決部分の重要部分として3番目に重要だと考える。
### 38行目
`    sum += min(time, q)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 10 queueの実装とは関係ないが、timeとqの小さい方を足すことで、正しくラウンドロビンスケジューリングのシミュレーションができ、重要であるため。
## 他の重要部分
- 9 : 20行目。キューの先頭を縮める処理を行う箇所であり、14行目同様に、キューを正しく動作させる上では欠かせない箇所である。
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 4 6 9 11
- まあ理解できた。 : 3人, 5 7 10
- あまり理解できなかった。 : 1人, 8
- まったく理解できなかった。 : 0人, 
