# 問題番号21
## 基本情報
- トピック : スタックの実装
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_3_A&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144774#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  MAX = 199
2  
3  
4  class Stack:
5      def __init__(self):
6          self.arr = [None for _ in range(MAX)]
7          self.head = 0
8  
9      def push(self, x):
10         if self.head >= MAX:
11             return "full"
12         self.arr[self.head] = x
13         self.head += 1
14 
15     def pop(self):
16         if self.head == 0:
17             return "empty"
18         self.head -= 1
19         return self.arr[self.head]
20 
21 
22 stack = Stack()
23 symbols = input().split()
24 
25 for symbol in symbols:
26     if symbol == "+":
27         stack.push(stack.pop() + stack.pop())
28     elif symbol == "-":
29         stack.push(-(stack.pop() - stack.pop()))
30     elif symbol == "*":
31         stack.push(stack.pop() * stack.pop())
32     else:
33         stack.push(int(symbol))
34 
35 print(stack.pop())
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
MAX = 199                                        1  
                                                 2  
                                                 3  
class Stack:                                     4  
    def __init__(self):                          5  
        self.arr = [None for _ in range(MAX)]    6  ▲
        self.head = 0                            7  
                                                 8  
    def push(self, x):                           9  
        if self.head >= MAX:                     10 
            return "full"                        11 
        self.arr[self.head] = x                  12 ●
        self.head += 1                           13 ★▲▲
                                                 14 
    def pop(self):                               15 
        if self.head == 0:                       16 
            return "empty"                       17 
        self.head -= 1                           18 ●●
        return self.arr[self.head]               19 ▲
                                                 20 
                                                 21 
stack = Stack()                                  22 ★★★★
symbols = input().split()                        23 
                                                 24 
for symbol in symbols:                           25 ●▲
    if symbol == "+":                            26 
        stack.push(stack.pop() + stack.pop())    27 ★★★★★●▲▲
    elif symbol == "-":                          28 
        stack.push(-(stack.pop() - stack.pop())) 29 ★●●●
    elif symbol == "*":                          30 
        stack.push(stack.pop() * stack.pop())    31 ▲▲▲
    else:                                        32 ●
        stack.push(int(symbol))                  33 ●●
                                                 34 
print(stack.pop())                               35 ▲
```
## 重要な理由の結果
### 1行目
`MAX = 199`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`class Stack:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    def __init__(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`        self.arr = [None for _ in range(MAX)]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 stackというデータ構造の何が重要かと言われると難しいが、単純なリストと先頭のインデックスを管理するだけで実装が出来るというのは重要かもしれない。
### 7行目
`        self.head = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    def push(self, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`        if self.head >= MAX:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`            return "full"`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`        self.arr[self.head] = x`
#### 1位 0人
#### 2位 1人
- 11 頭から入れる構造になっているのがqueueと違うところなので選びました．stackの実装というより細かい話になるので2番目にしました．
#### 3位 0人
### 13行目
`        self.head += 1`
#### 1位 1人
- 10 pushしたときに、headをずらすことがstackにおいて重要だと思ったため。
#### 2位 0人
#### 3位 2人
- 1 スタックの実装の中心部分であると考えて選択した．2番目ほど注意を必要としないと考え，3番目とした．
- 4 pushしたときにはheadを+1するというのはスタックの実装において本質的であるから。ただ逆ポーランド記法の計算には直接的に関係しない。
### 14行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`    def pop(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`        if self.head == 0:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`            return "empty"`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`        self.head -= 1`
#### 1位 0人
#### 2位 2人
- 1 スタックの実装において，要素を取り出す際に，self.headという変数が次に要素を配置するインデックスであることに注意して1減らしてから要素を取り出す必要があり，スタックの実装の中心部分であるとともに注意も必要であるため選択した．スタックを利用するという発想の方がこの問題においては重要と考え，2番目とした．
- 10 1番と同じように、popするときは、headを-1することで戻すことが重要だと思ったため。
#### 3位 0人
### 19行目
`        return self.arr[self.head]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 7 stackでは直前に入れた要素を取り出すようなデータ構造であることがこの行から分かり，この構造を用いることで正答を導き出すことができるから．
3番目である理由は，stackがどのようなデータ構造かをわかっている場合は，既知のことだから．
### 20行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`stack = Stack()`
#### 1位 4人
- 1 この問題をスタックを用いて解くことができるということを初めて知り，発想としても簡単ではないと感じたため1番目に選択した．
- 3 ループ部分と迷ったが、この問題で重要なのは逆ポーランド記法は左端からstackに突っ込んでいって計算すればそのまま計算することが出来る、ということなので。
- 7 問題を解くためにstackのデータ構造を用いるということがこの行から分かり，問題を解くための大きなヒントとなる部分であるから．
- 11 逆ポーランド記法をstackで処理しようと発想したところが大事だと思います．そこが反映されている箇所を選びました．
#### 2位 0人
#### 3位 0人
### 23行目
`symbols = input().split()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`for symbol in symbols:`
#### 1位 0人
#### 2位 1人
- 3 ここのループで左端からstackに突っ込んで行く過程を実装しているので。
#### 3位 1人
- 11 逆ポーランド記法をstackを使いながらうまく処理している箇所の冒頭をえらびました．stackを作ることにより重点があると考えたので3番目にしました．
### 26行目
`    if symbol == "+":`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`        stack.push(stack.pop() + stack.pop())`
#### 1位 5人
- 2 逆ポーランド記法の処理はそれほど自明ではないので、その処理の部分を書いたここがこの問題の最重要ポイントだと感じた。
- 4 逆ポーランド記法での演算をする際にスタックをこのように利用するという処理が書かれているから。
- 6 逆ポーランド記法の数式をスタックで処理するにあたっての、スタックから取り出し、演算し、挿入すという根幹の処理を示している。
- 8 スタックを用いながら、逆ポーランド記法に沿った計算を行っている、アルゴリズムの肝の部分だから。
- 9 逆ポーランド記法における足し算の計算を、スタックから値を取り出すことで行っている箇所であるから。
#### 2位 1人
- 7 演算子が入力であった時は，直前の二つの入力を取り出して計算し，それを再びstackに挿入することで計算が可能であることがこの行で分かるから．(29,31行目も同様)
一番目ではない理由は，stackを利用するということ自体を思いつけないとこの処理を行うことはできないから．
#### 3位 2人
- 5 + や ×の演算子の扱いについても上2つについで重要であると考え、先に登場した27行目が3番めに重要であるとした。
- 10 1番2番などに注意して、実装したstackを用いて、逆ポーランド記法の計算をしていて重要だと思ったため。
### 28行目
`    elif symbol == "-":`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`        stack.push(-(stack.pop() - stack.pop()))`
#### 1位 1人
- 5 この問題はStackを使用できるという部分が非自明であるため、Stackそのものの実装よりもStackを利用している部分のほうが重要であると考えた。その中で3種類の演算子はほぼ同様の処理で実現できるが、唯一符号が逆になっており注意が必要な29が最も重要であると考えた。
#### 2位 3人
- 2 逆ポーランド記法の処理はそれほど自明ではないので、その処理の部分を書いたここがこの問題の最重要ポイントだと感じた。2回目の登場なので、2番目。
- 6 逆ポーランド記法の数式をスタックで処理するにあたっての、スタックから取り出し、演算し、挿入すという根幹の処理を示している。1 番と同様に重要。
- 8 1番と同様の理由で、逆ポーランド記法特有の計算方法を実現しているところだから。重要度は1番と同じ
#### 3位 0人
### 30行目
`    elif symbol == "*":`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`        stack.push(stack.pop() * stack.pop())`
#### 1位 0人
#### 2位 0人
#### 3位 3人
- 2 逆ポーランド記法の処理はそれほど自明ではないので、その処理の部分を書いたここがこの問題の最重要ポイントだと感じた。3回目の登場なので、3番目。
- 6 逆ポーランド記法の数式をスタックで処理するにあたっての、スタックから取り出し、演算し、挿入すという根幹の処理を示している。1, 2 番と同様に重要。
- 8 1番・2番と同様で、逆ポーランド記法特有の計算方法を実現しているところだから。重要度は上の二つと同じ。
### 32行目
`    else:`
#### 1位 0人
#### 2位 1人
- 9 逆ポーランド記法において、数字が出てきたらスタックにその値をそのまま格納すればよいことが表されているから。実際に計算する処理を行う箇所のほうが大事だと考えているので、1番にはしなかった。
#### 3位 0人
### 33行目
`        stack.push(int(symbol))`
#### 1位 0人
#### 2位 2人
- 4 数字が得られればスタックに入れるというスタックの性質を利用しているから。ただ処理としては単純。
- 5 + や × の演算子よりも、数値がpushされたときのStackの扱い(ただpushすればよい)という点が重要だと考え、2番目に重要であるとした。
#### 3位 0人
### 34行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`print(stack.pop())`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 最後に答えの値を取り出す処理が書かれているから。これは処理の核心の部分ではないため、1,2番目とはしなかった。
## 他の重要部分
- 5 : 31行目：*についての処理が書かれており、重要
12行目,18行目: push,popについてlistで実装する際のhead変数の扱いが書かれており、重要
- 9 : 29・31行目。逆ポーランド記法における引き算、掛け算の計算結果の求め方が書かれているので、足し算同様に重要と考えている。
## 自由記述
## 理解度
- とても理解できた。 : 8人, 1 3 4 5 6 8 9 11
- まあ理解できた。 : 3人, 2 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
