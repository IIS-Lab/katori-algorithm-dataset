# 問題番号25
## 基本情報
- トピック : 幅優先探索
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_C&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144845#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  from collections import deque
2  
3  
4  def bfs(G, start):
5      dist = [-1 for _ in range(len(G))]
6      dist[start] = 0
7      queue = deque()
8      queue.append(start)
9  
10     while queue:
11         cur = queue.popleft()
12         for nxt in G[cur]:
13             if dist[nxt] == -1:
14                 dist[nxt] = dist[cur] + 1
15                 queue.append(nxt)
16     return dist
17 
18 
19 n = int(input())
20 G = []
21 for i in range(n):
22     edges = list(map(int, input().split()))
23     G.append([]) if edges[1] == 0 else G.append(edges[2:])
24     G[i] = [j - 1 for j in G[i]]
25 
26 ans = bfs(G, 0)
27 for i in range(n):
28     print(i + 1, ans[i])
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
from collections import deque                              1  
                                                           2  
                                                           3  
def bfs(G, start):                                         4  
    dist = [-1 for _ in range(len(G))]                     5  ▲
    dist[start] = 0                                        6  ▲
    queue = deque()                                        7  ●
    queue.append(start)                                    8  ▲
                                                           9  
    while queue:                                           10 ▲
        cur = queue.popleft()                              11 ★★★★★●●▲
        for nxt in G[cur]:                                 12 
            if dist[nxt] == -1:                            13 ●●●●▲▲▲
                dist[nxt] = dist[cur] + 1                  14 ★●●▲▲
                queue.append(nxt)                          15 ★★★●●
    return dist                                            16 
                                                           17 
                                                           18 
n = int(input())                                           19 
G = []                                                     20 
for i in range(n):                                         21 
    edges = list(map(int, input().split()))                22 
    G.append([]) if edges[1] == 0 else G.append(edges[2:]) 23 ▲
    G[i] = [j - 1 for j in G[i]]                           24 
                                                           25 
ans = bfs(G, 0)                                            26 ★★
for i in range(n):                                         27 
    print(i + 1, ans[i])                                   28 
```
## 重要な理由の結果
### 1行目
`from collections import deque`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def bfs(G, start):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    dist = [-1 for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 8 距離を最初に-1で初期化しておくことで、たどり着けないところは-1で出力せよ、という問題の指示に答えられるようにしているから。bfsのアルゴリズムに本質的に関わることではないので3番にした。
### 6行目
`    dist[start] = 0`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 10 1番や2番より基本的だが、start地点のdistの値を0で初期化することを忘れないことが重要であるため。
### 7行目
`    queue = deque()`
#### 1位 0人
#### 2位 1人
- 7 queueのデータ構造を用いることは幅優先探索を行うために重要であることだと思うから．
1番でない理由としては，この部分は幅優先探索のアルゴリズムの一部であり，問題を解くことには直結していないから．
#### 3位 0人
### 8行目
`    queue.append(start)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 最初に訪れる頂点をキューに入れる行であるから。少しの実装上の注意点なので1番や2番というわけではないものの、これがないと全く探索が行われないので、3番目に重要だと考えた。
### 9行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`    while queue:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 Queを用いるDPや全探索すべてに言えることだが、探索順序をQueを用いれば効率的に決定できるのは重要である。
### 11行目
`        cur = queue.popleft()`
#### 1位 5人
- 2 BFSは距離を近い順に確定させていくが、queueの先頭の要素がいまのところ一番近い頂点なので、その知見がふくまれたこの行が最重要。
- 4 幅優先探索はノードをキューとして管理することが重要で、この行はそれを表しているから。
- 6 幅優先探索の、訪問済みかつ未処理の頂点の中で最も昔に訪問した頂点を処理するという特徴が示されている。
- 10 bfsにおいて、queueのデータ構造を使うことが重要であるため。
- 11 入った方早い順序から出していくのがbfsの大事なところだと考えました．
#### 2位 2人
- 1 訪問済みの頂点をキューから取り出すことでBFS順で探索を行えることを表している行であるため重要と考えて選択した．1番目の方がこの考え方をより端的に表していると考えて，2番目に選択した．
- 5 15行目をappendleftにしていても、11行目がpopだとDFSになる。appendのほうが本質的に感じたが、15行目と同様にこの部分も非常に大切だと考えた。
#### 3位 1人
- 7 次に見る頂点候補(queue)のうち，古いものから順に取り出していくことで幅優先探索を実現できるということが分かるから．
3番である理由としては，古いもの順に取り出すということはqueueの基本的な使い方と合致しており，2番目があれば分かる操作であるから．
### 12行目
`        for nxt in G[cur]:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`            if dist[nxt] == -1:`
#### 1位 0人
#### 2位 4人
- 8 まだ見ていないところについて見るという記述で、これもbfsにおいては大切だと思った。1番の方が本質的だと思ったので、こちらは2番にした。
- 9 一度見た頂点を二度と見ないような処理をしている行であるから。最短距離の更新を本質的に行う行ではないため1番大事というわけではないが、これがないと無限ループが起こってしまうため、2番目に大事と考えている。
- 10 1番のデータ構造を用いた上で、訪問したノードは訪ねないようにすることが重要であるため。
- 11 まだ見ていないところに絞って探索しないと時間が無限にかかってしまいます．本質からちょっとだけ離れている気がするので2番目にしました．
#### 3位 3人
- 1 未訪問の頂点であるかどうかを確認する操作であり，ミスが起こりやすい部分だと考えて選択した．アルゴリズムの根幹となる部分ではないと考え3番目とした．
- 5 BFSの更新処理について、実際にdist配列を変更する部分であり、BFS/DFS共通の部分なので上2つより優先度は下がるが重要だと考えた。
- 6 この条件分岐は忘れがちだが忘れると痛い目を見る。1, 2 番に比べると細かい注意点に当たる。
### 14行目
`                dist[nxt] = dist[cur] + 1`
#### 1位 1人
- 9 今見ている頂点から直接たどり着ける頂点に対して最短距離の更新を行っている行であるから。最短距離の更新を直接行っている行であるため、ここが一番大事と考えている。
#### 2位 2人
- 2 まだ訪れていない頂点があったら、距離を確定させる操作がいるので、距離の確定をさせるこの行は重要。
- 3 幅優先探索で重要なのはここの配るDP遷移式で状態をまとめて探索できることだから。
#### 3位 2人
- 4 答えを表すリストを更新している部分だから。ただ探索の本質にはあまり関係ない。
- 11 次に見るノードは今見ているノードよりも距離を1増やしてい口方針が大事だとおもいます．距離は1じゃなくなったりするので，3番目にしました．
### 15行目
`                queue.append(nxt)`
#### 1位 3人
- 1 見つけた未訪問の頂点をキューに入れることで，BFSの順序で頂点を探索できるという考え方を表しているため．
- 5 BFSの本質的な部分であると同時に、この部分をappendleftにするとDFSという別のアルゴリズムになってしまうため、絶対に間違えてはいけない重要な部分だと考えた。
- 8 発見したノードをキューに入れていくというのはBFSの1番の特徴だから。
#### 2位 2人
- 4 キューにどのように値を追加しているのかを表す行だから。ただ次のノードを入れるというだけなので2番にした。
- 6 Deque を Queue として使う以上入れ方にも選択肢があるが、後ろから入れるということが示されている。Deque を使わなければさして気にするところでもないので 2 番。
#### 3位 0人
### 16行目
`    return dist`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`n = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`G = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`    edges = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    G.append([]) if edges[1] == 0 else G.append(edges[2:])`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 2 隣接リストで表現しないと計算量が増えてしまうので、アルゴリズムの根幹ではないがこれはこれで重要だと考える。
### 24行目
`    G[i] = [j - 1 for j in G[i]]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`ans = bfs(G, 0)`
#### 1位 2人
- 3 この問題のコアは幅優先探索を使えば解ける、ということなので。
- 7 問題で問われている最短距離を求めるためには幅優先探索を行えばよいということがこの行から分かるから．
#### 2位 0人
#### 3位 0人
### 27行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`    print(i + 1, ans[i])`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 5 : 6: 初期化しないとBFSを開始できないから
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 4 6 9 11
- まあ理解できた。 : 4人, 5 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
