# 問題番号12
## 基本情報
- トピック : セグ木(RMQ)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_A&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7145074#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  class SegmentTree:
2      def __init__(self, size):
3          x = 1
4          while size > x:
5              x *= 2
6          self.n = x
7          self.arr = [float("inf") for _ in range(2 * self.n - 1)]
8  
9      def set(self, i, x):
10         self.arr[i + self.n - 1] = x
11 
12     def build(self):
13         for i in reversed(range(0, self.n - 1)):
14             self.arr[i] = min(self.arr[2 * i + 1], self.arr[2 * i + 2])
15 
16     def update(self, i, x):
17         i += self.n - 1
18         self.arr[i] = x
19         while i > 0:
20             i = (i - 1) // 2
21             self.arr[i] = min(self.arr[2 * i + 1], self.arr[2 * i + 2])
22 
23     def _find_rec(self, x, y, i, cur_l, cur_r):
24         if cur_r <= x or y <= cur_l:
25             return float("inf")
26         elif x <= cur_l and cur_r <= y:
27             return self.arr[i]
28         else:
29             return min(self._find_rec(x, y, 2 * i + 1, cur_l, (cur_l + cur_r) // 2), self._find_rec(x, y, 2 * i + 2, (cur_l + cur_r) // 2, cur_r))
30 
31     def find(self, x, y):
32         return self._find_rec(x, y, 0, 0, self.n)
33 
34 
35 n, q = map(int, input().split())
36 
37 tree = SegmentTree(n)
38 for i in range(n):
39     tree.set(i, 2**31 - 1)
40 tree.build()
41 
42 for i in range(q):
43     com, x, y = map(int, input().split())
44     tree.update(x, y) if com == 0 else print(tree.find(x, y + 1))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
class SegmentTree:                                                                                                                                 1  
    def __init__(self, size):                                                                                                                      2  
        x = 1                                                                                                                                      3  
        while size > x:                                                                                                                            4  
            x *= 2                                                                                                                                 5  
        self.n = x                                                                                                                                 6  
        self.arr = [float("inf") for _ in range(2 * self.n - 1)]                                                                                   7  ●●
                                                                                                                                                   8  
    def set(self, i, x):                                                                                                                           9  
        self.arr[i + self.n - 1] = x                                                                                                               10 
                                                                                                                                                   11 
    def build(self):                                                                                                                               12 
        for i in reversed(range(0, self.n - 1)):                                                                                                   13 
            self.arr[i] = min(self.arr[2 * i + 1], self.arr[2 * i + 2])                                                                            14 ●●▲▲
                                                                                                                                                   15 
    def update(self, i, x):                                                                                                                        16 
        i += self.n - 1                                                                                                                            17 ▲
        self.arr[i] = x                                                                                                                            18 
        while i > 0:                                                                                                                               19 
            i = (i - 1) // 2                                                                                                                       20 ★▲
            self.arr[i] = min(self.arr[2 * i + 1], self.arr[2 * i + 2])                                                                            21 ★★●●●▲▲▲
                                                                                                                                                   22 
    def _find_rec(self, x, y, i, cur_l, cur_r):                                                                                                    23 
        if cur_r <= x or y <= cur_l:                                                                                                               24 
            return float("inf")                                                                                                                    25 
        elif x <= cur_l and cur_r <= y:                                                                                                            26 
            return self.arr[i]                                                                                                                     27 ●
        else:                                                                                                                                      28 
            return min(self._find_rec(x, y, 2 * i + 1, cur_l, (cur_l + cur_r) // 2), self._find_rec(x, y, 2 * i + 2, (cur_l + cur_r) // 2, cur_r)) 29 ★★★★●●●▲▲
                                                                                                                                                   30 
    def find(self, x, y):                                                                                                                          31 
        return self._find_rec(x, y, 0, 0, self.n)                                                                                                  32 
                                                                                                                                                   33 
                                                                                                                                                   34 
n, q = map(int, input().split())                                                                                                                   35 
                                                                                                                                                   36 
tree = SegmentTree(n)                                                                                                                              37 ★★★
for i in range(n):                                                                                                                                 38 
    tree.set(i, 2**31 - 1)                                                                                                                         39 ★▲
tree.build()                                                                                                                                       40 
                                                                                                                                                   41 
for i in range(q):                                                                                                                                 42 
    com, x, y = map(int, input().split())                                                                                                          43 
    tree.update(x, y) if com == 0 else print(tree.find(x, y + 1))                                                                                  44 ▲
```
## 重要な理由の結果
### 1行目
`class SegmentTree:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    def __init__(self, size):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`        x = 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`        while size > x:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`            x *= 2`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`        self.n = x`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`        self.arr = [float("inf") for _ in range(2 * self.n - 1)]`
#### 1位 0人
#### 2位 2人
- 5 SegmentTreeを使うことが最重要な前提であるとした上で、この問題のコードを書く上で気をつけるべき点として、初期化する際に演算minの単位元であるinfや最大の数である2^31-1で埋めている点がある。単にゼロ埋め、と覚えるのではなく、単位元を利用することを強調するという意味で、7行目が重要であると考えた。
- 11 セグ木の初期状態を最小が問題になっているのに合わせてinfでつくっている.長さが2^n-1のリストという点でも大事だと思います．どう更新するかの方がこの問題に特有だと感じたから2番目です．
#### 3位 0人
### 8行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    def set(self, i, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`        self.arr[i + self.n - 1] = x`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    def build(self):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`        for i in reversed(range(0, self.n - 1)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`            self.arr[i] = min(self.arr[2 * i + 1], self.arr[2 * i + 2])`
#### 1位 0人
#### 2位 2人
- 7 この行より，どのように問題に適したセグメントツリーを構成するかが分かるから．
1番でない理由は，具体的なアルゴリズム名(セグメントツリー)が分かることよりは重要ではないと考えたから．
- 8 セグメント木を使うというのは、この問題を解く上での本質であり、その木の構築の主要な部分だから。答えを出すところそのものではないので、2番とした。
#### 3位 2人
- 2 セグ木の処理の初期化を行なっている部分であるので、これもクエリ処理に次いで重要だと考えた。
- 4 セグメント木の性質を使って木を表すリストを埋めているため。ただ答えに直接つながる処理ではない。
### 15行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`    def update(self, i, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        i += self.n - 1`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 6 忘れがちなインデックスの処理。1 番 2 番と比べると本質ではない。
### 18行目
`        self.arr[i] = x`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`        while i > 0:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`            i = (i - 1) // 2`
#### 1位 1人
- 11 このデータ構造において，2で割っていくことで高速に最小値を更新できることが最大の強みだと思います．
#### 2位 0人
#### 3位 1人
- 1 子区間から親区間へと注目するインデックスを移す処理が書かれているため重要だと考えた．Segment木の発想の中心である1,2番目に比べると実装の細かい部分に当たると考え3番目とした．
### 21行目
`            self.arr[i] = min(self.arr[2 * i + 1], self.arr[2 * i + 2])`
#### 1位 2人
- 2 一点更新区間minのセグ木の問題であるが、一点更新がlogオーダーでできる本質の行だと考えたので、ここにした。
- 10 updateで親をたどりながら更新していることがとても重要だと思ったため。
#### 2位 3人
- 1 更新の際は子区間から親区間に結果を伝えるというsegment木の重要な考え方が表されていると考えたため．実装難易度が29行目よりも低いことを考慮して2番目とした．
- 4 木を更新する本質的な処理をしているため。1番に比べると複雑な処理はしていない。
- 6 セグメントツリーの更新を行う部分の本体。1 番と比べると自明。
#### 3位 3人
- 3 一点更新が対数時間で実行できるのが重要だがその本質はここの遷移式一発で更新できるからなので。
- 8 セグメント木の性質を利用して、数字のアップデートを行った後の更新作業を行なっており、重要なところだから。1番2番に比べると基本的なことなので、3番とした。
- 9 セグメント木における一点更新の処理が述べられている行であるから。一点更新の処理は区間の最小値を求める処理ほどは重要でないと考えているため、1番や2番ではないと考えている。
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    def _find_rec(self, x, y, i, cur_l, cur_r):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
`        if cur_r <= x or y <= cur_l:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`            return float("inf")`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`        elif x <= cur_l and cur_r <= y:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`            return self.arr[i]`
#### 1位 0人
#### 2位 1人
- 9 区間が丸ごと含まれている場合の、区間最小値の処理が述べられているから。これは左の区間と右の区間の最小値を再帰的に求めることが前提となっているため、1番ではないと考えた。
#### 3位 0人
### 28行目
`        else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`            return min(self._find_rec(x, y, 2 * i + 1, cur_l, (cur_l + cur_r) // 2), self._find_rec(x, y, 2 * i + 2, (cur_l + cur_r) // 2, cur_r))`
#### 1位 4人
- 1 区間に対する処理の際には，注目している区間を子区間に分割し再帰的に処理するというSegment木の核となる発想が表されているため最も重要だと考えた．
- 4 セグメント木の性質をつかって再起的に探索の関数を呼び出しているため。
- 8 セグメント木の性質を生かして、最小値を求める再帰アルゴリズムを作成しているから。
- 9 セグメント木において、区間の最小値の取得は左の区間と右の区間の最小値であることを再帰的に繰り返して求める、ということが重要であると考えており、29行目はまさしくそのことを述べているから。
#### 2位 3人
- 2 区間minをlogオーダーで求めることができる本質の行であるから。更新できることが重要ポイントであると感じたので2番目にした。
- 3 Segment Treeでどこが重要かと言われると微妙だがこの式で区間についての演算が高速にできるのはかなり本質だと思う。
- 10 最小値を取得する関数を、再帰を使って実装しているのもupdateの次にするべきこととして重要だと思いました。
#### 3位 2人
- 7 どのように最小値を得るのかをこの行で表されているから．
3番目である理由は，セグメントツリーの構造が分かれば，どのように得られるのかは分かる場合が多いと思うから．
- 11 探索の方法として，このような範囲を絞っていく再帰の関数をつくるのは重要だと感じます．2で割っていく箇所は1番目で触れたのでその要素を抜いて考えた時に3番目くらいの重要さかなとおもいました．
### 30行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`    def find(self, x, y):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`        return self._find_rec(x, y, 0, 0, self.n)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`n, q = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 37行目
`tree = SegmentTree(n)`
#### 1位 3人
- 3 Segment Treeで解けることがこの問題のコアであるから。
- 5 Q2同様、SegmentTreeを使うこと自体がもっとも重要であると考えた。
- 7 この問題の解法はセグメントツリーと呼ばれるアルゴリズムを用いるということがこの行から読み取れるから．
#### 2位 0人
#### 3位 0人
### 38行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 39行目
`    tree.set(i, 2**31 - 1)`
#### 1位 1人
- 6 セグメントツリーで区間 min を再帰的に求める根幹の部分だから。
#### 2位 0人
#### 3位 1人
- 5 7行目と同様、初期化のための数が2^31-1という巨大数であることを意識する必要があると考えたから。厳密には単位元ではないため、infよりは重要性が低いと感じた。
### 40行目
`tree.build()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 41行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 42行目
`for i in range(q):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 43行目
`    com, x, y = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 44行目
`    tree.update(x, y) if com == 0 else print(tree.find(x, y + 1))`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 10 1番や2番の次に、updateとfindを呼び出している部分が問題を解く上で重要だと思いました。
## 他の重要部分
- 9 : 7行目。区間最小値を求めるセグメント木では初期値をinfにするのが大切であるから。
## 自由記述
## 理解度
- とても理解できた。 : 5人, 1 3 6 9 11
- まあ理解できた。 : 5人, 2 4 5 7 8
- あまり理解できなかった。 : 1人, 10
- まったく理解できなかった。 : 0人, 
