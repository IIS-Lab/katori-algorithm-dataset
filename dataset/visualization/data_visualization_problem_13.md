# 問題番号13
## 基本情報
- トピック : クラスカル法
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_2_A&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144695#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  class UnionFind:
2      def __init__(self, n):
3          self.parent = [i for i in range(n)]
4          self.rank = [0 for _ in range(n)]
5  
6      def _find_root(self, x):
7          if x != self.parent[x]:
8              self.parent[x] = self._find_root(self.parent[x])
9          return self.parent[x]
10 
11     def is_same(self, x, y):
12         return self._find_root(x) == self._find_root(y)
13 
14     def unite(self, x, y):
15         root_x = self._find_root(x)
16         root_y = self._find_root(y)
17         if root_x != root_y:
18             if self.rank[root_x] > self.rank[root_y]:
19                 self.parent[root_y] = root_x
20             else:
21                 self.parent[root_x] = root_y
22                 if self.rank[root_x] == self.rank[root_y]:
23                     self.rank[root_y] += 1
24 
25 
26 def kruskal(G, V):
27     G.sort(key=lambda x: x[0])
28     tree = UnionFind(V)
29     ans = 0
30 
31     for w, s, t in G:
32         if not tree.is_same(s, t):
33             ans += w
34             tree.unite(s, t)
35 
36     return ans
37 
38 
39 V, E = map(int, input().split())
40 G = []
41 for i in range(E):
42     s, t, w = map(int, input().split())
43     G.append((w, s, t))
44 
45 print(kruskal(G, V))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
class UnionFind:                                             1  
    def __init__(self, n):                                   2  
        self.parent = [i for i in range(n)]                  3  ▲
        self.rank = [0 for _ in range(n)]                    4  ▲
                                                             5  
    def _find_root(self, x):                                 6  
        if x != self.parent[x]:                              7  
            self.parent[x] = self._find_root(self.parent[x]) 8  ●▲▲
        return self.parent[x]                                9  
                                                             10 
    def is_same(self, x, y):                                 11 
        return self._find_root(x) == self._find_root(y)      12 ▲
                                                             13 
    def unite(self, x, y):                                   14 ●
        root_x = self._find_root(x)                          15 
        root_y = self._find_root(y)                          16 
        if root_x != root_y:                                 17 ●
            if self.rank[root_x] > self.rank[root_y]:        18 
                self.parent[root_y] = root_x                 19 ▲▲
            else:                                            20 
                self.parent[root_x] = root_y                 21 
                if self.rank[root_x] == self.rank[root_y]:   22 
                    self.rank[root_y] += 1                   23 
                                                             24 
                                                             25 
def kruskal(G, V):                                           26 
    G.sort(key=lambda x: x[0])                               27 ★★★★★★●▲
    tree = UnionFind(V)                                      28 ▲
    ans = 0                                                  29 
                                                             30 
    for w, s, t in G:                                        31 
        if not tree.is_same(s, t):                           32 ★★●●●●●●
            ans += w                                         33 
            tree.unite(s, t)                                 34 ★●▲▲
                                                             35 
    return ans                                               36 
                                                             37 
                                                             38 
V, E = map(int, input().split())                             39 
G = []                                                       40 
for i in range(E):                                           41 
    s, t, w = map(int, input().split())                      42 
    G.append((w, s, t))                                      43 
                                                             44 
print(kruskal(G, V))                                         45 ★★
```
## 重要な理由の結果
### 1行目
`class UnionFind:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    def __init__(self, n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`        self.parent = [i for i in range(n)]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 1 UnionFindTreeの実装する上で，自分の親頂点をメモしておくという部分が発想として最も大切だと考えた．一方でこの問題の中心となるアルゴリズムはクラスカル法なので，3番目として選択した．
### 4行目
`        self.rank = [0 for _ in range(n)]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 11 rankをもつことでunionfindの構造を工夫して高速な処理をできる．unionfindのさらに細かい中身の話なので3番目にしました．
### 5行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    def _find_root(self, x):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`        if x != self.parent[x]:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`            self.parent[x] = self._find_root(self.parent[x])`
#### 1位 0人
#### 2位 1人
- 4 Union-Find木で重要である、rootを探すという処理の大事な部分だから。ただ、答えに直接つながるわけではない。
#### 3位 2人
- 8 再帰を用いて、親を辿るというUnionFind木の重要な性質を記述しているところだから。問題解決に直接関わらず、難しくもないので3番とした。
- 10 木構造の根を探すことは、使われていないがunionfindにおいてとても重要であるから、3番目に重要であると思った。
### 9行目
`        return self.parent[x]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`    def is_same(self, x, y):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`        return self._find_root(x) == self._find_root(y)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 5 UnionFind関数について、唯一外部から呼び出されている関数であるため重要だと考えた。
UnionFIndについての知識があまりなくても、is_sameという命名がされているため起こっていることの想像がし易いと考えた。したがって、UnionFind内部の実装よりもそれを呼び出すkruskal関数のほうが重要だと考えたため、3番目においた。
### 13行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`    def unite(self, x, y):`
#### 1位 0人
#### 2位 1人
- 10 二つの木構造をまとめる実装は、unionfindにおいてとても重要であるから、2番目に重要であると思った。1番の方が、クラスカル法のアルゴリズムで気にするところだと思った。
#### 3位 0人
### 15行目
`        root_x = self._find_root(x)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`        root_y = self._find_root(y)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        if root_x != root_y:`
#### 1位 0人
#### 2位 1人
- 8 UnionFind木において、rootが違った場合にuniteするという重要な処理をしているところだから。問題解決に直接関わるところではないので2番とした。
#### 3位 0人
### 18行目
`            if self.rank[root_x] > self.rank[root_y]:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`                self.parent[root_y] = root_x`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 3 DSUのコアはここのマージテクだと減価償却で計算量が減ることなので。
- 4 Union-Find木で重要な「親」を更新しているため。処理内容としてはかなり単純。
### 20行目
`            else:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`                self.parent[root_x] = root_y`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`                if self.rank[root_x] == self.rank[root_y]:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`                    self.rank[root_y] += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`def kruskal(G, V):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`    G.sort(key=lambda x: x[0])`
#### 1位 6人
- 1 重みの小さい辺から貪欲に見るというクラスカル法の重要な部分が表現されていると考えたため．
- 2 クラスカル法は連結かどうかで辺を追加するかどうかを決めるので、その連結判定の部分が最重要であると考えた。
- 4 クラスカル法で最も重要な、辺を重みの小さい順に並べるという処理を行なっているため。
- 5 最小全域木の問題は、貪欲法で解くことができることが本質的な部分だと考えている。したがって、コストについてグラフをソートしている27行目が最も大切だと考えた。
- 6 辺の重みに関する貪欲法であることがクラスカル法の本質である。
- 11 重さの小さい辺から取っていけば，最小全域木ができるのは重要な事実だと思います．
#### 2位 1人
- 7 クラスカル法では辺の重みの小さい順に取り出すことで最小全域木を求めることができるということがこの行で分かるから．
1番でない理由は，クラスカル法の解法を知っている人であれば分かることであるから．
#### 3位 1人
- 9 最小全域木を求める前段階の処理として、辺の長さでソートする、ということをしないと正しい結果を返さないから。実際に木を作る部分ではないため、この部分の処理は1番や2番ではないと考えた。
### 28行目
`    tree = UnionFind(V)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 7 クラスカル法の中ではUnionTreeを用いながら同じ集団に属しているかどうかを判断できるということが分かるから．
3番である理由は，最小全域木を求めることに直接関係するわけではなく，どのように取り出した辺がすでに同じ集合に属しているわけではないということを判定するかということを表しているから．
### 29行目
`    ans = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`    for w, s, t in G:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`        if not tree.is_same(s, t):`
#### 1位 2人
- 8 クラスカル法において、UnionFind木で閉路ができているかどうかの判定をしている重要なところだから。
- 10 閉路を作らないことを確認することがクラスカル法で、最も重要であると思ったため。
#### 2位 6人
- 1 注目している辺の両端の頂点が既に連結かどうかを確認する部分であり，クラスカル法の実装において中心的な部分であると考えた．一方で重みの小さい辺から見ることが発想として重要であると考え，2番目とした．
- 2 クラスカル法は事前に辺のコストでソートしておくことで高速に求められるので、これが次に重要。
- 5 ソートされた辺について、どのような条件で選んでいるかを知ることができるため重要だと考えた。しかし、貪欲法ということがわかればある程度推測可能であるため2番目においた。
- 6 辺を採用することでループが発生しない場合のみ採用することを表す行である。1 番と比べると詳細にあたる。
- 9 その辺を採用するかどうかの処理は、その2点が連結ではないということを述べている行であるから。グラフの連結を行うことが前提となっているため、1番ではないと考えた。
- 11 Unionfindですでにつながっているかを判断している大事な箇所であるとおもいます．つながっているかのあくまで道具としてつかっているので2番目にしました．
#### 3位 0人
### 33行目
`            ans += w`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
`            tree.unite(s, t)`
#### 1位 1人
- 9 最小全域木を求めるには、採用する辺を用いてグラフを連結する、という処理が最も大切であると考えているから。
#### 2位 1人
- 3 クラスカル法のコアはDSUを使えば最小全域木を構築できることなので。
#### 3位 2人
- 2 上と同様に連結判定を高速に行うためにUnion-Find木のmergeを行っている部分なので、重要であると考えた。判定そのものではなく判定のための操作なので3番目。
- 6 辺を採用することでループが発生しない場合のみ採用、を実現するために集合の併合を行う部分。2 番に対して従たる部分だと言える。
### 35行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
`    return ans`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 37行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 38行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 39行目
`V, E = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 40行目
`G = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 41行目
`for i in range(E):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 42行目
`    s, t, w = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 43行目
`    G.append((w, s, t))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 44行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 45行目
`print(kruskal(G, V))`
#### 1位 2人
- 3 この問題のコアはクラスカル法で最小全域木が構築できることなので。
- 7 この問題の解法ではクラスカル法を用いるということがこの一行で分かるから．
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 5 : 43:27行目のG.sort()で、どのようにソートされているのか直感的には分かりづらいため、tupleのリストであることを知ることができ重要だと考えた。
- 9 : 18, 22, 23行目。Union Find 木の計算量を落とすための工夫として、木にランクをつけていることを表す行であり、ここを間違えたとしても正しく動かないことはないものの、計算量が大きく落ちてしまうから。
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 5 6 9 11
- まあ理解できた。 : 4人, 4 7 8 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
