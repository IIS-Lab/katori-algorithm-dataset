# 問題番号6
## 基本情報
- トピック : 0・1ナップサック問題(DP)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144710#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  N, W = map(int, input().split())
2  v = [0 for _ in range(N)]
3  w = [0 for _ in range(N)]
4  for i in range(N):
5      v[i], w[i] = map(int, input().split())
6  
7  dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)]
8  for i in range(N):
9      for j in range(W + 1):
10         dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]) if j - w[i] >= 0 else dp[i][j]
11 
12 print(dp[N][W])
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
N, W = map(int, input().split())                                                            1  
v = [0 for _ in range(N)]                                                                   2  
w = [0 for _ in range(N)]                                                                   3  
for i in range(N):                                                                          4  
    v[i], w[i] = map(int, input().split())                                                  5  ▲
                                                                                            6  
dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)]                                      7  ★●●●●●●●▲
for i in range(N):                                                                          8  ●▲
    for j in range(W + 1):                                                                  9  ▲▲
        dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]) if j - w[i] >= 0 else dp[i][j] 10 ★★★★★★★★★★●
                                                                                            11 
print(dp[N][W])                                                                             12 ●●▲▲▲▲▲▲
```
## 重要な理由の結果
### 1行目
`N, W = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`v = [0 for _ in range(N)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`w = [0 for _ in range(N)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`for i in range(N):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    v[i], w[i] = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 2 10行目と7行目が最も重要な部分であるが、一応入力をしないと問題は解けないので、5行目が次に大切。
### 6行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)]`
#### 1位 1人
- 1 初期化したDPテーブルを更新する箇所でありDPの考察の大部分を占めているとともに，ミスが起こりやすい箇所でもあるため重要だと考えた．
#### 2位 7人
- 2 動的計画法をつかうことにより、O(NW)で求めることができるが、そのdp配列を宣言していることも大切であると考えた。(dpの本質部分ではないので2番目。)
- 5 直感的に理解できる部分ではあるが、DPテーブルの設計について(V,Wに１を加えた大きさであること)の補足知識を得られるから
- 6 動的計画法の更新の初期条件が含まれているから。漸化式においては更新式の次に重要と言えるだろう。
- 8 dpテーブルを作成するのも、動的計画法においては大切だから。1番に比べると本質的ではないと思った。
- 9 DPの初期値を表しているから。DPの問題においては初期値が遷移の次に大切であるので、この順番である。
- 10 dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)]はdpテーブルの初期化として、漸化式ほどではないが重要だと思ったため。
- 11 この問題を二次元リストで管理するという発想自体が大事だと思います．どう管理するかは1番目にあげたので，2番目には構造をあげました．
#### 3位 1人
- 4 動的計画法を行うためのテーブルを初期化しているため。初期化のみのため1番や2番にはならない。
### 8行目
`for i in range(N):`
#### 1位 0人
#### 2位 1人
- 3 dpは状態を適切に管理することで全探索を効率化することだと考えられるが、9行目と合わせてここが全探索部分なので。
#### 3位 1人
- 6 テーブルの更新順序を規定している行だから。1 番や 2 番の部分が決まれば自然に定まるので、それらより重要とは言えない。
### 9行目
`    for j in range(W + 1):`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 3 dpは状態を適切に管理することで全探索を効率化することだと考えられるが、8行目と合わせてここが全探索部分なので。
- 7 容量Wに関するdpであることがこの行で確認できるから．
3番目である理由は，特に他のものに注目したdpでも可能であるため．
### 10行目
`        dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]) if j - w[i] >= 0 else dp[i][j]`
#### 1位 10人
- 2 ナップサック問題の漸化式の部分であり、これのおかげで指数時間から改善することができているため。
- 3 ナップサック問題は要はdpで解けることが一番大事だが、そのコアはここの遷移式なので。
- 4 動的計画法を行うためのテーブルを更新する重要な処理が行われているため。
- 5 DPの処理がワンライナーで記述されており、どのようにDPテーブルが書き込まれているかわかりやすいから
- 6 動的計画法の根幹である、テーブルの更新を行っている部分だから。
- 7 dpを行うために一番重要となる，値を更新するための条件式が書かれているから．
- 8 動的計画法において、最も本質的な部分を表している場所だから。
- 9 DPの遷移を表しており、DPの問題においては遷移が最も大事な箇所であると考えているから。
- 10 動的計画法で一番重要な式を表していおり、重要であると感じたため。
- 11 dpテーブルの更新を行なっていくところであるから．漸化式をどう定義するか考えるのがDPの一番の要点だと思います．
#### 2位 1人
- 1 DPテーブルを構築している箇所であり，DPの本質部分の一つだと考え選択した．DPテーブルの更新を行う部分に比べると考察の必要は少なく，ミスも起こりにくいと考え2番目とした．
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`print(dp[N][W])`
#### 1位 0人
#### 2位 2人
- 4 答えを出力するために動的計画法の結果のテーブルを参照しているため。ただ処理としては参照をしているだけ。
- 7 dpの結果，最終的に求めたい答えはdp[N][W]に現れるということがこの行で現れているから．
1番目でない理由は，dpの更新アルゴリズムが分かればこのことは最終的に分かることであるから．
#### 3位 6人
- 1 完成させたDPテーブルを用いて要求された答えを出力する部分であるため重要だと考えた．
DPテーブルの初期化，更新の方がより本質的かつ注意を要する部分だと考え，3番目とした．
- 5 上記２つの行で処理の本質的な部分はすべて網羅しているが、補足として、DPテーブルのどの部分に最終的な結果が書き込まれていることが分かるから
- 8 動的計画法の答えがテーブルの右下に出てくるというのも、知らないと分からないから。アルゴリズムそのものではないので重要度は低いと思った。
- 9 DPテーブルの中で、答えが格納されている場所を表しているから。DPテーブルの中でこの場所に答えが格納されていることは、DPテーブルが正しく更新されたことが前提であるため、優先順位は前者二つに比べると低くなる。
- 10 dp[N][W]を出力し、価値の合計の最大値を求めることが、1,2番ほど難しくないが重要だと感じたため。
- 11 最終的に欲しい状態がテーブルの中のどこに存在しているかを把握するのは大事だと思います．どこを見るかよりも情報自体を作るのが大事だと考えたので，3番目にしました．
## 他の重要部分
- 6 : 9。8 行目と同様に重要。
## 自由記述
## 理解度
- とても理解できた。 : 9人, 1 2 3 4 5 6 8 9 11
- まあ理解できた。 : 2人, 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
