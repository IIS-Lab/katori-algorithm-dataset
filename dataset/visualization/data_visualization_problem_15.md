# 問題番号15
## 基本情報
- トピック : ベルマンフォード法
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7130661#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  def bellman_ford(G, V, r):
2      dist = [float("inf") for _ in range(V)]
3      dist[r] = 0
4  
5      for i in range(V):
6          for s, t, d in G:
7              if dist[t] > dist[s] + d:
8                  dist[t] = dist[s] + d
9                  if i == V - 1:
10                     print("NEGATIVE CYCLE")
11                     return
12 
13     for i in range(V):
14         print("INF" if dist[i] == float("inf") else dist[i])
15 
16 
17 V, E, r = map(int, input().split())
18 G = []
19 for i in range(E):
20     s, t, d = map(int, input().split())
21     G.append((s, t, d))
22 
23 bellman_ford(G, V, r)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
def bellman_ford(G, V, r):                                   1  
    dist = [float("inf") for _ in range(V)]                  2  ▲
    dist[r] = 0                                              3  
                                                             4  
    for i in range(V):                                       5  ★★●●▲
        for s, t, d in G:                                    6  ●▲▲
            if dist[t] > dist[s] + d:                        7  ★★●●●▲
                dist[t] = dist[s] + d                        8  ★★★★●▲
                if i == V - 1:                               9  ★●●●●▲▲▲▲
                    print("NEGATIVE CYCLE")                  10 
                    return                                   11 
                                                             12 
    for i in range(V):                                       13 
        print("INF" if dist[i] == float("inf") else dist[i]) 14 ▲
                                                             15 
                                                             16 
V, E, r = map(int, input().split())                          17 
G = []                                                       18 
for i in range(E):                                           19 
    s, t, d = map(int, input().split())                      20 
    G.append((s, t, d))                                      21 
                                                             22 
bellman_ford(G, V, r)                                        23 ★★
```
## 重要な理由の結果
### 1行目
`def bellman_ford(G, V, r):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    dist = [float("inf") for _ in range(V)]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 8 距離を十分に大きな値で初期化しておくのはベルマンフォード法を実行するにあたって重要だから。アルゴリズムの本質ではないので3番にした。
### 3行目
`    dist[r] = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    for i in range(V):`
#### 1位 2人
- 1 全ての辺を用いて経路更新を行う操作を頂点の数(-1)回行うことで最短経路を求めるというベルマンフォード法の重要な考え方が表されていると考えたため．
- 5 Dijkstra法やBFSなどとベルマンフォード法との大きな差異は、V回のループを回すことだと考えているため、この部分が最も如実に現れた5行目が最重要だと考えた。
#### 2位 2人
- 3 ベルマンフォードの本質は探索順序だと思うが、ここの中継点でループを回すところで、扱うノードによる集合を大きくしていっているから。
- 11 全てのノードを出発点にして同じ操作をするということが表れている箇所だから．ノードの情報が書き変わる部分の方がなんとなく重要に感じてしまいました．
#### 3位 1人
- 6 高々頂点数回分のループで距離の更新が完了することを示す、プログラムの停止性に関わる部分。1 番、2 番ほどは直接答えに関係しない。
### 6行目
`        for s, t, d in G:`
#### 1位 0人
#### 2位 1人
- 1 全ての辺を用いて経路更新を行う操作を頂点の数(-1)回行うことで最短経路を求めるというベルマンフォード法の重要な考え方が表されていると考えたため選択した．一方で，頂点の数-1回の更新で済むという部分は1番目で表されているため，こちらは2番目とした．
#### 3位 2人
- 2 ぐるぐる回す部分でグラフの辺を全部見ている部分なので、直接的ではないが、残りの行の中では一番重要だと考えた。
- 10 1番2番に気をつけた上で、ダイクストラと違い、全ての辺に対しての計算を毎回行うことが重要だと思った。
### 7行目
`            if dist[t] > dist[s] + d:`
#### 1位 2人
- 2 ぐるぐる回して最短距離が更新できるなら更新する、というアルゴリズムなので、距離更新できるかを見ている行が重要だと考えた。
- 11 その辺を選んだ時両端のノードの情報がどう変わるかという，辺の重みの更新方針がわかる一行だと思えるからです．
#### 2位 3人
- 6 最短距離の更新条件が示されている行であり、1 番に対し従たる部分である。
- 7 ループの中でどのような条件を満たせば値の更新を行なっていくのかということがこの行で現れているから．
1番でない理由としては，これはベルマンフォード法の一部分であり，この部分だけからではアルゴリズム全体を把握できるわけではないから．
- 9 最短経路の更新条件を表す行であり、条件を間違えると正しく動作しないから。最短経路の更新の操作を直接行う行ではないため、重要度は2番目と考えている。
#### 3位 1人
- 5 メモの更新という基本的なテクニックであるため上2つと比較して重要性は低いが、最短距離の更新がどのように行われているのかは重要だと考えた。
### 8行目
`                dist[t] = dist[s] + d`
#### 1位 4人
- 4 距離を更新できれば更新するというベルマンフォード法の本質的な処理だから。
- 6 最短距離の更新を実際に行っている部分であり、ベルマンフォード法の根幹。
- 8 ベルマンフォード法で距離の更新を行なっている重要な記述だから。
- 9 最短経路を更新する行であり、ここがないと最短経路が更新されず、アルゴリズムが全く動作しないから。
#### 2位 1人
- 10 1番に気をつけた上で、全ての辺に対してdistの更新を行う部分が、重要だと思った
#### 3位 1人
- 3 ベルマンフォード法で実際に遷移を行っている部分がここだから。
### 9行目
`                if i == V - 1:`
#### 1位 1人
- 10 ベルマン・フォード法において負の閉路の検知することがとても重要だと思ったため。
#### 2位 4人
- 2 V回ぐるぐる回しても最短距離の更新が起こる場合は負のサイクルがあるという意味なので、その検出を行っている行が次に重要であると考えた。
- 4 NEGATIVE CYCLEの検出をこの条件で行えるのがベルマンフォード法の大事なところだから。ただ最短経路というところには関係ない。
- 5 この問題では、負の閉路検出のためにベルマンフォード法を採用している。したがって、「i回目のループで頂点の更新が起きた」という条件を表している9行目が2番目に重要だと考えた。最重要としなかったのは、9行目の把握のためにはV回ループを回すことを理解している必要があるため。
- 8 負の値を持つ閉路ができているときに検知するという大事なところだから。必ずしも使われるところではないので2番とした。
#### 3位 4人
- 1 負の閉路がなければ，最短経路の更新はV-1回で終了することを用いて負の閉路を検出する箇所であり，負の閉路があるような設定では重要だと考えた．最短経路を求めるという点において1,2番目の方がより重要と考え，3番目とした．
- 7 どのように負の経路を見つけるかということがこの条件文に書かれているから．
3番である理由は，負の経路があることは例外的なものであり，問題全体的に関係する部分ではないから．
- 9 負閉路検出条件を表している行であるから。負閉路は検出が行われない場合もあるため、前2つに比べると重要度は下がると考えている。
- 11 負閉路がないか確認できる嬉しい箇所であるから．最短経路検出できない->負閉路という順序であり，主役は最短経路の方だと感じるので3番目です．
### 10行目
`                    print("NEGATIVE CYCLE")`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`                    return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`    for i in range(V):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        print("INF" if dist[i] == float("inf") else dist[i])`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 4 辿り着けないとき判定と処理も大事だから。ただ、処理は単純である。
### 15行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`V, E, r = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`G = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`for i in range(E):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`    s, t, d = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`    G.append((s, t, d))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`bellman_ford(G, V, r)`
#### 1位 2人
- 3 この問題のコアは、厳密にいえば単一始点でちょっと手を加えて解けることなので。
- 7 この問題を解くために，ベルマンフォード法と呼ばれるアルゴリズムを用いれば良いということがこの行から読み取れるから．
#### 2位 0人
#### 3位 0人
## 他の重要部分
## 自由記述
## 理解度
- とても理解できた。 : 9人, 1 2 3 4 5 6 8 9 11
- まあ理解できた。 : 2人, 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
