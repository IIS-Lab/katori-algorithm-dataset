# 問題番号3
## 基本情報
- トピック : 計数ソート
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_A&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144591#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  MAX = 10001
2  
3  
4  def count_sort(arr):
5      count = [0 for _ in range(MAX)]
6      for i in arr:
7          count[i] += 1
8  
9      index = 0
10     for i in range(0, MAX):
11         for _ in range(count[i]):
12             arr[index] = i
13             index += 1
14 
15     return arr
16 
17 
18 N = int(input())
19 A = list(map(int, input().split()))
20 
21 print(*count_sort(A))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
MAX = 10001                         1  
                                    2  
                                    3  
def count_sort(arr):                4  
    count = [0 for _ in range(MAX)] 5  ★★★
    for i in arr:                   6  
        count[i] += 1               7  ★●●●●▲▲▲▲
                                    8  
    index = 0                       9  ▲
    for i in range(0, MAX):         10 ★★
        for _ in range(count[i]):   11 ★●●▲▲▲
            arr[index] = i          12 ★★★★●●●▲
            index += 1              13 ●●▲▲
                                    14 
    return arr                      15 
                                    16 
                                    17 
N = int(input())                    18 
A = list(map(int, input().split())) 19 
                                    20 
print(*count_sort(A))               21 
```
## 重要な理由の結果
### 1行目
`MAX = 10001`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def count_sort(arr):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    count = [0 for _ in range(MAX)]`
#### 1位 3人
- 1 
各要素について出現回数を記録するという計数ソートのアルゴリズムの発想を端的に表した一行だと考えたため．1番目とした．
- 5 計数ソートの根本的な考え方である、巨大な配列を用意している部分だから
- 11 ありえる要素の値がインデックスとなった計数のための場所をあらかじめ確保しておくことがこのソートの要だと考えたから
#### 2位 0人
#### 3位 0人
### 6行目
`    for i in arr:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`        count[i] += 1`
#### 1位 1人
- 9 計数ソートのエッセンスは、「何の要素が何個ある」という配列を組み立てる部分だと考えており、7行目はそれを言い表したものだと言えるから。
#### 2位 4人
- 2 計数ソートというアルゴリズムの通り、数を数えて行うソートだが、その計数の部分を行っている行であるから。
- 5 計数ソートで実際にどのように配列を更新しているかがわかりやすいから
- 6 計数ソートに必要な度数分布表を計算する根幹の部分だから。1 番ではないのは、あくまで前処理の意味合いが強いから。
- 10 count[i] に i の出現数を記録して、カウンタ配列を作ることは1番ほど難しくないが、重要だと思ったため。
#### 3位 4人
- 3 計数しているところもしいて言えば重要かもしれないと思ったから。
- 4 このソーティングアルゴリズムで重要になるcountリストの中身を決めているため。ただ数え上げているだけではある。
- 7 問題文の疑似コードでの「 C[i] に i の出現数を記録する 」という操作を実行している部分にあたるから．
3番である理由は，ほとんど疑似コード通りであることから．
- 8 計数ソートを作るために、登場する数字をカウントするという大事なところだから。簡単なので3番とした。
### 8行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`    index = 0`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 11 インデックスを動かしていく変数をもつのもコードのわかりやすさのために大事かなと思いました．別の書き方もでき，計数ソートの本質ではないので，3番目になりました．
### 10行目
`    for i in range(0, MAX):`
#### 1位 2人
- 2 計数ソートの重要なアイデアとして、同じ数字をまとめて処理する、という部分があり、そのまとまて処理している部分であるから。
- 6 度数分布表を左から見る、というのが計数ソートにおけるソートの部分だから。
#### 2位 0人
#### 3位 0人
### 11行目
`        for _ in range(count[i]):`
#### 1位 1人
- 4 countリストを順番に見ていくという操作がこのソーティングアルゴリズムの本質だから。
#### 2位 2人
- 1 各要素の出現回数に応じてソートされる配列を更新する部分であり，計数ソートの核となる発想であると考えたが，5行目のカウンターの初期化部分の方がより本質的と考え，2番目とした．
- 7 配列の要素を一回一回書き換えるのではなく，for文であらかじめ決められた回数繰り返して同じ数を代入すればよいということが分かる．
1番でない理由としては，indexという変数をつかっているおかげで実現できるから．
#### 3位 3人
- 5 バケットに格納された数だけarrayにpushするという考え方が現れているから
- 6 出現回数分だけソート結果に入ることを表す行だから。1 番や 2 番と比べると、ソートという文脈からは遠いと言える。
- 10 出現回数分繰り返すことは、1,2番ほど難しくないが重要だと思ったため。
### 12行目
`            arr[index] = i`
#### 1位 4人
- 3 バケツソートでどこが重要かは難しいところだがしいて言えば計数後に順番に配列をつくるところ、かもしれないから。
- 7 返す配列のindexを持ち，indexをインクリメントしながら最終的な配列を更新していくことで，問題文の疑似コード部分の「C[i] に i 以下の数の出現数を記録する」操作が必要ないということが分かるから．
- 8 計数ソートを昇順で作成する際に、その配列を１つずつ埋めていくという最も本質的な処理だから。
- 10 結果となる配列に値を代入している行で、計数ソートを一番よく表している行だと思ったため。
#### 2位 3人
- 4 答えを表すリストに何を詰めるのかを決めている部分だから。ただ処理としては単純。
- 9 12行目の処理は配列に計数ソートの結果を小さい順に並べる部分の処理であり、この処理は結果を正しく返す上では大事であるから。アルゴリズムの中心の部分ではないため、この部分は2番目に重要である。
- 11 要素の値が小さいほうからソートした配列が格納されるリストにいれている行だから．計数しているところではないので2番目にしました．
#### 3位 1人
- 2 複雑ではないが、計数ソートの答えを求めている部分であるから。
### 13行目
`            index += 1`
#### 1位 0人
#### 2位 2人
- 3 数後に順番に配列をつくるところでまあインデックス管理も重要かな、と思ったから。
- 8 上と同じような理由だが、インデックスを進めていかないと正しく配列が作成できないから。計数ソートの本質は12行目の方だと思ったので2番にした
#### 3位 2人
- 1 各要素の出現回数に応じてソートされる配列のインデックスを適切に設定する部分であり，アルゴリズムの本質ではないが，ミスが起こりやすい部分だと考えたため3番とした．
- 9 インデックスを1ずつ進める箇所も、アルゴリズムを正しく動作させるという処理の一部分では重要であるから。あくまでアルゴリズムの本質の部分ではなく、処理の一部分にすぎないため、この部分は3番目に重要であると考えている。
### 14行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`    return arr`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`N = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`A = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`print(*count_sort(A))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 5 : 10:計数ソートの計算量がO(n+k)であることを表している行だと思うから
## 自由記述
- 9 : どこが大事な箇所なのかは比較的早い段階で思いつくのですが、その中での順位付けをするのが大変だと感じます。
## 理解度
- とても理解できた。 : 9人, 1 2 3 4 5 6 8 9 11
- まあ理解できた。 : 2人, 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
