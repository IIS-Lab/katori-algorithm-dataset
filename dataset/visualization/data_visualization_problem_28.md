# 問題番号28
## 基本情報
- トピック : SPFA
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144810#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  from collections import deque
2  
3  
4  def spfa(G, r):
5      dist = [float("inf") for _ in range(len(G))]
6      queue = deque()
7      queue_flag = [False for _ in range(len(G))]
8      queue_count = [0 for _ in range(len(G))]
9  
10     dist[r] = 0
11     queue.append(r)
12     queue_flag[r] = True
13     queue_count[r] = 1
14 
15     while queue:
16         cur = queue.pop()
17         queue_flag[cur] = False
18         for nxt, cost in G[cur]:
19             if dist[nxt] > dist[cur] + cost:
20                 dist[nxt] = dist[cur] + cost
21                 if not queue_flag[nxt]:
22                     queue.append(nxt)
23                     queue_flag[nxt] = True
24                     queue_count[nxt] += 1
25                     if queue_count[nxt] >= len(G):
26                         print("NEGATIVE CYCLE")
27                         return
28 
29     for i in range(len(G)):
30         print("INF" if dist[i] == float("inf") else dist[i])
31 
32 
33 V, E, r = map(int, input().split())
34 G = [[] for _ in range(V)]
35 for i in range(E):
36     s, t, d = map(int, input().split())
37     G[s].append((t, d))
38 
39 spfa(G, r)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
from collections import deque                                1  
                                                             2  
                                                             3  
def spfa(G, r):                                              4  
    dist = [float("inf") for _ in range(len(G))]             5  
    queue = deque()                                          6  ●
    queue_flag = [False for _ in range(len(G))]              7  
    queue_count = [0 for _ in range(len(G))]                 8  
                                                             9  
    dist[r] = 0                                              10 
    queue.append(r)                                          11 
    queue_flag[r] = True                                     12 
    queue_count[r] = 1                                       13 
                                                             14 
    while queue:                                             15 ●
        cur = queue.pop()                                    16 ★
        queue_flag[cur] = False                              17 ●
        for nxt, cost in G[cur]:                             18 ●
            if dist[nxt] > dist[cur] + cost:                 19 ★●
                dist[nxt] = dist[cur] + cost                 20 ★●●▲▲▲
                if not queue_flag[nxt]:                      21 ●●●
                    queue.append(nxt)                        22 ★★★●
                    queue_flag[nxt] = True                   23 ★▲
                    queue_count[nxt] += 1                    24 
                    if queue_count[nxt] >= len(G):           25 ★★▲▲▲▲▲▲▲
                        print("NEGATIVE CYCLE")              26 
                        return                               27 
                                                             28 
    for i in range(len(G)):                                  29 
        print("INF" if dist[i] == float("inf") else dist[i]) 30 
                                                             31 
                                                             32 
V, E, r = map(int, input().split())                          33 
G = [[] for _ in range(V)]                                   34 
for i in range(E):                                           35 
    s, t, d = map(int, input().split())                      36 
    G[s].append((t, d))                                      37 
                                                             38 
spfa(G, r)                                                   39 ★★
```
## 重要な理由の結果
### 1行目
`from collections import deque`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def spfa(G, r):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    dist = [float("inf") for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    queue = deque()`
#### 1位 0人
#### 2位 1人
- 7 SPFAではqueueを用いることでより効率的に頂点の最短距離を更新していくことができるため，queueを用いるということを表す行は重要であると思ったから．
1番でない理由は，SPDAのアルゴリズム全体をこの行だけで把握できるわけではなく，アルゴリズムの一部にすぎないから．
#### 3位 0人
### 7行目
`    queue_flag = [False for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`    queue_count = [0 for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`    dist[r] = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`    queue.append(r)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    queue_flag[r] = True`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`    queue_count[r] = 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`    while queue:`
#### 1位 0人
#### 2位 1人
- 3 queueに更新されたノードを積んでいき更新できる限り更新するのがSPFAで重要だと思うから。
#### 3位 0人
### 16行目
`        cur = queue.pop()`
#### 1位 1人
- 8 キューというデータ構造を用いて、順に経路を探索していくというのはspfaのアルゴリズムで最も大事なことだから。
#### 2位 0人
#### 3位 0人
### 17行目
`        queue_flag[cur] = False`
#### 1位 0人
#### 2位 1人
- 9 暫定的に、「まだ最短経路の更新がなされる可能性があるか」を「ない」に変えることを表す行であるから。ここを更新することで、無駄な頂点を見ないようにすることが可能となり、速くアルゴリズムを作動させるためには重要と考えている。プログラムの速さに関する箇所であるため、1番重要というわけではないと考えている。
#### 3位 0人
### 18行目
`        for nxt, cost in G[cur]:`
#### 1位 0人
#### 2位 1人
- 1 距離が更新された頂点に隣接する頂点に関しては距離の更新の確認を行うというSPFAの考え方を表している行であるため，選択した．1番の方が同じ考え方を端的に表している部分だと考え，こちらは2番目とした．
#### 3位 0人
### 19行目
`            if dist[nxt] > dist[cur] + cost:`
#### 1位 1人
- 6 最短距離を更新する条件が示されている。最短路問題を解くにあたり根幹となる操作である。
#### 2位 1人
- 8 最短経路を更新していくための書き方で、重要だと思った。しかしspfa特有の書き方ではないので、2番とした。
#### 3位 0人
### 20行目
`                dist[nxt] = dist[cur] + cost`
#### 1位 1人
- 11 最短経路を求める時の更新の仕方が表れている一行であると考えたから．
#### 2位 2人
- 2 一応最短経路を求めるアルゴリズムなので、最短距離が更新できれば更新する、という操作を入れる部分も大事だと感じる。高速化ベルマンフォードの高速化の部分の方が大事だと感じたので2番目。
- 4 答えとなるdistを更新する行だから。ただ処理はcostをたすだけで単純だから。
#### 3位 3人
- 3 SPFAをDPとして見たときに、更新式はここで行われているから。
- 7 最短距離を更新できそうなら更新していくという操作を順序に行うことで最終的に全体の最短距離を求めることに繋がるから．
3番である理由は，SPFAにおいてqueueを用いていることの方が重要ではないかと考えたから．
- 10 1番2番の次に、ベルマンフォードと同じようにdistを更新することが重要だと思ったため。
### 21行目
`                if not queue_flag[nxt]:`
#### 1位 0人
#### 2位 3人
- 5 dijkstra法との違いのない部分なので重要度は落ちるが、queueにappendするかどうかの判断基準の部分なので重要だと考えた。

- 10 1番の次に、すでに調べたノードは飛ばすことが重要であると思ったため。
- 11 まだ訪れていない箇所に対して探索を進める方針が大事だから．下支えのような工夫だと感じたので2番目にしました．
#### 3位 0人
### 22行目
`                    queue.append(nxt)`
#### 1位 3人
- 1 距離が更新された頂点だけをキューに入れることにより，無駄な距離更新の確認を省くという考え方を表しているため選択した．
- 2 SPFAはベルマンフォード法で最短距離が更新された頂点しか回さないことで高速化を達成しているので、queueを使っているこの行が大事だと考えた。
- 4 SPFAではキューをこのように使うということが表れている行だから。
#### 2位 1人
- 6 最短路が更新された頂点を今後の処理対象とすることが示されている。SPFA が高速に動作する原理である。処理時間改善に過ぎないので 1 番ではない。
#### 3位 0人
### 23行目
`                    queue_flag[nxt] = True`
#### 1位 1人
- 9 暫定的に、「まだ最短経路の更新がなされる可能性があるか」を「ある」に変えることを表す行であるから。ここで最短経路の更新可能性を更新することが、正しく最短経路の更新を行う上では重要と考えている。
#### 2位 0人
#### 3位 1人
- 5 21行目を理解するにあたって、queue_flagとはどのようなフラグなのかを知るのに必要であるため23行目が3番目に大切だと考えた。
### 24行目
`                    queue_count[nxt] += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`                    if queue_count[nxt] >= len(G):`
#### 1位 2人
- 5 Dijkstra法について知っている前提で考えると、DijkstraでなくSPFAを使う最大の理由であろう負の閉路検出について書かれている25行目がもっとも大切だと考えた。
- 10 spfaにおいて、負の経路の検出をして、whie文を抜けることは重要であると思ったため。
#### 2位 0人
#### 3位 7人
- 1 負閉路が検出できる条件を表しており重要だと考えた．SPFAの中心的な考え方は1,2番目であると考えて3番目とした．
- 2 回りすぎたら負のサイクルがあるという判定も重要だと考える。上二つの方が最短距離を求める部分でより本質的だと感じたので、これは3番目。
- 4 NEGATIVE CYCLEを判定している部分だから。ただこの判定はSPFAの本質からは離れている。
- 6 負閉路の存在条件が示されている。1, 2 番と比べると最短路問題の文脈からは外れている。
- 8 閉路を検出するのも、最短経路の探索においては重要だから。経路探索そのものの方が大切だと思ったので3番とした。
- 9 負閉路検出を行う行であるから。負閉路検出は必ずしも必要ではないため、1番や2番ではないと考えている。
- 11 負閉路を検出できるのは嬉しいポイントであるから．副次的な印象をうけるので3番目にしました．
### 26行目
`                        print("NEGATIVE CYCLE")`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`                        return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`    for i in range(len(G)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`        print("INF" if dist[i] == float("inf") else dist[i])`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
`V, E, r = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 34行目
`G = [[] for _ in range(V)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`for i in range(E):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 36行目
`    s, t, d = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 37行目
`    G[s].append((t, d))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 38行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 39行目
`spfa(G, r)`
#### 1位 2人
- 3 このとき方においてはspfaで解けることに気付いていることが肝だから。
- 7 この問題の解法では，SPFAと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 7 : 21: すでにqueueに挿入されている頂点はこの行の条件文で除くことで，重複しないようにでき，queueを用いても探索を実現することにつながっているから．
25: 負の経路の存在を判定するのに必要な条件だから．
## 自由記述
- 5 : 私の勘違いである可能性もありますが、このコードならqueueの命名はstackが適切なように思えます。
## 理解度
- とても理解できた。 : 4人, 3 4 6 8
- まあ理解できた。 : 7人, 1 2 5 7 9 10 11
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
