# 問題番号11
## 基本情報
- トピック : クイックソート
- 問題リンク : https://drive.google.com/file/d/1TIx0AkrxxxW1MZxFGCpplkjHJe4mMUDP/view?usp=share_link
- 解答リンク : https://atcoder.jp/contests/math-and-algorithm/submissions/37034471
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  def quick_sort(arr, left, right):
2      if left >= right:
3          return
4  
5      pivot = arr[left]
6      cur_l = left
7      cur_r = right
8      while True:
9          while arr[cur_l] < pivot:
10             cur_l += 1
11         while arr[cur_r] > pivot:
12             cur_r -= 1
13         if cur_l >= cur_r:
14             break
15         arr[cur_l], arr[cur_r] = arr[cur_r], arr[cur_l]
16         cur_l += 1
17         cur_r -= 1
18 
19     quick_sort(arr, left, cur_l - 1)
20     quick_sort(arr, cur_r + 1, right)
21 
22     return arr
23 
24 
25 N = int(input())
26 A = list(map(int, input().split()))
27 
28 print(*quick_sort(A, 0, len(A) - 1))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
def quick_sort(arr, left, right):                       1  
    if left >= right:                                   2  ▲
        return                                          3  
                                                        4  
    pivot = arr[left]                                   5  ★★▲▲
    cur_l = left                                        6  
    cur_r = right                                       7  
    while True:                                         8  
        while arr[cur_l] < pivot:                       9  ★★●
            cur_l += 1                                  10 
        while arr[cur_r] > pivot:                       11 ●
            cur_r -= 1                                  12 
        if cur_l >= cur_r:                              13 ▲
            break                                       14 
        arr[cur_l], arr[cur_r] = arr[cur_r], arr[cur_l] 15 ★★★★●●▲▲▲▲▲
        cur_l += 1                                      16 
        cur_r -= 1                                      17 
                                                        18 
    quick_sort(arr, left, cur_l - 1)                    19 ★●●●●●●▲
    quick_sort(arr, cur_r + 1, right)                   20 ●▲
                                                        21 
    return arr                                          22 
                                                        23 
                                                        24 
N = int(input())                                        25 
A = list(map(int, input().split()))                     26 
                                                        27 
print(*quick_sort(A, 0, len(A) - 1))                    28 ★★
```
## 重要な理由の結果
### 1行目
`def quick_sort(arr, left, right):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    if left >= right:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 クイックソートが終了する条件を表しており、ソートの本質部分ではないものの、プログラムを正しく動作させる上では重要な箇所であると考えたから。
### 3行目
`        return`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    pivot = arr[left]`
#### 1位 2人
- 10 pivotをarr[left]と置くことで、whileの中身がシンプルになるので重要だと思いました。
- 11 ある基準点をつくってその点より上か下かで整列していくというソートの初歩であるため．
#### 2位 0人
#### 3位 2人
- 3 swapのための基準であるpivotを決めているところはswapほどではないが重要だと考えた。
- 8 クイックソートにおいて、pivotの選び方はいろいろあるが、ここでは1番左のものをpivot
にしているというのがここから分かるから。割と些事だと思ったので3番にした。
### 6行目
`    cur_l = left`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`    cur_r = right`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`    while True:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`        while arr[cur_l] < pivot:`
#### 1位 2人
- 1 基準値よりも小さいものと大きいものに分けるという考え方を表しているため重要だと考えた．
- 2 ピボットを固定してピボットより左はピボットより小さく、右は大きくしたいが、そのswapを行うindexを決めている行であるから。
#### 2位 1人
- 4 リストの右側と左側に分けるためのカーソル位置を決める条件文だから。あくまで1番の処理を行うための条件文だから。
#### 3位 0人
### 10行目
`            cur_l += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`        while arr[cur_r] > pivot:`
#### 1位 0人
#### 2位 1人
- 2 上と同様に、swapを行うindexを決めている行である。後に出てきたので2番目。
#### 3位 0人
### 12行目
`            cur_r -= 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`        if cur_l >= cur_r:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 11 終了条件を正しくかかないと不具合がおこるため．アルゴリズムの本質からはなれるように感じたので3番目です．
### 14行目
`            break`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`        arr[cur_l], arr[cur_r] = arr[cur_r], arr[cur_l]`
#### 1位 4人
- 4 今見ているリストの左側と右側にpivotを基準に分けるというクイックソートの本質的な処理をしているため。
- 6 小さいものを左、大きいものを右に寄せるための交換操作をする行で、ソートの根幹だから。
- 8 クイックソートというアルゴリズムで、pivotを基準として左右に振り分けていくという作業がもっともよく表れている一文だから。
- 9 左側にある、ピボットより大きい値と、右側にある、ピボットより小さい値を、スワップする箇所であり、この部分がクイックソートの処理の本質部分であるといえるから。
#### 2位 2人
- 3 クイックソートは境界を決めて左右でswapを繰り返すのが本質だから。
- 11 まさに順序が逆転している箇所を入れ替えている行だから．pivotの概念よりはこのアルゴリズムにとくゆうではないから2番目です．
#### 3位 5人
- 2 swapするindexを決めた上で、実際にそのswapをしている行であるから。indexを決める方が大事であると考えたので3番目にした。
- 5 マーカーの移動だけではpivotより大きい/小さいものに分けることはできないが、このSwap処理が入ることで左右に振り分けられるのだということが分かるようになるから
- 6 クイックソートが再帰的なアルゴリズムであることを示す行だから。2 番と同様に重要。
- 7 pivotより小さい数を左に，大きい数を右にという操作を行うというクイックソートのそれぞれの試行で行われている操作がこの一行で分かるから．
3番目である理由は，1番目のクイックソートとアルゴリズム名の判明と2番目の再起的に行うことで高速化していることよりは重要度が低いと考えたため．
- 10 値をスワップさせることはクイックソートで基本的なので、3番目に重要であると思いました。
### 16行目
`        cur_l += 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        cur_r -= 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`    quick_sort(arr, left, cur_l - 1)`
#### 1位 1人
- 5 クイックソートが再帰的な処理で、左と右にpivot以外を分けて処理しているのだということが、20行目と合わせて理解できるから。
#### 2位 6人
- 1 分割した配列について操作を行うという考え方を表しているため重要だと考えた．分割した配列に対して行う操作を表している1番目よりは重要ではないと考え，2番目として選択した．
- 6 クイックソートが再帰的なアルゴリズムであることを示す行だから。ソート自体を処理しているとは言えないので 1 番ではない。
- 7 クイックソートでは，再起的に領域を狭めながらソートを実現するアルゴリズムであることがこの一行でわかるから．(20行目も同様だと思います．)
1番でない理由は，ここだけではどのようなアルゴリズムなのか全体を把握はできないため．
- 8 クイックソートで再帰を使うというのも、アルゴリズム上とても重要だから。1番の方がより本質的だと思ったのでこちらは2番とした。
- 9 配列の中のより小さい部分に対してクイックソートを再帰的に行っている箇所であるから。ソートの本質である「並べ替え」を表す箇所ではないと考えているため、1番ではないと考えた。
- 10 再帰を使うことは1番よりも思いつきやすいので、2番目に重要であると思いました。
#### 3位 1人
- 4  pivotを基準に分けるというのを再起的に行う部分だから。ただ引数の与え方などは比較的単純。
### 20行目
`    quick_sort(arr, cur_r + 1, right)`
#### 1位 0人
#### 2位 1人
- 5 クイックソートが再帰的な処理で、左と右にpivot以外を分けて処理しているのだということが、19行目と合わせて理解できるから。(後に登場したので、2番めに大切ということにしました)
#### 3位 1人
- 1 分割した配列について操作を行うという考え方を表しているため重要だと考えた．2番目と同等の重要度だが，便宜上3番目とした．
### 21行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
`    return arr`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`N = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`A = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`print(*quick_sort(A, 0, len(A) - 1))`
#### 1位 2人
- 3 クイックソートを含めてソートアルゴリズムが問題の本質だから。
- 7 この問題の解法では，クイックソートと呼ばれるアルゴリズムを利用するということがこの一行で分かり，アルゴリズム名が判明すると解く方針も分かりやすくなるから．
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 5 : 8 ~ 17:クイックソートの根幹部分の実装は全体に意味があり、重要だと感じます
- 7 : 2: 再起の終了条件を明示している部分だから．
- 9 : 20行目。19行目同様に、再帰的に呼び出してクイックソートを行うことを表している箇所であるため大切である。
## 自由記述
- 5 : 問題文の(配列の長さ、配列の要素の値等については特に考えなくて良い)という表現の意味があまり汲み取れなかったです
## 理解度
- とても理解できた。 : 6人, 3 4 5 6 8 11
- まあ理解できた。 : 5人, 1 2 7 9 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
