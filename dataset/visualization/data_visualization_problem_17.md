# 問題番号17
## 基本情報
- トピック : ダイクストラ法(2重ループ)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_12_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144753#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  def dijkstra(G, r):
2      dist = [float("inf") for _ in range(len(G))]
3      dist[r] = 0
4      done = [False for _ in range(len(G))]
5  
6      while True:
7          tmp_min_dist = float("inf")
8          cur = -1
9          for i in range(len(G)):
10             if (not done[i]) and (tmp_min_dist > dist[i]):
11                 tmp_min_dist = dist[i]
12                 cur = i
13 
14         if cur == -1:
15             break
16 
17         for nxt, cost in G[cur]:
18             if dist[nxt] > dist[cur] + cost:
19                 dist[nxt] = dist[cur] + cost
20 
21         done[cur] = True
22 
23     return dist
24 
25 
26 n = int(input())
27 G = [[] for _ in range(n)]
28 for i in range(n):
29     edges = list(map(int, input().split()))
30     for j in range(edges[1]):
31         G[i].append((edges[2 * j + 2], edges[2 * j + 3]))
32 
33 ans = dijkstra(G, 0)
34 for index, cost in enumerate(ans):
35     print(index, cost)
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
def dijkstra(G, r):                                        1  
    dist = [float("inf") for _ in range(len(G))]           2  ▲
    dist[r] = 0                                            3  
    done = [False for _ in range(len(G))]                  4  ▲
                                                           5  
    while True:                                            6  
        tmp_min_dist = float("inf")                        7  
        cur = -1                                           8  
        for i in range(len(G)):                            9  ▲
            if (not done[i]) and (tmp_min_dist > dist[i]): 10 ★★●●●●▲
                tmp_min_dist = dist[i]                     11 ★▲
                cur = i                                    12 ●
                                                           13 
        if cur == -1:                                      14 ▲
            break                                          15 
                                                           16 
        for nxt, cost in G[cur]:                           17 ★●
            if dist[nxt] > dist[cur] + cost:               18 ★●●▲
                dist[nxt] = dist[cur] + cost               19 ★★★●●
                                                           20 
        done[cur] = True                                   21 ★●▲▲▲
                                                           22 
    return dist                                            23 
                                                           24 
                                                           25 
n = int(input())                                           26 
G = [[] for _ in range(n)]                                 27 
for i in range(n):                                         28 
    edges = list(map(int, input().split()))                29 
    for j in range(edges[1]):                              30 
        G[i].append((edges[2 * j + 2], edges[2 * j + 3]))  31 ▲
                                                           32 
ans = dijkstra(G, 0)                                       33 ★★
for index, cost in enumerate(ans):                         34 
    print(index, cost)                                     35 
```
## 重要な理由の結果
### 1行目
`def dijkstra(G, r):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`    dist = [float("inf") for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 8 距離を十分に大きな値で初期化しておくのはダイクストラ法の実行において重要だと思ったから。あくまで初期化なので3番にした。
### 3行目
`    dist[r] = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`    done = [False for _ in range(len(G))]`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 4 更新を終えたノードを保存するリストは必要だから。ただここではリストを用意しているだけ。
### 5行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    while True:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`        tmp_min_dist = float("inf")`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`        cur = -1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`        for i in range(len(G)):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 1 全ての頂点を見ることで現在到達している頂点の中で距離が最小となるものを見つけるという考え方を最もよく表していると考え選択した．2番目の方がこの考え方をより端的に表していると考えて3番目とした．
### 10行目
`            if (not done[i]) and (tmp_min_dist > dist[i]):`
#### 1位 2人
- 5 結果的にdone[i]がFalseでありdist[i]が最小であるものをtmp_min_distとcurに代入していることが、この行をよく読まないと分からないと感じたから。
- 11 次に確定させるノードを決める時に，未確定かつ最短でいけるところを選ぶという方針がアルゴリズムにおいて大事な点だと感じました．
#### 2位 4人
- 1 全ての頂点を見ることで現在到達している頂点の中で距離が最小となるものを見つけるという考え方を最もよく表していると考え選択した．1番目のようにダイクストラ法のアルゴリズムの最重要な部分ではないと考え，2番とした．
- 4 1番の処理で使うcurを更新するのに必要な条件文だから。あくまで1番の処理のための道具。
- 7 ダイクストラ法において，次に更新していく元となる頂点は，まだ見ていない頂点でかつコストが最小である頂点であるということがこの行で分かるから．
1番でない理由は，これはダイクストラ法の具体的な中身であり，ここからアルゴリズム全体が分かるというわけではないから．
- 10 1番に気をつけた上で、現在までで最短距離を持つ未確定のノードを取り出すことが重要だと思ったため。
#### 3位 1人
- 9 次に選ぶ頂点を決める際の条件を決めている行であり、ここが動作していないと次に選ぶ頂点がわからないまま処理が終わらないことになりかねないから。実際に頂点を決めているわけではないので、あくまで2番目よりは重要度は落ちると考えている。
### 11行目
`                tmp_min_dist = dist[i]`
#### 1位 1人
- 2 ダイクストラ法のキモは、最短距離が順々に確定させるところなので、その確定した部分を見つけ出す部分が最重要であると考えた。
#### 2位 0人
#### 3位 1人
- 6 次に最短距離を確定させる頂点を選ぶにあたり、暫定距離が最小となるものを選べば良いことを表す部分。ダイクストラ法の詳細部分にあたる。
### 12行目
`                cur = i`
#### 1位 0人
#### 2位 1人
- 9 次に選ぶ頂点を決めている行であり、ここが動作していないと次に選ぶ頂点がわからないから。直接最短経路の更新をする行ではないため、あくまで1番ではないと考えている。
#### 3位 0人
### 13行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        if cur == -1:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 このダイクストラだと終了条件がないと止まらないため、ここの式は実は大事かもしれない。
### 15行目
`            break`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        for nxt, cost in G[cur]:`
#### 1位 1人
- 8 ダイクストラ法の処理の手順がよく表れているwhileループだから。
#### 2位 1人
- 5 Djikstra法の本質である、もっとも距離の近い頂点から行ける頂点を全走査する考え方が表現されているから。1番ではないと判断した理由は、Djikstra法の概要を知っていれば読解の必要がなく内容を想像できる点。
#### 3位 0人
### 18行目
`            if dist[nxt] > dist[cur] + cost:`
#### 1位 1人
- 4 あるノードまでの距離をこの条件文を使って更新する。この方法がダイクストラ法の本質だから。
#### 2位 2人
- 2 最短距離が更新できるところがあれば更新していくのはダイクストラ法でもあいかわらず重要な位置を占めていると思う。キモは上のやつだと思うので、これは2番目。
- 6 最短距離を更新する条件を示している、1 番に対して従たる部分。
#### 3位 1人
- 7 ダイクストラ法において，見つけた最小コストを持つ頂点を起点にその周りの頂点のコストを更新していくという操作のための条件がこの行で示されているから．
3番である理由は，2番での頂点を見つける操作を経た上でこの操作を行うから．
### 19行目
`                dist[nxt] = dist[cur] + cost`
#### 1位 3人
- 6 最短距離の更新を実際に行う、ダイクストラ法の根幹をなす部分。
- 9 最短経路の更新を行っている行であるから。ここが動かないと正しく動作しないため、最短経路を求めるアルゴリズムではここが最も重要と考えている。
- 10 距離を短く出来る場合は更新することが最も重要だと思いました。
#### 2位 2人
- 3 優先度つきQueも使っていないので大分苦しい実装だがしいて言えばここの比較後の遷移は大事かもしれない。
- 11 辺の重みを更新している箇所なので重要に感じました．ダイクストラならでは操作というわけではないので2番目にしました．
#### 3位 0人
### 20行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`        done[cur] = True`
#### 1位 1人
- 1 現在到達している頂点の中で距離が最も小さい頂点の距離を確定して良いというダイクストラ法の考え方の根本となる部分が記載されているため．
#### 2位 1人
- 8 一度巡回したところには戻ってこないというアルゴリズムの特徴がよく出ているから。最重要の処理ではないので2番にした。
#### 3位 3人
- 2 使用済みの距離が確定した頂点はマーキングしておかないとtmp_min_distを決める際に困るので、アルゴリズムの中心部分ではないが、これが3番目であると考えた。
- 10 1番2番に気をつけた上で、done[cur]をTrueにし忘れないようにすることが重要だと思った。
- 11 距離が確定したところを保持しておかないと次のノードが決められないから．アルゴリズムの探索手法に付随する処理感が強いため3番目です．
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`    return dist`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
`n = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
`G = [[] for _ in range(n)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`    edges = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
`    for j in range(edges[1]):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`        G[i].append((edges[2 * j + 2], edges[2 * j + 3]))`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 5 特殊な入力方法を受け取るための実装であり、上位2つの行と違って直接解法には関わらないが、読解の必要があると考えたから。
### 32行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
`ans = dijkstra(G, 0)`
#### 1位 2人
- 3 この問題のコアはダイクストラ法を使えば解くことが出来る、ということなので。
- 7 この問題の解法ではダイクストラ法を使うということが分かり，アルゴリズム名を知っている人であれば，ここからどのように解くことができるのか考えることができるから．
#### 2位 0人
#### 3位 0人
### 34行目
`for index, cost in enumerate(ans):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 35行目
`    print(index, cost)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 9 : 2行目。初期値を設定している行であり、ここを間違えると正しく動作しないから。
4行目。既に見たかどうかの配列を確保している行であり、これを行わないとプログラムが終わらないから。
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 6 8 9 11
- まあ理解できた。 : 3人, 4 7 10
- あまり理解できなかった。 : 1人, 5
- まったく理解できなかった。 : 0人, 
