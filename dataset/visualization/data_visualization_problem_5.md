# 問題番号5
## 基本情報
- トピック : 深さ優先探索(再帰実装・行きがけ/帰りがけ)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7144610#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  n = int(input())
2  G = []
3  for i in range(n):
4      edges = list(map(int, input().split()))
5      G.append([]) if edges[1] == 0 else G.append(edges[2:])
6      G[i] = [j - 1 for j in G[i]]
7  
8  d = [-1 for _ in range(n)]
9  f = [-1 for _ in range(n)]
10 time = 0
11 
12 
13 def dfs_sub(cur):
14     global time
15     d[cur] = time = time + 1
16     for nxt in G[cur]:
17         if d[nxt] != -1:
18             continue
19         dfs_sub(nxt)
20     f[cur] = time = time + 1
21 
22 
23 def dfs():
24     for i in range(n):
25         if d[i] == -1:
26             dfs_sub(i)
27 
28 
29 dfs()
30 
31 for i in range(n):
32     print(i + 1, d[i], f[i])
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
n = int(input())                                           1  
G = []                                                     2  
for i in range(n):                                         3  
    edges = list(map(int, input().split()))                4  
    G.append([]) if edges[1] == 0 else G.append(edges[2:]) 5  ●▲▲
    G[i] = [j - 1 for j in G[i]]                           6  
                                                           7  
d = [-1 for _ in range(n)]                                 8  
f = [-1 for _ in range(n)]                                 9  
time = 0                                                   10 
                                                           11 
                                                           12 
def dfs_sub(cur):                                          13 
    global time                                            14 ●
    d[cur] = time = time + 1                               15 ●●▲▲
    for nxt in G[cur]:                                     16 
        if d[nxt] != -1:                                   17 ★●▲
            continue                                       18 ★
        dfs_sub(nxt)                                       19 ★★★★★★★★●●●
    f[cur] = time = time + 1                               20 ●●●▲▲▲
                                                           21 
                                                           22 
def dfs():                                                 23 
    for i in range(n):                                     24 ▲
        if d[i] == -1:                                     25 ▲
            dfs_sub(i)                                     26 ▲
                                                           27 
                                                           28 
dfs()                                                      29 ★
                                                           30 
for i in range(n):                                         31 
    print(i + 1, d[i], f[i])                               32 
```
## 重要な理由の結果
### 1行目
`n = int(input())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
`G = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`    edges = list(map(int, input().split()))`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`    G.append([]) if edges[1] == 0 else G.append(edges[2:])`
#### 1位 0人
#### 2位 1人
- 5 DFSの問題なので再帰部分が最も大事だが、それが扱う隣接リストの構造が明確に分かる部分だから
#### 3位 2人
- 2 グラフの隣接リスト表現を配列Gに作っている部分であるから。直接問題を解く部分ではないが、グラフの扱い方の知識としては重要であると考えた。
- 8 inputのデータを加工して使いやすい形のリストにしているから。データ処理の話なので、重要度は劣ると思った。
### 6行目
`    G[i] = [j - 1 for j in G[i]]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 8行目
`d = [-1 for _ in range(n)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`f = [-1 for _ in range(n)]`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`time = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`def dfs_sub(cur):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`    global time`
#### 1位 0人
#### 2位 1人
- 2 この問題では入った・出た時刻を答える必要があり、その時刻を再帰関数を呼び出しても正しく動作するようにグローバル変数として宣言している部分であるから。
#### 3位 0人
### 15行目
`    d[cur] = time = time + 1`
#### 1位 0人
#### 2位 2人
- 4 発見時刻を表すリストを更新している部分だから。DFSの本質ではないがこの値は回答に必要。
- 6 解答となるタイムスタンプを更新している部分だから。1 番ではないのは、比較的自明だと言えるから。
#### 3位 2人
- 1 再帰関数が呼ばれた直後に操作を行うことで，ノードを訪れた直後に操作を行うことを表す部分であるため重要だと考えた．解答に直結しているものの，DFSの本質ではなく，また2番目に選んだ箇所よりも発想として容易だと考え，3番目とした．
- 9 訪れた時間帯を記録する箇所であり、結果を出力する上では大事であるが、アルゴリズムの本質部分ではないから。
### 16行目
`    for nxt in G[cur]:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`        if d[nxt] != -1:`
#### 1位 1人
- 10 訪れたことがあるノードをはとばすことが重要であると思ったから。
#### 2位 1人
- 9 深さ優先探索で、一度訪れた頂点を訪れないようにする処理が書かれており、探索が終わらないことを防止する役割があるから。ただ、探索の方法のほうが重要であると考えているため、1番大事というわけではないと考えている。
#### 3位 1人
- 11 到達したところを管理しておかないと無限におわらなくなってしまうので，大切です．
DFSする上で注意するポイントという位置付けで，DFSそのものからは外れるかなと思ったので，3番目です．
### 18行目
`            continue`
#### 1位 1人
- 8 深さ優先探索をしているということがよく読み取れる一文だから。
#### 2位 0人
#### 3位 0人
### 19行目
`        dfs_sub(nxt)`
#### 1位 8人
- 1 初めに見つけたノードから優先して探索するというDFSのアルゴリズムを端的に表す部分だと考え，最も重要とした.
- 2 DFSは再帰関数を用いて実装することが多いが、その再帰関数を呼び出している部分であるから。
- 4 dfs_subという関数を再起的に呼び出すという、深さ優先探索の本質的な処理をしているため。
- 5 自分自身を呼び出しており、再帰を利用したDFSであることが明確にわかるから
- 6 深さ優先探索の実装の特徴である、再起的呼び出しを行っている部分だから。
- 7 深さ優先探索が再帰関数で実現可能であるということがここの一行で現れているから．
- 9 深さ優先探索の方法（今いる頂点と隣り合っている頂点の再帰呼び出し）を表しており、アルゴリズムの本質部分であるため、最も重要であると考えている。
- 11 再帰にすることでDFSを実装しているので自身を呼び出すところが重要だと思いました．
#### 2位 3人
- 3 今回の問題のコアであるdfsで一番大事なのはここの再帰構造だと思うので。
- 8 1番と同じような理由だが、深さ優先探索で、１つ掘り下げるのが終わった時の処理を表していて、重要だから。1番と同じくらい重要だと思った。
- 10 再帰を使っていることも、計算量的に重要だと思ったから。使わなくても、dfsはできるので1番ほど重要でないと思った。
#### 3位 0人
### 20行目
`    f[cur] = time = time + 1`
#### 1位 0人
#### 2位 3人
- 1 再帰関数が閉じた後に操作を行うことで，隣接頂点を調べ終えた後に操作をすることを保証する部分であり，重要だと考えた．DFSの本質ではないが，発想も簡単ではないと感じるので，2番目とした．
- 7 その頂点の探索終了時間は，そこに続く頂点の探索が全て終わった後にするため，for文を抜けた後に終了時刻を記録するという間違えやすい条件がここで現れているから．
1番でない理由としては，深さ優先探索自体のアルゴリズムの実現の方が重要であると考えたから．
- 11 完了時刻を求めないといけないので，自身を呼び出した後で時間を計測している箇所を選びました．再帰がどういう操作になっているかを理解していないと，この場所に書けないと思いました．
完了時刻は必ずしも問題にならないので2番目です．
#### 3位 3人
- 4 完了時刻を表すリストを更新している部分だから。どの部分でこの処理を行うかを考えるのは比較的簡単。
- 6 解答となるタイムスタンプを更新している部分だから。実際 2 番と同程度に重要だと思う。
- 10 v  の隣接リストを調べ終えた完了時刻を記録していて、1番や2番ほどではないが、重要だと思ったため。
### 21行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
`def dfs():`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
`    for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 3 この問題特有の部分は、ただdfsを回すだけではなく一応全ての頂点についてチェックしなければいけないことだから。
### 25行目
`        if d[i] == -1:`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 5 頂点で探索を打ち切ることが伝わるため、再帰・隣接リストの構造と合わせてDFSアルゴリズムの全体を理解できるようになるから
### 26行目
`            dfs_sub(i)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 7 未発見の頂点がある場合はそこを支点に深さ優先探索を始めていくことで，全ての点を網羅することができるということがこの一行で現れているから．
3番である理由はこのことは問題文でも指摘されていることだから．
### 27行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`dfs()`
#### 1位 1人
- 3 dfsで解けるということがこの問題で一番コアな部分だと思うので。
#### 2位 0人
#### 3位 0人
### 30行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`for i in range(n):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 32行目
`    print(i + 1, d[i], f[i])`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 5 : 15,20 : 探索開始・終了時刻をどのタイミングで記録しているかがわかりやすいから
- 7 : 17: 一度現れた頂点は無視することで，ループに陥ってしまうことを防いでいる．
- 9 : 20行目。15行目同様に、訪れた時間帯を記録しているため、15行目と同じく重要である。
## 自由記述
## 理解度
- とても理解できた。 : 8人, 1 2 3 5 6 8 9 11
- まあ理解できた。 : 3人, 4 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
