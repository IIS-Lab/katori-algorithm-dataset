# 問題番号19
## 基本情報
- トピック : ラビン・カープ法(ローリングハッシュ)
- 問題リンク : https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_B&lang=ja
- 解答リンク : https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=7139684#1
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  BASE = int(1e3 + 7)
2  DIVISOR = int(1e9 + 7)
3  
4  
5  def rabin_karp(T, P):
6      res = []
7      if len(T) < len(P):
8          return res
9  
10     t_hash = 0
11     p_hash = 0
12     base_l_power = 1
13     for i in range(len(P)):
14         t_hash = (t_hash * BASE + ord(T[i])) % DIVISOR
15         p_hash = (p_hash * BASE + ord(P[i])) % DIVISOR
16         base_l_power = (base_l_power * BASE) % DIVISOR
17 
18     if t_hash == p_hash:
19         res.append(0)
20     for i in range(len(T) - len(P)):
21         t_hash = (BASE * t_hash - base_l_power * ord(T[i]) + ord(T[i + len(P)])) % DIVISOR
22         if t_hash == p_hash:
23             res.append(i + 1)
24 
25     return res
26 
27 
28 T = input()
29 P = input()
30 
31 ans = rabin_karp(T, P)
32 if len(ans):
33     print(*ans, sep="\n")
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
BASE = int(1e3 + 7)                                                                        1  ▲
DIVISOR = int(1e9 + 7)                                                                     2  
                                                                                           3  
                                                                                           4  
def rabin_karp(T, P):                                                                      5  
    res = []                                                                               6  
    if len(T) < len(P):                                                                    7  ▲▲
        return res                                                                         8  
                                                                                           9  
    t_hash = 0                                                                             10 
    p_hash = 0                                                                             11 
    base_l_power = 1                                                                       12 
    for i in range(len(P)):                                                                13 
        t_hash = (t_hash * BASE + ord(T[i])) % DIVISOR                                     14 ★★●●●●●▲
        p_hash = (p_hash * BASE + ord(P[i])) % DIVISOR                                     15 ▲▲
        base_l_power = (base_l_power * BASE) % DIVISOR                                     16 ▲▲
                                                                                           17 
    if t_hash == p_hash:                                                                   18 
        res.append(0)                                                                      19 
    for i in range(len(T) - len(P)):                                                       20 
        t_hash = (BASE * t_hash - base_l_power * ord(T[i]) + ord(T[i + len(P)])) % DIVISOR 21 ★★★★★★●●▲▲
        if t_hash == p_hash:                                                               22 ★●●●●▲
            res.append(i + 1)                                                              23 
                                                                                           24 
    return res                                                                             25 
                                                                                           26 
                                                                                           27 
T = input()                                                                                28 
P = input()                                                                                29 
                                                                                           30 
ans = rabin_karp(T, P)                                                                     31 ★★
if len(ans):                                                                               32 
    print(*ans, sep="\n")                                                                  33 
```
## 重要な理由の結果
### 1行目
`BASE = int(1e3 + 7)`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 11 基底を変数で持つと見やすくなるから．絶対に必要な工夫ではないので3番目にしました．
### 2行目
`DIVISOR = int(1e9 + 7)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 5行目
`def rabin_karp(T, P):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`    res = []`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`    if len(T) < len(P):`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 2 細かい部分なので3番目にしたが、文字列の長さで場合分けをしておかないと、13行目のハッシュの計算で配列概算症を起こして困ってしまうと思うので、これも重要。
- 5 コーナーケースの処理であり、重要だと考えた。ただしローリングハッシュとは関係ない部分なので3番めに重要だとした。ｌ
### 8行目
`        return res`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 10行目
`    t_hash = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
`    p_hash = 0`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
`    base_l_power = 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`    for i in range(len(P)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 14行目
`        t_hash = (t_hash * BASE + ord(T[i])) % DIVISOR`
#### 1位 2人
- 8 ラビンカープ法で、ローリングハッシュを使うというのは肝の部分だから。
- 11 文字列のハッシュをとることで同じ文字列かを比べるアルゴリズムの核だと感じたから．
#### 2位 5人
- 3 15行目と合わせて、ラビン-カープ、というかローリングハッシュにも共通でハッシュ値をMODで求めて照合に使えることが重要だから。
- 5 15行目とともに、ハッシュの具体的な計算方法がわかりやすく重要だと考えた。ただし、21行目とほぼ同じ処理であるため、1番ではないと考えた 。
- 6 t のハッシュ値の初期値を定義に従って計算する部分だから。1 番ほど非自明ではない。
- 9 ハッシュの値の初期値を設定する箇所であるから。計算量を落とす核心の部分ではないため、1番ではないと考えている。
- 10 1番ほどの工夫ではないが、t_hashとp_hashを計算することが2番目に重要であると思った。
#### 3位 1人
- 4 ハッシュ値を求めることはラビンカープ法において重要だから。最初のハッシュ値を単純な方法で求めているだけだから。
### 15行目
`        p_hash = (p_hash * BASE + ord(P[i])) % DIVISOR`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 6 p のハッシュ値を定義に従って計算する部分だから。2 番のように初期値計算の意味合いがない。
- 7 ハッシュをどのように計算するのか，ハッシュの定義がここで分かるから．
3番目である理由は，2番目で挙げた，ハッシュを比較するという考え方の前提があった上でどのようにハッシュを計算するのかという考えの流れになると思ったから．
### 16行目
`        base_l_power = (base_l_power * BASE) % DIVISOR`
#### 1位 0人
#### 2位 0人
#### 3位 2人
- 1 今後ハッシュの計算に利用する変数をあらかじめ計算しており実装の工夫として大切だと考えたため．アルゴリズムの核というよりは実装の工夫にあたると考え3番目に選択した．
- 10 1番2番に気をつけた上で、base_l_powerも剰余を取りながら、更新することが3番目に重要であると思った。
### 17行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
`    if t_hash == p_hash:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
`        res.append(0)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`    for i in range(len(T) - len(P)):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`        t_hash = (BASE * t_hash - base_l_power * ord(T[i]) + ord(T[i + len(P)])) % DIVISOR`
#### 1位 6人
- 1 ハッシュの更新式を表しており，このように前のハッシュを利用して簡単に次のハッシュを計算できることがこのアルゴリズムを成り立たせていると考えたため．
- 4 文字列のハッシュ値を効率的に更新するという複雑な処理を行なっているから。
- 5 ローリングハッシュの基本的な式であり、最も本質的だと考えた。
- 6 T の部分文字列の Rolling Hash の値が、前の値からの差分でどのように得られるかを示している。
- 9 ハッシュの更新を行う箇所であり、ここの更新がローリングハッシュで計算量を落とせる本質の箇所であるから。
- 10 しゃくとり法的な考えを用いており、最も重要であると考えたため。
#### 2位 2人
- 2 文字列tのスタート地点をずらしたときのハッシュ値が高速に計算できることはアルゴリズムが高速に動くことにとてもよく貢献していると考える。ハッシュが文字列の一致判定に使えるというアイデアの方が中心であると感じたので、こっちが2番目。
- 11 見る文字列をスライドしていくたびに，ハッシュの更新をしている箇所だから．
#### 3位 2人
- 3 本来文字列の長さ分だけ計算が必要なハッシュ値計算をこのDPを使うことで計算量を圧縮できているから。
- 8 1番と同じく、ローリングハッシュの計算をしているところだから。内容的に重複しているので3番とした。
### 22行目
`        if t_hash == p_hash:`
#### 1位 1人
- 2 ローリングハッシュは、それぞれの文字列に対してハッシュ値を計算してそれが一致していれば文字列が一致していると判定するアルゴリズムなので、一致判定をしている行が最重要だと考えた。
#### 2位 4人
- 1 ハッシュ値の一致を用いて文字列を照合するという発想を表しており重要だと考え選択した．ハッシュの計算が高速に行えるという点の方が重要だと考え，2番目とした．
- 4 文字列の一致をハッシュ値によって確認するというのはラビンカープ法の本質だから。ただ、処理としては一致を確認しているだけ。
- 7 文字列をハッシュにして，それが等しいかどうかを比較することで文字列の探索を行うということがこの行から分かるから．
1番でない理由は，この行だけではどのようにハッシュを形成するかなど全体的なアルゴリズムを把握することができないため．
- 8 ハッシュが一致していたら文字列が一致しているとみなす、というのは問題を解く上で大切だから。ハッシュの定義の方が大事なので2番とした。
#### 3位 1人
- 9 文字列の照合条件を、ハッシュの照合条件とみなして判定する箇所であるから。ハッシュの計算箇所ではないため、重要度は下がると考えている。
### 23行目
`            res.append(i + 1)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`    return res`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 26行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 27行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 28行目
`T = input()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 29行目
`P = input()`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 30行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 31行目
`ans = rabin_karp(T, P)`
#### 1位 2人
- 3 この問題のコアはラビン-カープ法、を使えば文字列の照合そのものがO(1)かつ前計算も（この問題では前計算そのものをループ憎んでいるが）線形に出来ることなので。
- 7 この問題ではラビンカープ文字列探索アルゴリズムを用いるということがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．
#### 2位 0人
#### 3位 0人
### 32行目
`if len(ans):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 33行目
`    print(*ans, sep="\n")`
#### 1位 0人
#### 2位 0人
#### 3位 0人
## 他の重要部分
- 3 : 15
- 7 : 21: どのように効率的に部分文字列のハッシュを計算するのかがこの行から分かるから．
## 自由記述
## 理解度
- とても理解できた。 : 6人, 1 2 3 5 6 9
- まあ理解できた。 : 5人, 4 7 8 10 11
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
