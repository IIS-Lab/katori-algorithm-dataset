# 問題番号9
## 基本情報
- トピック : 二項係数+繰り返し自乗法(mod)+階乗計算
- 問題リンク : https://atcoder.jp/contests/abc034/tasks/abc034_c
- 解答リンク : https://atcoder.jp/contests/abc034/submissions/36923609
- 解答人数 : 11
- 解答者ID : 1 2 3 4 5 6 7 8 9 10 11
## ソースコード
```py
1  MOD = int(1e9 + 7)
2  
3  
4  def power_mod(a, p):
5      if p == 0:
6          return 1
7      tmp = power_mod(a * a % MOD, p // 2)
8      if p % 2:
9          tmp = tmp * a % MOD
10     return tmp
11 
12 
13 def factorial(n):
14     res = 1
15     for i in range(1, n + 1):
16         res = (res * i) % MOD
17     return res
18 
19 
20 def combination(n, k):
21     return factorial(n) * power_mod(factorial(n - k), MOD - 2) * power_mod(factorial(k), MOD - 2) % MOD
22 
23 
24 W, H = map(int, input().split())
25 print(combination(W + H - 2, W - 1))
```
## 重要度の結果
★: 1st, ●: 2nd, ▲: 3rd
```py
MOD = int(1e9 + 7)                                                                                      1  
                                                                                                        2  
                                                                                                        3  
def power_mod(a, p):                                                                                    4  ●
    if p == 0:                                                                                          5  
        return 1                                                                                        6  
    tmp = power_mod(a * a % MOD, p // 2)                                                                7  ●●●●●▲▲▲▲▲
    if p % 2:                                                                                           8  
        tmp = tmp * a % MOD                                                                             9  ▲
    return tmp                                                                                          10 
                                                                                                        11 
                                                                                                        12 
def factorial(n):                                                                                       13 ▲
    res = 1                                                                                             14 
    for i in range(1, n + 1):                                                                           15 
        res = (res * i) % MOD                                                                           16 
    return res                                                                                          17 
                                                                                                        18 
                                                                                                        19 
def combination(n, k):                                                                                  20 
    return factorial(n) * power_mod(factorial(n - k), MOD - 2) * power_mod(factorial(k), MOD - 2) % MOD 21 ★★★★★★★●●●●
                                                                                                        22 
                                                                                                        23 
W, H = map(int, input().split())                                                                        24 
print(combination(W + H - 2, W - 1))                                                                    25 ★★★★●▲▲▲▲
```
## 重要な理由の結果
### 1行目
`MOD = int(1e9 + 7)`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 2行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 3行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 4行目
`def power_mod(a, p):`
#### 1位 0人
#### 2位 1人
- 2 二項係数を計算するには逆元を計算する必要があるが、そのためにはp-2乗を計算する必要があるので、powを計算する関数は次いで重要であると考えた。
#### 3位 0人
### 5行目
`    if p == 0:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 6行目
`        return 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 7行目
`    tmp = power_mod(a * a % MOD, p // 2)`
#### 1位 0人
#### 2位 5人
- 1 冪乗を求めるための繰り返し二乗法の考え方を端的に表している部分であるため選択した．一方で計算の最も難しい部分である1番目よりは重要ではないと考えた．
- 8 累乗の計算で、再帰を使うことで計算量を抑えるというのは重要だから。MODに比べると基本的なことだと思ったので2番とした。
- 9 繰り返し二乗法を用いて累乗を高速に計算する処理において、nを半分ずつにしていくことで高速な計算を実現していることを表している箇所であるから。問題の本質的な箇所というのではないため、1番ではないと考えた。
- 10 剰余を取りながら計算することも、1番ほどではないが、とても重要だと思ったため。
- 11 繰り返し自乗法の要だと思ったからです．この問題の条件がゆるゆるであれば必要なくなるので2番目にしました．
#### 3位 5人
- 3 9行目と合わせてn乗を求める時に繰り返し2乗法を用いると効率的に求められることが大事だから。
- 4 power_modを適切に計算するために再起処理を行なっているため。power_modは大事だが、このプログラムの中では道具の1つ。
- 5 combination関数ではfactorial,power_modの２種類の関数を呼び出しているが、factorial関数はMODを用いていること以外は自然な実装であるのに対し、power_modは繰り返し二乗法を用いており、理解が必要であるため、３番目に重要な部分だと考えた。
- 6 再帰を用いた繰り返し二乗法を端的に示す行だから。単に計算量削減のために必要なものなので、1 番や 2 番ではない。
- 7 累乗の計算が2の累乗に注目することでより計算コストを抑えられるということがしめされているから．
3番である理由は，この行の処理は1番2番で挙げた箇所に関する計算をさらに計算コストを下げるために行なっているものであるため．
### 8行目
`    if p % 2:`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 9行目
`        tmp = tmp * a % MOD`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 9 繰り返し二乗法を用いて累乗を高速に計算する処理において、nが奇数のときに行う処理を表しているため。この処理はnが偶数のときには出てこないこともあり、1番目や2番目にはならないと考えた。
### 10行目
`    return tmp`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 11行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 12行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 13行目
`def factorial(n):`
#### 1位 0人
#### 2位 0人
#### 3位 1人
- 11 繰り返しつかうfactorialを切り出して関数にもっておくのは大事だと思います．この問題特有の話ではないので3番目です．
### 14行目
`    res = 1`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 15行目
`    for i in range(1, n + 1):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 16行目
`        res = (res * i) % MOD`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 17行目
`    return res`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 18行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 19行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 20行目
`def combination(n, k):`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 21行目
`    return factorial(n) * power_mod(factorial(n - k), MOD - 2) * power_mod(factorial(k), MOD - 2) % MOD`
#### 1位 7人
- 1 割り算の結果の剰余を求める際には逆元を用いることが必要であるという最も注意すべき点に対応しているため．また，冪乗を求めるために繰り返し二乗法を用いることも示されている．
- 2 二項係数をもとめる必要がある問題だが、その二項係数の計算をしている部分であり、最重要であると考える。
- 4 
power_mod()を適切に利用して組み合わせの計算をしているため。与える引数も複雑で考える必要がある。
- 8 大きい数字なのでmodをとりながら計算していく、というプログラミングならではの処理方法だから。
- 9 この問題の本質は経路数を二項係数を用いてどのように計算するかというところにあり、逆元を用いた二項係数の計算を行っているこの箇所が、まさしく本質的な箇所であるといえるから。
- 10 コンビネーションのfactorial(n) * power_mod(factorial(n - k), MOD - 2) * power_mod(factorial(k), MOD - 2) % MODとすることは、逆元の考えなどを用いており、重要だと思った。
- 11 modにおいて割り算をするときにmod-2乗と同等という知識は大事かなと思います．
#### 2位 4人
- 3 modをとるcombinationの効率的な計算は階乗をつかうことや、階乗の逆元がフェルマーの小定理で求められることが重要だから。
- 5 Combination関数の実装の本体であり、nCrの求め方を知るための重要なコードであるため、nCrを使う事自体の次に重要だと考えた。
- 6 combination を定義した部分だから。また、逆元計算の方法が含まれている。問題固有の考察は含まれないので、1 番ではない。
- 7 modありのコンビネーションの計算では，逆元を使うと計算量を抑えてできるということがわかるから．
1番である理由は，これは計算の工夫であり，問題の解法自体とは直接関わることではないため．
#### 3位 0人
### 22行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 23行目
``
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 24行目
`W, H = map(int, input().split())`
#### 1位 0人
#### 2位 0人
#### 3位 0人
### 25行目
`print(combination(W + H - 2, W - 1))`
#### 1位 4人
- 3 この問題で一番コアなのは答えをcombination一発で求められることに気付くことだから。
- 5 そもそも、この経路パターン数の問題をnCrの形式に落とし込めること自体ある程度の発想と数学力が必要であるため、combination関数を呼び出している部分がもっとも重要であると考えた。
- 6 combination というよく知られた関数を用いて問題の解答を端的に記述しているから。
- 7 この問題はコンビネーションによって解くことができるということがこの一行でわかるから．
#### 2位 1人
- 4 答えを求めるためにcombination()に適切な引数を与えている部分だから。引数を決めているだけで本質的な処理の部分ではない。
#### 3位 4人
- 1 この問題の答えである場合の数を求めている部分であるため選択した．アルゴリズムとしての工夫が凝縮されている1番目，2番目の部分ほど重要ではないと考えた
- 2 問題の答えがdp等での数え上げではなく、二項係数で表すことができることを表しており、アルゴリズムの本質部分ほどではないが、問題を解く上では重要な観察が含まれていると考えた。
- 8 そもそもこの計算方法で答えが求められることを知らないとこうは書けないから。数学の知識なので3番とした。
- 10 シンプルに組み合わせの数を使って、経路数を求めるという考えもコードは1,2番よりシンプルであるが重要だと思ったため。
## 他の重要部分
- 5 : 8,9: 繰り返し二乗法における実際の計算を担っている部分であるため、再帰の部分の次に大切であると考えた。
- 9 : 16行目。二項係数の計算に用いられる階乗の計算の処理を行っている行であるから。
25行目。今回の問題における経路数の式を表しており、ここを間違えると答えが合わないから。
## 自由記述
## 理解度
- とても理解できた。 : 7人, 1 2 3 6 8 9 11
- まあ理解できた。 : 4人, 4 5 7 10
- あまり理解できなかった。 : 0人, 
- まったく理解できなかった。 : 0人, 
