time,personID,problemID,1st,1st_reason,1st_label_katori,1st_label_yamamoto,1st_check,2nd,2nd_reason,2nd_label_katori,2nd_label_yamamoto,2nd_check,3rd,3rd_reason,3rd_label_katori,3rd_label_yamamoto,3rd_check,others,understanding,free
12/8/2022 20:53:06,1,1,8,尺取法において重要な，条件を満たす限り区間の右端を進めるという操作が書かれているため．,10,10,,7,尺取法において重要な，条件を満たさなくなったら限り区間の左端を進めるという操作が書かれているため．区間の右端の操作の方が難しいと考えたため2番とした．,10,10,,2,尺取法の本質部分からは外れるため1番や2番ではないが，問題の性質に起因するコーナーケースを除去する重要な部分であるため．,3,3,,,とても理解できた。,
12/10/2022 23:35:03,3,1,8,尺取り法は特定の連続部分列に対する処理を全探索ではなく、左端と右端を上手くずらすことでO(N)に抑えるアルゴリズムだが、7行目と合わせてコアの部分だから。,4,4,,7,8行目と合わせて尺取り法のコアの部分だが、問題特有の処理はないから。,13,13,,2,要素に0が含まれている時の例外処理はこの問題固有のものだから。,3,3,,,とても理解できた。,
12/13/2022 20:49:40,7,1,8,配列の右側に関してこの行の条件をつけながら探索していくことで，正解を導き出すことができるから．,10,10,,2,"配列に0が含まれている場合をあらかじめ抜いておくことで，例外なパターンを排除でき，メインとなるアルゴリズムを実装できるから．
一番ではない理由としては，これは0を含むという例外的なパターンのみにしか対応せず，基本的なアルゴリズムとは関連が薄いから．",3,3,,15,"rightをleftのたびに更新せず，前回のループで計算したものをそのまま利用することで計算量を落とすことが可能となっているから．
1番や2番ではないのは，これは計算量を減らすためであり，この処理がなく，全て計算を行なっても答え自体は導き出せるから．",4,4,,12: この条件式があることでバグがなくアルゴリズムを実行できるから．,まあ理解できた。,
12/14/2022 5:06:56,8,1,8,rightをひとつずつインクリメントしながらギリギリのところを確かめるという、問題を解く最も本質的なところだと思ったから。,8,8,,2,１つでも０が含まれていたら計算するまでもないという例外処理を行なっているから。あくまで例外処理なので２番とした。,3,3,,15,左側を右にずらすときの大事な計算だから。8行目の方が本質的だと思ったので３番とした。,12,12,,,とても理解できた。,
12/14/2022 13:39:27,6,1,8,尺取法において、区間を伸ばし続ける条件を記述する行になっているから。,8,8,,10,尺取法の一部である、区間を伸ばすという処理を行っているから。1 番でないと考えたのは、問題によって変わる部分ではないから。,10,10,,7,尺取法の一部である、区間をずらすという処理を行っているから。1 番や 2 番でないと考えたのは、問題によって変わる部分でなく、区間を伸ばす処理に対する従たる処理だから。,10,14,×,11。最終的に欲しい解答を計算している部分だから。,とても理解できた。,
12/15/2022 10:52:01,2,1,8,この問題はしゃくとり法を用いて解くことができるが、そのしゃくとり法の繰り返しを行なっている部分であるから。,10,10,,12,同じくしゃくとり法のインデックスに関する部分で正しく場合分けしないといけないため重要であると考えられるが、複雑さでいえば8行目より少ないから。,8,8,,2,配列に0があるときのみコーナーケースとして処理する必要があり、大枠としては関係ないが、問題を解く上では必要である処理だから。,3,3,,,とても理解できた。,
12/15/2022 12:59:30,4,1,8,arrを順番に見ていく上で最も重要な判別を行なっていると思うから,8,8,,15,前回のsumを利用することで効率化に貢献しているため。ただこの効率化がなくても問題に正解はできる。,4,4,,11,最終的な答えを更新している部分であるため。ただ誰でも簡単に思いつきそう。,9,9,,"2, 0の掛け算に対する処理を意外と忘れてしまいそうな気がするから",とても理解できた。,
12/15/2022 18:51:04,9,1,8,尺取り法における、範囲を伸ばせる条件を指定しており、この部分の判定が正しいかどうかが、アルゴリズムが正しく動くための核であると考えたから。,8,8,,11,答えの値の更新を行っており、これが無いとアルゴリズムが正しい答えを返さないから。ただし、この部分はアルゴリズムの核とは言えないため、1番ではないと考える。,9,9,,2,配列の値の中に0があった場合というコーナーケースに対する例外処理を行っており、これがないとコーナーケースに対して正しい値を返さないから。ただし、この部分はメインのアルゴリズム部分ではないため、重要度は先ほどの2つに比べると落ちると考える。,3,3,,12行目。細かいところではあるが、尺取り法における左のポインタと右のポインタが等しい値を指したときの処理を行っており、アルゴリズムを実装する上では大事な要素となる。,とても理解できた。,
12/28/2022 12:33:41,5,1,8,「条件を満たすように範囲を広げる」という、尺取り法を用いた解法を端的に表しているから,10,10,,7,8行目に右端を動かしていることのほうが本質的だが、左端を走査していることも本質的だから。,10,10,,2,簡単にコーナーケースを処理できており大切だが、なくても解けること・尺取り法と関係ないため１番ではないと思った,3,3,,11行：走査しながらのresの逐次更新は競プロなどでよく使う表現だから,とても理解できた。,
12/30/2022 16:27:34,10,1,8,累積がxの値を超えるまで右端を動かしていくことは、とても重要であるから。,10,10,,15,左端を動かすときに、最左端の値で割り忘れないことは重要であるから。1番ではないのは、プログラムを動かすときに気付きやすいと思ったため。,3,3,,12,左端右端が被った時の処理も大切であると思ったため。1番や2番ではない理由は、デバッグで気付きやすいと思ったため。,14,14,,,まあ理解できた。,
1/2/2023 21:45:05,11,1,8,指定された条件を満たす限り，列の中においてみる範囲を増やしていくという方針が表れている箇所だと思ったから,10,10,,2,選択した範囲の積に注目しており，積の特性である一つでも0であれば0になることに気づいているから．基本方針ではないので一番に選びませんでした．,14,14,,12,列の範囲を拡大していく中でこの処理をする必要がある．毎回ではなく，列の長さが0のときだけの処理なので3番目にしました．,3,3,,,とても理解できた。,
12/8/2022 21:07:35,1,2,29,現在見ている区間を再帰的に分割することで区間和を求めるというセグメント木の本質部分だと考えたため．,12,12,,26,現在見ている区間が求めたい区間に含まれている場合はその区間和を返すという部分であり，区間和を再帰的に求める上で重要な操作だと考えた．区間の分割の方がより本質的と考え，2番とした．,12,12,,20,子区間から親区間に遡って区間和を求めるという操作であり，セグメント木を成り立たせるための初期化として重要だと考えた．求めたい区間和を複数の区間に分割する操作に比べれば本質的でないと考え，3番目とした．,6,6,,,まあ理解できた。,
12/10/2022 23:41:21,3,2,37,RSQはセグ木を使えば計算量的に効率よく解けることに気付ければ後はセグ木を作れるorとってこれるかだけなので。,2,2,,21,一応セグ木というデータ構造における重要なのは更新式をこの式で再帰的に（ここではwhile文だが）行えることだから。,9,9,,29,一応セグ木というデータ構造における重要なのはクエリをこの式で再帰的に（ここではwhile文だが）行えることだから。,5,5,,,まあ理解できた。,
12/13/2022 21:01:11,7,2,37,この問題の回答ではセグメントツリーと呼ばれるアルゴリズムを用いるということが明示されており，これを思いつけるかどうかが問題を解く鍵だと思うから．,2,2,,14,"セグメントツリーの基本的な構造が分かり，この構造からどのように問題を解くのかを考えることができるから．
1番でない理由としては，「セグメントツリー」というアルゴリズム名があったほうが問題の全体的な解き方を把握しやすいから．",2,2,,29,"セグメントツリーでどのように特定の範囲の和を取得するのかということについて，再帰で和を取得するということがこの行でわかるから．
3番である理由としては，この部分だけではどのように値の更新などを行うかといったことについては分からず，問題の解き方に直結していないから．",5,5,,,まあ理解できた。,
12/14/2022 13:48:48,6,2,29,セグメントツリーにおいて最も複雑な、区間和を再帰的に計算する部分だから。,12,12,,21,セグメントツリーにおける更新部分の根幹となる行だから。1 番でないのは、区間和計算ほど複雑ではないから。,9,9,,17,うっかり忘れそうな処理だから。1 番や 2 番と比べると、瑣末な番号合わせだと言える。,3,3,,,とても理解できた。,
12/15/2022 11:00:22,2,2,29,問題のクエリに答える部分である、区間和を求める計算のメインがこの部分であるから。,12,12,,21,問題に答える部分ではないが、問題の指示として出てくる配列の一点更新を行う計算のメインがこの部分であるから。,12,12,,14,問題を答えるわけでもなく、問題の指示として陽に出ているわけでもないが、これからの計算をするうえでの準備をしている行であるから。,13,13,,,まあ理解できた。,
12/15/2022 19:24:06,9,2,29,セグメント木における一番大事な要素は、区間和の計算方法であり、中でも左半分の区間の結果と右半分の区間の結果をマージすることを再帰的に繰り返すことで出来る、ということが最も大事な要素と考えている。29行目はまさしくこのことを表している行であるから。,5,5,,27,区間和の計算において、今見ている区間が求めるべき区間にすべて含まれる場合は今見ている区間の結果をそのまま返す、ということが計算量削減のために重要であるから。ただし、このことは左半分の結果と右半分の結果をマージする、ということが前提となっているため、あくまで1番ではないという立ち位置でいる。,4,4,,21,セグメント木においては一点更新の仕方が区間和の処理の仕方の次に重要なポイントであると考えており、21行目はまさしく一点更新の仕方を言い表しているから。,9,9,,3～6行目。セグメント木のサイズを2のべき乗にするという処理を行っている行であるため。,とても理解できた。,
12/17/2022 21:36:45,8,2,7,問題を解くためにセグメント木というデータ構造を使う、というのがよく表れているから。,2,2,,21,セグメント木を作るための計算をしているところだから。セグメント木を使う、というアイデアの方が重要だと思ったので2番とした。,12,12,,29,部分和を求めるために再帰を用いるというのが重要だと思った。木を作る方が大切だと思ったので3番とした。,5,5,,,まあ理解できた。,
12/20/2022 23:47:18,4,2,29,セグメント木の性質を利用して再起的にgetSumを求める関数を呼び出している部分だから。,5,5,,21,セグメント木を更新している部分だから。ただそれほど複雑な処理ではないため。,9,9,,1,まずこの問題をセグメント木を使って解こうとする発想が重要だから。ただ重要な処理をしている訳ではない。,2,2,,,とても理解できた。,
12/28/2022 12:52:42,5,2,37,SegmentTreeの典型問題であるため、「SegmentTree」という表記が登場し、セグ木を使用することが最もわかりやすい37行目を選んだ。,2,2,,42,セグ木の一点更新クエリの仕様について、どのように入力すればよいかがわかりやすいから,1,1,,44,セグ木の区間加算クエリの仕様について、どのように入力すればよいかがわかりやすいから。関数名が直感的であるため区間加算よりは重要度が低いと考えた。,1,1,,,まあ理解できた。,"回答とは関係ないのですが、ans01,02のようにしていただけると辞書順になるのでソートが楽になるため、次回以降同様の実験をされる際は変更していただけると嬉しいなと思いました"
12/30/2022 16:48:57,10,2,29,セグメント木の性質や再帰を使っているところが非常に重要だと思いました。,5,5,,21,addもセグメント木の性質を使っていて、重要だと思いました。1番ではないのは、29行目の方が難しいと思ったため。,13,13,,24,cur_r <= x or y <= cur_lのような場合分けは、忘れやすいと感じたため。1番2番ほど難しくはないのかなと思ったため。,3,3,,,まあ理解できた。,
1/2/2023 22:11:58,11,2,7,問題設定よりセグ木を使うことことで解答可能だと判断できる．セグ木のデータ構造を作成している行だから．,2,2,,21,ツリー上で列の和を管理するデータ構造の要となる処理をしているところだと考えました．,14,14,,29,合計の値を取得する操作をしている箇所で，これも2番目に選んだ箇所と同様，データ構造特有の操作であるから．2番目と同列に考えています．2番目が一つしか選べなかったので3番目になりました．,14,14,,,とても理解できた。,
12/8/2022 21:19:11,1,3,5,"
各要素について出現回数を記録するという計数ソートのアルゴリズムの発想を端的に表した一行だと考えたため．1番目とした．",9,9,,11,各要素の出現回数に応じてソートされる配列を更新する部分であり，計数ソートの核となる発想であると考えたが，5行目のカウンターの初期化部分の方がより本質的と考え，2番目とした．,9,9,,13,各要素の出現回数に応じてソートされる配列のインデックスを適切に設定する部分であり，アルゴリズムの本質ではないが，ミスが起こりやすい部分だと考えたため3番とした．,3,3,,,とても理解できた。,
12/10/2022 23:49:48,3,3,12,バケツソートでどこが重要かは難しいところだがしいて言えば計数後に順番に配列をつくるところ、かもしれないから。,9,9,,13,数後に順番に配列をつくるところでまあインデックス管理も重要かな、と思ったから。,9,14,×,7,計数しているところもしいて言えば重要かもしれないと思ったから。,12,12,,,とても理解できた。,
12/13/2022 21:26:16,7,3,12,返す配列のindexを持ち，indexをインクリメントしながら最終的な配列を更新していくことで，問題文の疑似コード部分の「C[i] に i 以下の数の出現数を記録する」操作が必要ないということが分かるから．,9,9,,11,"配列の要素を一回一回書き換えるのではなく，for文であらかじめ決められた回数繰り返して同じ数を代入すればよいということが分かる．
1番でない理由としては，indexという変数をつかっているおかげで実現できるから．",9,9,,7,"問題文の疑似コードでの「 C[i] に i の出現数を記録する 」という操作を実行している部分にあたるから．
3番である理由は，ほとんど疑似コード通りであることから．",9,9,,,まあ理解できた。,
12/14/2022 13:55:02,6,3,10,度数分布表を左から見る、というのが計数ソートにおけるソートの部分だから。,10,10,,7,計数ソートに必要な度数分布表を計算する根幹の部分だから。1 番ではないのは、あくまで前処理の意味合いが強いから。,12,12,,11,出現回数分だけソート結果に入ることを表す行だから。1 番や 2 番と比べると、ソートという文脈からは遠いと言える。,9,13,×,,とても理解できた。,
12/15/2022 11:09:03,2,3,10,計数ソートの重要なアイデアとして、同じ数字をまとめて処理する、という部分があり、そのまとまて処理している部分であるから。,14,14,,7,計数ソートというアルゴリズムの通り、数を数えて行うソートだが、その計数の部分を行っている行であるから。,12,12,,12,複雑ではないが、計数ソートの答えを求めている部分であるから。,14,14,,,とても理解できた。,
12/15/2022 20:01:50,9,3,7,計数ソートのエッセンスは、「何の要素が何個ある」という配列を組み立てる部分だと考えており、7行目はそれを言い表したものだと言えるから。,14,14,,12,12行目の処理は配列に計数ソートの結果を小さい順に並べる部分の処理であり、この処理は結果を正しく返す上では大事であるから。アルゴリズムの中心の部分ではないため、この部分は2番目に重要である。,14,14,,13,インデックスを1ずつ進める箇所も、アルゴリズムを正しく動作させるという処理の一部分では重要であるから。あくまでアルゴリズムの本質の部分ではなく、処理の一部分にすぎないため、この部分は3番目に重要であると考えている。,10,14,×,,とても理解できた。,どこが大事な箇所なのかは比較的早い段階で思いつくのですが、その中での順位付けをするのが大変だと感じます。
12/17/2022 21:43:15,8,3,12,計数ソートを昇順で作成する際に、その配列を１つずつ埋めていくという最も本質的な処理だから。,9,9,,13,上と同じような理由だが、インデックスを進めていかないと正しく配列が作成できないから。計数ソートの本質は12行目の方だと思ったので2番にした,10,14,×,7,計数ソートを作るために、登場する数字をカウントするという大事なところだから。簡単なので3番とした。,12,12,,,とても理解できた。,
12/21/2022 11:16:37,4,3,11,countリストを順番に見ていくという操作がこのソーティングアルゴリズムの本質だから。,10,10,,12,答えを表すリストに何を詰めるのかを決めている部分だから。ただ処理としては単純。,9,14,×,7,このソーティングアルゴリズムで重要になるcountリストの中身を決めているため。ただ数え上げているだけではある。,12,12,,,とても理解できた。,
12/28/2022 12:59:36,5,3,5,計数ソートの根本的な考え方である、巨大な配列を用意している部分だから,6,6,,7,計数ソートで実際にどのように配列を更新しているかがわかりやすいから,9,9,,11,バケットに格納された数だけarrayにpushするという考え方が現れているから,11,11,,10:計数ソートの計算量がO(n+k)であることを表している行だと思うから,とても理解できた。,
12/30/2022 17:00:00,10,3,12,結果となる配列に値を代入している行で、計数ソートを一番よく表している行だと思ったため。,9,9,,7,count[i] に i の出現数を記録して、カウンタ配列を作ることは1番ほど難しくないが、重要だと思ったため。,9,9,,11,"出現回数分繰り返すことは、1,2番ほど難しくないが重要だと思ったため。",10,10,,,まあ理解できた。,
1/2/2023 22:48:08,11,3,5,ありえる要素の値がインデックスとなった計数のための場所をあらかじめ確保しておくことがこのソートの要だと考えたから,6,6,,12,要素の値が小さいほうからソートした配列が格納されるリストにいれている行だから．計数しているところではないので2番目にしました．,13,13,,9,インデックスを動かしていく変数をもつのもコードのわかりやすさのために大事かなと思いました．別の書き方もでき，計数ソートの本質ではないので，3番目になりました．,1,1,,,とても理解できた。,
12/8/2022 21:29:43,1,4,19,二分探索木の構築において，ある要素Aの左部分木の要素は全てAより小さいという制約を表現しており，24行目も同様に導かれるため，最も重要だと考えた．,14,14,,32,中間順巡回のアルゴリズムを表す上で重要だと考え選択した．木の構築の方が本質的であることから2番目とした．,13,13,,38,行きがけ順のアルゴリズムを表す上で重要だと考え選択した．木の構築の方が本質的であること，行きがけ順ではソートされた列が選ばれないことから2番目とした．,13,13,,,とても理解できた。,
12/11/2022 0:34:39,3,4,18,この問題のコアは二分探索木というデータ構造そのものだと思うのですが、二分探索木で一番大事なのはまあここのwhileだけでinsert or  検索位置がわかることかなと思ったからです。,13,13,,30,問題に効率よくこたえるためには不可欠なメソッドだから。逆に言えばコアな部分ではない。,4,4,,36,問題に効率よくこたえるためには不可欠なメソッドだから。逆に言えばコアな部分ではない。,4,4,,,とても理解できた。,
12/13/2022 21:34:08,7,4,32,中間順巡回においては先に各ノードより左に位置するノードを見るということが重要であり，それがここで現れているから．,10,10,,38,"先行順巡回では先に自分自身のノードを見てからその子のノードへと移っていくことがこの行で現れているから．
1番でない理由は，中間順巡回に比べてこちらの方が直感的だと思ったから．",10,10,,12,"疑似コードで触れられている二分木のinsertを実際に実装している部分だから．
3番である理由は，この問題では中間順巡回，先行順巡回でのノードの巡り方のアルゴリズムの違いが問われており，ここは本質ではないと思ったから．",13,13,,,まあ理解できた。,
12/14/2022 14:07:06,6,4,33,出力がこの位置にあることで in order トラバーサルとなっているから。,14,14,,38,出力がこの位置にあることで pre order トラバーサルとなっているから。重要度は 1 番と大して変わらないが、こちらの方が若干自明な気もする。,14,14,,21,二分探索木構築において最も重要な、新たなノードを生成している部分だから。1 番や 2 番ではないのは、これは二分探索木における一般的な処理であり、本問はトラバーサルの部分の方を問われているから。,11,11,,26。21 行目と同様に重要,とても理解できた。,
12/15/2022 11:14:47,2,4,19,データ構造の重要な部分であるinsertにおいて、値が現在のノードより小さいときは左に入れる、という処理を行なっている部分であるから。,11,11,,24,データ構造の重要な部分であるinsertにおいて、値が現在のノードより大きいときは右に入れる、という処理を行なっている部分であるから。19行目より後に出てきているので、こちらを2番にした。,11,11,,14,insertする本質とは関係ないが、実際にはこれがないと一番最初にエラーが起きてしまうので、そのコーナーケースを処理する部分として重要であると考える。,3,3,,,まあ理解できた。,
12/15/2022 20:46:05,9,4,19,いま見ているノードよりも値が小さいときには左のノードに進むことを表す処理を表す箇所であり、二分探索木の作り方を分岐によって表現する点で重要であると考えている。,10,8,×,21,二分探索木に値をセットするところであり、左のノードに進んだときに値が存在しなければそこに置く、という処理を表す箇所であり、二分探索木の進む方向を決めた後の処理を表現している点で、進む方向を決める処理の次に重要であると考えている。,9,9,,32,二分探索木の巡回を、再帰によって行うことを表しているから。この問題では二分探索木の構成が本質であると考えているため、先述の2つよりは重要度は低いと考えている。,5,5,,"15行目。二分探索木に値がまだ入っていないときの処理を、別途場合分けによってあらわしている点で重要だと考えている。
24・26行目。それぞれ「一番大事な処理」「二番目に大事な処理」を左に進む場合で述べたが、右に進むの場合も当然重要である。
33・34・38～40行目。「三番目に大事な処理」を32行目で述べたが、これらの行も同じく二分探索木の巡回を再帰によって行うことを表しており、重要である。",とても理解できた。,「左と右」や「通りがけ順と行きがけ順」のように、重要な行の中に2つのものが並列で並んでいるような箇所があり、それらの順位付けの扱いをどうするのかが非常に難しいと感じました。
12/17/2022 21:49:32,8,4,19,新たな値の挿入において、二分木の性質を活用しているところだから。,11,11,,33,中間順巡回と先行順巡回の違いがこのprint関数の位置によく表れているから。二分木の挿入の方が、二分木の本質だと思ったので2番にした。,14,14,,38,2番目に重要だと思ったのと同じ理由。重要度は2番目と同じだと思った。,14,14,,,まあ理解できた。,
12/21/2022 11:40:17,4,4,19,二分探索木を作成・値を挿入するときに最も重要になる条件分岐だから。,8,8,,32,中間順巡回を行うために、どの引数を用いて再起的に関数を呼び出すかを決めているため。ただ、できている木を見ていくだけの処理。,5,5,,39,先行順巡回を行うために、再起的に関数を呼び出している部分だから。ただ、この木においては中間順の方が重要な意味を持つ。,5,5,,,とても理解できた。,
12/28/2022 13:19:47,5,4,19,二分探索木の挿入において、左右がどのように振り分けられるかを表している重要な部分だと思うから,8,8,,23,左右の振り分けのルールを理解することが大前提だが、その後に疑問となりうる、すでに子ノードに値が振り分けられていた場合、再帰的な処理を行うことが読み取れるコードになっているから。,5,5,,38,二分探索木の構築のほうが重要だと考えたが、出力における2種類の探索のうち、pre_orderのほうが直感的に捉えられると考え、出力部分を選んだ。,13,13,,"39,40: pre_orderの巡回において、どの部分で再帰関数を呼び出しているかも重要だと思うから",とても理解できた。,重要性の評価とは関係なく競プロのコードとしてみた時、キーに重複があったときに無限ループが発生するような気がして少し違和感がありました。AOJのこの問題はライブラリの検証のためあると思っているので、コードの汎用性を優先したほうが良いのではないかなと思ってしまいました
12/30/2022 17:12:28,10,4,19,insertするときに、左右で場合分けすることが重要であると思ったため。,8,8,,15,self.rootがNoneの時の場合分けも非常に重要だと思ったため。1番ではないのは比較的気付きやすいと感じたため。,8,8,,32,"再帰を使ったり、self.in_order(node.left)とprint("" "" + str(node.number), end="""")の順番に気をつけたりして、in_orderとpre_orderを実装することが重要だと感じたため。",14,14,,,あまり理解できなかった。,
1/3/2023 2:14:13,11,4,19,左の子には小さく，右の子には大きいという木の性質をつかって探索している行だから．,10,10,,1,木を作る上で大切な右と左の子をもつ要素を定義している箇所であるため．実際に探索している箇所の方が重要かなとおもったので2番目にしました．,14,14,,32,"nodeの情報を表現する方法としてinorder,preorderという概念があることは大事だと思います．一方で探索木をどう表そうとも載ってる情報の内容が変わるわけではないので3番目にしました．",14,14,,,とても理解できた。,
12/8/2022 21:41:14,1,5,19,初めに見つけたノードから優先して探索するというDFSのアルゴリズムを端的に表す部分だと考え，最も重要とした.,10,10,,20,再帰関数が閉じた後に操作を行うことで，隣接頂点を調べ終えた後に操作をすることを保証する部分であり，重要だと考えた．DFSの本質ではないが，発想も簡単ではないと感じるので，2番目とした．,14,14,,15,再帰関数が呼ばれた直後に操作を行うことで，ノードを訪れた直後に操作を行うことを表す部分であるため重要だと考えた．解答に直結しているものの，DFSの本質ではなく，また2番目に選んだ箇所よりも発想として容易だと考え，3番目とした．,14,14,,,とても理解できた。,
12/11/2022 0:47:43,3,5,29,dfsで解けるということがこの問題で一番コアな部分だと思うので。,2,2,,19,今回の問題のコアであるdfsで一番大事なのはここの再帰構造だと思うので。,5,5,,24,この問題特有の部分は、ただdfsを回すだけではなく一応全ての頂点についてチェックしなければいけないことだから。,10,10,,,とても理解できた。,
12/13/2022 21:42:52,7,5,19,深さ優先探索が再帰関数で実現可能であるということがここの一行で現れているから．,5,5,,20,"その頂点の探索終了時間は，そこに続く頂点の探索が全て終わった後にするため，for文を抜けた後に終了時刻を記録するという間違えやすい条件がここで現れているから．
1番でない理由としては，深さ優先探索自体のアルゴリズムの実現の方が重要であると考えたから．",3,3,,26,"未発見の頂点がある場合はそこを支点に深さ優先探索を始めていくことで，全ての点を網羅することができるということがこの一行で現れているから．
3番である理由はこのことは問題文でも指摘されていることだから．",10,10,,17: 一度現れた頂点は無視することで，ループに陥ってしまうことを防いでいる．,まあ理解できた。,
12/14/2022 14:10:29,6,5,19,深さ優先探索の実装の特徴である、再起的呼び出しを行っている部分だから。,5,5,,15,解答となるタイムスタンプを更新している部分だから。1 番ではないのは、比較的自明だと言えるから。,9,9,,20,解答となるタイムスタンプを更新している部分だから。実際 2 番と同程度に重要だと思う。,9,9,,,とても理解できた。,
12/15/2022 11:20:40,2,5,19,DFSは再帰関数を用いて実装することが多いが、その再帰関数を呼び出している部分であるから。,5,5,,14,この問題では入った・出た時刻を答える必要があり、その時刻を再帰関数を呼び出しても正しく動作するようにグローバル変数として宣言している部分であるから。,1,1,,5,グラフの隣接リスト表現を配列Gに作っている部分であるから。直接問題を解く部分ではないが、グラフの扱い方の知識としては重要であると考えた。,6,6,,,とても理解できた。,
12/15/2022 20:54:01,9,5,19,深さ優先探索の方法（今いる頂点と隣り合っている頂点の再帰呼び出し）を表しており、アルゴリズムの本質部分であるため、最も重要であると考えている。,5,5,,17,深さ優先探索で、一度訪れた頂点を訪れないようにする処理が書かれており、探索が終わらないことを防止する役割があるから。ただ、探索の方法のほうが重要であると考えているため、1番大事というわけではないと考えている。,7,7,,15,訪れた時間帯を記録する箇所であり、結果を出力する上では大事であるが、アルゴリズムの本質部分ではないから。,9,9,,20行目。15行目同様に、訪れた時間帯を記録しているため、15行目と同じく重要である。,とても理解できた。,
12/17/2022 22:04:00,8,5,18,深さ優先探索をしているということがよく読み取れる一文だから。,13,13,,19,1番と同じような理由だが、深さ優先探索で、１つ掘り下げるのが終わった時の処理を表していて、重要だから。1番と同じくらい重要だと思った。,14,14,,5,inputのデータを加工して使いやすい形のリストにしているから。データ処理の話なので、重要度は劣ると思った。,14,14,,,とても理解できた。,
12/21/2022 11:56:29,4,5,19,dfs_subという関数を再起的に呼び出すという、深さ優先探索の本質的な処理をしているため。,5,5,,15,発見時刻を表すリストを更新している部分だから。DFSの本質ではないがこの値は回答に必要。,9,9,,20,完了時刻を表すリストを更新している部分だから。どの部分でこの処理を行うかを考えるのは比較的簡単。,9,9,,,まあ理解できた。,
12/28/2022 15:11:51,5,5,19,自分自身を呼び出しており、再帰を利用したDFSであることが明確にわかるから,5,5,,5,DFSの問題なので再帰部分が最も大事だが、それが扱う隣接リストの構造が明確に分かる部分だから,14,14,,25,頂点で探索を打ち切ることが伝わるため、再帰・隣接リストの構造と合わせてDFSアルゴリズムの全体を理解できるようになるから,7,7,,"15,20 : 探索開始・終了時刻をどのタイミングで記録しているかがわかりやすいから",とても理解できた。,
12/30/2022 17:25:08,10,5,17,訪れたことがあるノードをはとばすことが重要であると思ったから。,10,10,,19,再帰を使っていることも、計算量的に重要だと思ったから。使わなくても、dfsはできるので1番ほど重要でないと思った。,4,4,,20,v  の隣接リストを調べ終えた完了時刻を記録していて、1番や2番ほどではないが、重要だと思ったため。,9,9,,,まあ理解できた。,
1/3/2023 5:06:13,11,5,19,再帰にすることでDFSを実装しているので自身を呼び出すところが重要だと思いました．,5,5,,20,"完了時刻を求めないといけないので，自身を呼び出した後で時間を計測している箇所を選びました．再帰がどういう操作になっているかを理解していないと，この場所に書けないと思いました．
完了時刻は必ずしも問題にならないので2番目です．",12,12,,17,"到達したところを管理しておかないと無限におわらなくなってしまうので，大切です．
DFSする上で注意するポイントという位置付けで，DFSそのものからは外れるかなと思ったので，3番目です．",7,7,,,とても理解できた。,
12/8/2022 21:48:32,1,6,7,初期化したDPテーブルを更新する箇所でありDPの考察の大部分を占めているとともに，ミスが起こりやすい箇所でもあるため重要だと考えた．,3,9,×,10,DPテーブルを構築している箇所であり，DPの本質部分の一つだと考え選択した．DPテーブルの更新を行う部分に比べると考察の必要は少なく，ミスも起こりにくいと考え2番目とした．,6,6,,12,"完成させたDPテーブルを用いて要求された答えを出力する部分であるため重要だと考えた．
DPテーブルの初期化，更新の方がより本質的かつ注意を要する部分だと考え，3番目とした．",2,14,×,,とても理解できた。,
12/11/2022 0:52:52,3,6,10,ナップサック問題は要はdpで解けることが一番大事だが、そのコアはここの遷移式なので。,9,9,,8,dpは状態を適切に管理することで全探索を効率化することだと考えられるが、9行目と合わせてここが全探索部分なので。,4,4,,9,dpは状態を適切に管理することで全探索を効率化することだと考えられるが、8行目と合わせてここが全探索部分なので。,4,4,,,とても理解できた。,
12/13/2022 22:22:39,7,6,10,dpを行うために一番重要となる，値を更新するための条件式が書かれているから．,8,8,,12,"dpの結果，最終的に求めたい答えはdp[N][W]に現れるということがこの行で現れているから．
1番目でない理由は，dpの更新アルゴリズムが分かればこのことは最終的に分かることであるから．",2,14,×,9,"容量Wに関するdpであることがこの行で確認できるから．
3番目である理由は，特に他のものに注目したdpでも可能であるため．",13,13,,,まあ理解できた。,
12/14/2022 14:16:56,6,6,10,動的計画法の根幹である、テーブルの更新を行っている部分だから。,9,9,,7,動的計画法の更新の初期条件が含まれているから。漸化式においては更新式の次に重要と言えるだろう。,6,6,,8,テーブルの更新順序を規定している行だから。1 番や 2 番の部分が決まれば自然に定まるので、それらより重要とは言えない。,14,14,,9。8 行目と同様に重要。,とても理解できた。,
12/15/2022 20:59:02,9,6,10,DPの遷移を表しており、DPの問題においては遷移が最も大事な箇所であると考えているから。,9,9,,7,DPの初期値を表しているから。DPの問題においては初期値が遷移の次に大切であるので、この順番である。,6,6,,12,DPテーブルの中で、答えが格納されている場所を表しているから。DPテーブルの中でこの場所に答えが格納されていることは、DPテーブルが正しく更新されたことが前提であるため、優先順位は前者二つに比べると低くなる。,2,14,×,,とても理解できた。,
12/15/2022 23:10:54,2,6,10,ナップサック問題の漸化式の部分であり、これのおかげで指数時間から改善することができているため。,4,4,,7,動的計画法をつかうことにより、O(NW)で求めることができるが、そのdp配列を宣言していることも大切であると考えた。(dpの本質部分ではないので2番目。),6,6,,5,10行目と7行目が最も重要な部分であるが、一応入力をしないと問題は解けないので、5行目が次に大切。,1,1,,,とても理解できた。,
12/17/2022 22:08:08,8,6,10,動的計画法において、最も本質的な部分を表している場所だから。,13,13,,7,dpテーブルを作成するのも、動的計画法においては大切だから。1番に比べると本質的ではないと思った。,6,6,,12,動的計画法の答えがテーブルの右下に出てくるというのも、知らないと分からないから。アルゴリズムそのものではないので重要度は低いと思った。,2,14,×,,とても理解できた。,
12/21/2022 12:10:22,4,6,10,動的計画法を行うためのテーブルを更新する重要な処理が行われているため。,9,9,,12,答えを出力するために動的計画法の結果のテーブルを参照しているため。ただ処理としては参照をしているだけ。,2,14,×,7,動的計画法を行うためのテーブルを初期化しているため。初期化のみのため1番や2番にはならない。,6,6,,,とても理解できた。,
12/28/2022 15:18:46,5,6,10,DPの処理がワンライナーで記述されており、どのようにDPテーブルが書き込まれているかわかりやすいから,9,9,,7,"直感的に理解できる部分ではあるが、DPテーブルの設計について(V,Wに１を加えた大きさであること)の補足知識を得られるから",1,1,,12,上記２つの行で処理の本質的な部分はすべて網羅しているが、補足として、DPテーブルのどの部分に最終的な結果が書き込まれていることが分かるから,2,14,×,,とても理解できた。,
12/30/2022 17:30:37,10,6,10,動的計画法で一番重要な式を表していおり、重要であると感じたため。,13,13,,7,dp = [[0 for _ in range(W + 1)] for _ in range(N + 1)]はdpテーブルの初期化として、漸化式ほどではないが重要だと思ったため。,6,6,,12,"dp[N][W]を出力し、価値の合計の最大値を求めることが、1,2番ほど難しくないが重要だと感じたため。",2,14,×,,まあ理解できた。,
1/3/2023 5:11:59,11,6,10,dpテーブルの更新を行なっていくところであるから．漸化式をどう定義するか考えるのがDPの一番の要点だと思います．,9,9,,7,この問題を二次元リストで管理するという発想自体が大事だと思います．どう管理するかは1番目にあげたので，2番目には構造をあげました．,2,2,,12,最終的に欲しい状態がテーブルの中のどこに存在しているかを把握するのは大事だと思います．どこを見るかよりも情報自体を作るのが大事だと考えたので，3番目にしました．,2,14,×,,とても理解できた。,
12/8/2022 22:01:24,1,7,9,"
注目している区間の真ん中の要素について確認を行い区間を狭めることにより，確認回数をlogオーダーに抑えるという2分探索の考え方の核となる部分であるため．",4,4,,12,条件を満たす要素があれば探索区間をその右側に，なければ左側に絞るという2分探索の区間削減の考え方を最も端的に表していると考えたため．1番目のように計算量のオーダーに関わる部分ではないため，2番目とした,10,10,,8,"このように実装することによって,okとngの大小が逆転しても同様に実装できるため，1,2番目として選んだ行ほど重要ではないが，実装の工夫としては重要だと考え3番目として選んだ．",1,1,,,とても理解できた。,
12/11/2022 0:57:18,3,7,26,この問題の一番コアなところは二分探索を使って効率的に探索できることに気付くことなので。,2,2,,9,この問題で一番大事なアルゴリズム二分探索の大事な部分は、ここで区間を半分にしながら探索できることだと思うから。,10,10,,8,上述した区間を半分にすることを繰り返すことで必要なindexを求められるのが二分探索で大事なところなので、繰り返し処理もまあちょっとは大事かもしれない。,10,10,,,とても理解できた。,
12/13/2022 22:51:14,7,7,9,二部探索で一番重要である，okとngの中間の数と比較し，範囲を狭めていくという工程で重要な中間の数を算出する箇所だから．,12,12,,8,"探索の終了条件をこの行のように定めることで探索の終了を定めている．
一行目でない理由は，終了条件は二部探索の一番重要な部分ではないから．",7,7,,12,"答えとしてカウントされるかどうかの判断をしている部分だから．
3番目である理由は，この問題で一番問われているであろう二部探索のアルゴリズム自身とは少し外れた内容であるから．",8,8,,,まあ理解できた。,
12/14/2022 14:21:09,6,7,13,二分探索の根幹である、解の存在範囲を半分に狭める部分だから。,10,10,,15,二分探索の根幹である、解の存在範囲を半分に狭める部分だから。1 番と同様に重要。,10,10,,8,あり得る解が 1 つになるまで探索するという終了条件を表す部分だから。解の狭め方に比べると従たる部分であると言える。,7,7,,,とても理解できた。,
12/15/2022 23:23:27,2,7,9,"""二分""探索という名前のアルゴリズムなので、変数midを宣言してその判定問題に落とし込んでいる部分が最重要であると考えた。",8,8,,12,その二分探索の判定問題を解いている部分なので、アルゴリズムの本質部分に次いで、問題を解くという意味で重要であると考えた。,8,8,,8,二分探索は終了条件をきちんと指定しないと正しく収束しなかったり、計算が終わらなかったりするので、細かい部分ではあるが、上の2つの行に次いで重要であると考える。,7,7,,,とても理解できた。,
12/16/2022 18:13:26,9,7,2,二分探索の中において、判定の条件を関数化したものであり、ここが間違っていると二分探索が正しく動作しないという点で一番大事なポイントだと考えているから。,8,8,,8,二分探索における終了条件を明記しており、ここが正しくないと正しく終了しないため。判定の条件とは違い、問題によって異なるような箇所ではなく、常に同じような処理をする箇所であるため、1番ではないと考えた。,7,7,,10,データが配列の中に見つかった場合にTrueが返せるような処理を別立てで行っている箇所であるから。この部分は今回の問題特有の箇所であり、一般の二分探索の問題で現れる箇所ではないため、1番や2番ではないと考えた。,8,8,,16行目。この部分では、データが見つからなかった場合にFalseを返しており、10行目同様に重要だと考えた。,とても理解できた。,
12/17/2022 22:13:47,8,7,13,二分探索で、見つからなかった時にカーソルの位置をずらして、探索範囲を狭めるという処理はとても重要だから。,10,10,,15,1番と同様の理由で、二分探索において重要なところだから。重要度は1番と同じ。,10,10,,10,二分探索で、答えが見つかった時の処理も重要だから。探索範囲を狭めていくことの方が二分探索の本質だと思ったので3番にした。,14,14,,,とても理解できた。,
12/21/2022 12:23:45,4,7,2,答えがリストの右側にあるか左側にあるかを判別するという二分探索の本質的な処理だから。,8,8,,9,現在の探索範囲の真ん中の位置を調べるというのは二分探索において重要。ただ処理としては単純。,10,10,,10,2分探索に成功したかを判別する処理だから。比較的重要ではあるが、一致の確認をしているだけ。,8,8,,,とても理解できた。,
12/28/2022 15:25:33,5,7,2,二分探索には様々な流派があり、読み手の「ok」の定義が曖昧だとコードの誤読を起こす。２行目を読むことで、「ok ⇔ 値がkey以上の集合」(めぐる式二分探索？)と理解できるため、重要だと考えた。,3,3,,9,二分探索の基本的な考え方である、ngとokの中点を次回の探索点とするという考え方が分かるから。１番にしなかった理由は、二分探索が既知であればあまり本質的ではないため。,9,9,,8,while文を使って二分探索を実装する際のテクニックとして学びのある行だから。二分探索の基本的な知識である点と、中点を次回の探索点にするという知識よりは重要度が低いと考え３番めにおいた。,1,1,,,とても理解できた。,
12/30/2022 17:38:52,10,7,8,whileの条件式によって、中の場合分けが変わってきて、ややこしくなる事があるので、重要だと思いました。,3,3,,6,while abs(ok - ng) > 1:が最初に成り立つように、ng = -1と初期化することも重要だと思いました。,6,6,,27,binary_searchで見つかった分ansに足すことは比較的簡単だが重要だと思いました。,9,9,,,まあ理解できた。,
1/3/2023 5:20:33,11,7,9,"""2""つにわっているところだから．この操作のおかげで高速に探索できるようになっているため．",4,4,,8,探索を終える条件を把握することは大事だと思います．操作を終える条件であり，操作そのものではないので2番目にしました．,7,7,,6,"ng,okで確実にそうだといえる範囲のインデックスを指すことは重要です．前二つに比べるとちょっとしたポイント感が強くて本質からちょっと離れたところにいるイメージがあります．",9,9,,,とても理解できた。,
12/8/2022 23:18:37,1,8,14,キューをリングバッファとして実装する際に，headとtailの位置を更新する部分が最も重要だと考えた．,9,9,,20,キューをリングバッファとして実装する際に，headとtailの位置を更新する部分が最も重要だと考えた．1番目と全く同じ重要度であるが，便宜上2番目とした．,9,9,,27,この問題を解く際にキューを使うという発想が重要だと考えた．キューの実装の方がより重要と考え，3番目とした．,2,2,,,とても理解できた。,
12/11/2022 1:02:45,3,8,27,この問題のコアなところは、データ構造queueを使えば問題の設定をそのままシミュレーションできることに気付くことなので。,2,2,,37,queueを使って実際に問題の状況をシミュレートしているところはここだから。,12,12,,7,リングバッファを用いたqueueのどこが一番大事かは少々微妙だがしいて言えば8行と合わせてここのインデックス管理だけでqueueが実装できることかなあ、と思ったから。,14,14,,,とても理解できた。,
12/13/2022 23:27:20,7,8,5,初期値の段階でheadとtailの位置を決めておくことでqueueのアルゴリズムが簡単に実現できるということがこの初期化関数でわかるから．,6,6,,19,"queueのアルゴリズムの特徴である，取り出す時は先頭の要素からということがこの行で表されているから．
1番でない理由としては，queueのアルゴリズムの説明は問題中でなされているから．",11,11,,13,"queueの挿入時は末尾に挿入するということがこの行で表されているから．
3番目である理由は，stackなど他のアルゴリズムでも挿入では末尾に挿入することが多いため，違いがないから．",11,11,,,まあ理解できた。,
12/14/2022 14:25:24,6,8,37,問題固有の本質的な処理を行なっている唯一の部分であると言える。,13,13,,14,リングバッファによるキューの実装で必要な処理だから。問題固有の部分ではないので 1 番ではない。,13,13,,20,リングバッファによるキューの実装で必要な処理だから。2 番と同様に重要。,13,13,,,とても理解できた。,
12/15/2022 23:29:20,2,8,14,queueは配列を円環状に使い回しながら先頭と末尾の座標を持って実現するデータ構造であるが、その末尾の座標を円環状に持っていることを表している部分だから。,14,14,,20,14行目と同様に、円環状の配列の先頭を持っている部分であるので重要であると考える。20行のほうが後に出てきているので、2番目にした。,14,14,,37,プロセスの残り時間で場合分けをしながらqueueを操作している部分で、データ構造の実現の方が本質であるとは思うが、問題解決部分の重要部分として3番目に重要だと考える。,8,8,,,とても理解できた。,
12/16/2022 18:31:40,9,8,37,キューを用いてラウンドロビンのシミュレーションを行う部分であり、この部分の処理が間違っているとシミュレーションがうまくいかないことになり、問題の本質部分に関わっているといえるから。,12,12,,14,リングバッファ方式でキューの末尾を伸ばしていく処理を行っており、この部分が正しくないと正しくキューが動作しないため。キューの実装箇所であるため、この問題特有の処理ではないと考えたため、1番とはしなかった。,11,11,,24,キューが空であることの条件を書いており、この部分が正しくないと正しくプログラムが終了しないため。キューの実装の本質部分ではないと考えたため、1番や2番とはしなかった。,7,7,,20行目。キューの先頭を縮める処理を行う箇所であり、14行目同様に、キューを正しく動作させる上では欠かせない箇所である。,とても理解できた。,
12/17/2022 22:25:57,8,8,37,問題の要求に応えるために、データ構造そのものだけでなく、その使い方も工夫する必要があるというところだから。,13,13,,13,queueにpushするという、データ構造において重要な作業だから。1番目に比べると簡単だと思ったため2番にした。,11,11,,19,queueからpopするというのもデータ構造において大切だから。2番と重要度はほぼ同じ。,11,11,,,あまり理解できなかった。,
12/21/2022 12:32:03,4,8,37,ラウンドロビンスケジューリングを実現するために、キューを更新するか、printするかを決めている部分だから。,8,8,,13,キューにプッシュするときにどのインデックスに入れるかを決めているため。キューとしては重要だが、処理は比較的単純。,9,9,,19,キューのポップを行う本質的な部分。2番のプッシュより処理はもっと単純である。,11,11,,,とても理解できた。,
12/28/2022 15:38:43,5,8,13,データがQueueを模した配列にどのように格納されているかのイメージを掴むことができるから,14,14,,14,上記のデータの格納について理解することにあわせて、14行目を読むことでtailがどのような挙動をしているか分かるようになるため,14,14,,19,データ構造についてイメージを掴めていることが前提となるが、popがどちらがわから行われているかを読み取ることができるから,11,11,,,まあ理解できた。,
12/30/2022 17:51:52,10,8,14,pushされたときに、self.tailをずらしているのはqueueの実装において大切だと感じたため。,9,9,,11,queueがいっぱいになった時の場合分けも1番ほどではないが、非常に重要であると思ったため。,8,8,,38,queueの実装とは関係ないが、timeとqの小さい方を足すことで、正しくラウンドロビンスケジューリングのシミュレーションができ、重要であるため。,12,12,,,まあ理解できた。,
1/3/2023 5:31:21,11,8,4,queueというデータ構造はかなり重要だと思います．クラス名を定義している行を選びました．,13,13,,20,取り出した後インデックスを一つ進めて，先頭を移動させています．modをとって有限のリストを活用しているのも大事だと思います．queueのあくまで一部分なので2番目です．,14,14,,8,初期状態をhead>tailなのはこのコードを書く上で間違えやすいかなと思ったので選びました．別の書き方もできるので3番目です．,3,3,,,とても理解できた。,
12/8/2022 23:26:43,1,9,21,割り算の結果の剰余を求める際には逆元を用いることが必要であるという最も注意すべき点に対応しているため．また，冪乗を求めるために繰り返し二乗法を用いることも示されている．,12,12,,7,冪乗を求めるための繰り返し二乗法の考え方を端的に表している部分であるため選択した．一方で計算の最も難しい部分である1番目よりは重要ではないと考えた．,12,12,,25,この問題の答えである場合の数を求めている部分であるため選択した．アルゴリズムとしての工夫が凝縮されている1番目，2番目の部分ほど重要ではないと考えた,12,12,,,とても理解できた。,
12/11/2022 1:08:43,3,9,25,この問題で一番コアなのは答えをcombination一発で求められることに気付くことだから。,2,2,,21,modをとるcombinationの効率的な計算は階乗をつかうことや、階乗の逆元がフェルマーの小定理で求められることが重要だから。,12,12,,7,9行目と合わせてn乗を求める時に繰り返し2乗法を用いると効率的に求められることが大事だから。,4,4,,,とても理解できた。,
12/13/2022 23:45:05,7,9,25,この問題はコンビネーションによって解くことができるということがこの一行でわかるから．,2,2,,21,"modありのコンビネーションの計算では，逆元を使うと計算量を抑えてできるということがわかるから．
1番である理由は，これは計算の工夫であり，問題の解法自体とは直接関わることではないため．",4,4,,7,"累乗の計算が2の累乗に注目することでより計算コストを抑えられるということがしめされているから．
3番である理由は，この行の処理は1番2番で挙げた箇所に関する計算をさらに計算コストを下げるために行なっているものであるため．",4,4,,,まあ理解できた。,
12/14/2022 14:29:52,6,9,25,combination というよく知られた関数を用いて問題の解答を端的に記述しているから。,2,2,,21,combination を定義した部分だから。また、逆元計算の方法が含まれている。問題固有の考察は含まれないので、1 番ではない。,12,12,,7,再帰を用いた繰り返し二乗法を端的に示す行だから。単に計算量削減のために必要なものなので、1 番や 2 番ではない。,5,5,,,とても理解できた。,
12/15/2022 23:34:05,2,9,21,二項係数をもとめる必要がある問題だが、その二項係数の計算をしている部分であり、最重要であると考える。,12,12,,4,二項係数を計算するには逆元を計算する必要があるが、そのためにはp-2乗を計算する必要があるので、powを計算する関数は次いで重要であると考えた。,12,12,,25,問題の答えがdp等での数え上げではなく、二項係数で表すことができることを表しており、アルゴリズムの本質部分ほどではないが、問題を解く上では重要な観察が含まれていると考えた。,2,2,,,とても理解できた。,
12/16/2022 18:49:19,9,9,21,この問題の本質は経路数を二項係数を用いてどのように計算するかというところにあり、逆元を用いた二項係数の計算を行っているこの箇所が、まさしく本質的な箇所であるといえるから。,12,12,,7,繰り返し二乗法を用いて累乗を高速に計算する処理において、nを半分ずつにしていくことで高速な計算を実現していることを表している箇所であるから。問題の本質的な箇所というのではないため、1番ではないと考えた。,4,4,,9,繰り返し二乗法を用いて累乗を高速に計算する処理において、nが奇数のときに行う処理を表しているため。この処理はnが偶数のときには出てこないこともあり、1番目や2番目にはならないと考えた。,12,12,,"16行目。二項係数の計算に用いられる階乗の計算の処理を行っている行であるから。
25行目。今回の問題における経路数の式を表しており、ここを間違えると答えが合わないから。",とても理解できた。,
12/17/2022 22:30:08,8,9,21,大きい数字なのでmodをとりながら計算していく、というプログラミングならではの処理方法だから。,12,12,,7,累乗の計算で、再帰を使うことで計算量を抑えるというのは重要だから。MODに比べると基本的なことだと思ったので2番とした。,4,4,,25,そもそもこの計算方法で答えが求められることを知らないとこうは書けないから。数学の知識なので3番とした。,2,2,,,とても理解できた。,
12/21/2022 13:00:49,4,9,21,"
power_mod()を適切に利用して組み合わせの計算をしているため。与える引数も複雑で考える必要がある。",12,12,,25,答えを求めるためにcombination()に適切な引数を与えている部分だから。引数を決めているだけで本質的な処理の部分ではない。,1,1,,7,power_modを適切に計算するために再起処理を行なっているため。power_modは大事だが、このプログラムの中では道具の1つ。,5,5,,,まあ理解できた。,
12/28/2022 15:46:44,5,9,25,そもそも、この経路パターン数の問題をnCrの形式に落とし込めること自体ある程度の発想と数学力が必要であるため、combination関数を呼び出している部分がもっとも重要であると考えた。,2,2,,21,Combination関数の実装の本体であり、nCrの求め方を知るための重要なコードであるため、nCrを使う事自体の次に重要だと考えた。,13,13,,7,"combination関数ではfactorial,power_modの２種類の関数を呼び出しているが、factorial関数はMODを用いていること以外は自然な実装であるのに対し、power_modは繰り返し二乗法を用いており、理解が必要であるため、３番目に重要な部分だと考えた。",14,14,,"8,9: 繰り返し二乗法における実際の計算を担っている部分であるため、再帰の部分の次に大切であると考えた。",まあ理解できた。,
12/30/2022 18:04:48,10,9,21,"コンビネーションのfactorial(n) * power_mod(factorial(n - k), MOD - 2) * power_mod(factorial(k), MOD - 2) % MODとすることは、逆元の考えなどを用いており、重要だと思った。",12,12,,7,剰余を取りながら計算することも、1番ほどではないが、とても重要だと思ったため。,12,12,,25,"シンプルに組み合わせの数を使って、経路数を求めるという考えもコードは1,2番よりシンプルであるが重要だと思ったため。",2,2,,,まあ理解できた。,
1/3/2023 5:39:07,11,9,21,modにおいて割り算をするときにmod-2乗と同等という知識は大事かなと思います．,14,14,,7,繰り返し自乗法の要だと思ったからです．この問題の条件がゆるゆるであれば必要なくなるので2番目にしました．,13,13,,13,繰り返しつかうfactorialを切り出して関数にもっておくのは大事だと思います．この問題特有の話ではないので3番目です．,1,1,,,とても理解できた。,
12/8/2022 23:34:05,1,10,12,現在注目している部分文字列から一つの操作を行う状態を考えるというDPの考え方を表している行であるため，最も重要だと考えた．,14,14,,6,空文字列とのレーベンシュタイン距離を考えることが必要であり，DPテーブルを初期化するというDPにおいて基本的な部分であるため．,6,6,,8,空文字列とのレーベンシュタイン距離を考えることが必要であり，DPテーブルを初期化するというDPにおいて基本的な部分であるため．(2番目と同等の重要度ですが便宜上3番目としました．),6,6,,"10, 11行目 DPの更新順序に関わっているため重要だと考えた",とても理解できた。,
12/11/2022 1:11:33,3,10,12,レーベンシュタイン距離で一番大事なのはdpで求められることが一番大事だと思うが、そのコアの遷移式はここだから。,9,9,,10,11行目と合わせてdpで効率化された全探索をしている部分だから。,10,10,,11,10行目と合わせてdpで効率化された全探索をしている部分だから。,10,10,,,とても理解できた。,
12/14/2022 0:19:10,7,10,12,dpで必要なdpテーブル更新のための方程式が明示されている部分だから．,9,9,,4,"どのようなdpテーブルを構築するのかが書かれている部分だから
1番目でない理由は，dpで一番重要なのはどのように更新の条件を立てるかだと思ったから．",6,6,,14,"最終的にも止まる答えがdpテーブルのどこにあたるのかということを示している部分だから．
3番である理由は，1,2番で示した部分が分かれば，この部分も直感的に分かるのではないかと思うから．",2,14,×,,まあ理解できた。,
12/14/2022 14:32:18,6,10,12,動的計画法の根幹である、テーブルの更新を行っている部分だから。,9,9,,6,動的計画法の根幹である、テーブルの更新を行っている部分だから。ただし、1 番ほどテーブルの多くの部分について記述したものではない。,9,9,,7,動的計画法の根幹である、テーブルの更新を行っている部分だから。2 番と同様に重要。,9,9,,,とても理解できた。,
12/15/2022 23:37:51,2,10,12,動的計画法の漸化式の部分であり、この式を立てることができれば解けたも同然なので、1番大切であると考える。,9,9,,14,dp配列の[len(s1)][len(s2)]番目が答えになるということはきちんと漸化式を理解していないとわからないはずなので、ここも漸化式そのものに次いで重要であると考える。,2,14,×,6,漸化式そのものや答えの部分ほどではないが、配列は適切に初期化しておかないと正しい動作をしないので、これが次いで重要であると考える。,6,6,,,まあ理解できた。,
12/16/2022 18:55:03,9,10,12,レーベンシュタイン距離を求めるDPにおける遷移を表しており、ここを間違えるとDPが正しく動かないから。,9,9,,6,DPの初期値を格納している箇所であり、遷移ほどではないものの、DPの結果を正しく出すためには必要な箇所であるから。,6,6,,14,答えがDPテーブルの中のどこに現れているかを表しているから。DPの答えが正しく求められるには、遷移や初期値が正しいことが前提であるため、遷移や初期値ほど重要ではないと考えている。,2,14,×,8行目。ここも6行目と同様にDPの初期値を格納している箇所であるため重要である。,とても理解できた。,
12/17/2022 22:34:25,8,10,12,動的計画法を使うというのはこの問題を解く上でのポイントであり、またテーブルの埋め方も考えて書かなければいけない所だから。,9,9,,6,dpテーブルの初期化において、1列目の埋め方はこの問題の内容を踏まえて、少し考えなければならないところだから。テーブルの埋め方の方が大事だと思ったので3番とした。,6,6,,14,動的計画法で、答えがテーブルの右下に出てくるというのも重要なところだから。知っていれば分かることなので3番とした。,2,14,×,,とても理解できた。,
12/21/2022 13:18:29,4,10,12,挿入・削除・置換を使ってDPテーブルを更新するという、動的計画法の本質的な処理だから。,9,9,,4,動的計画法で解くためにDPテーブルを初期化している部分だから。DPを使うという判断が分かる行というだけで、大事な処理ではない。,6,6,,6,DPテーブルの自明な部分を埋める処理だから。自明な部分というだけあって1番や2番ではない。,9,9,,,とても理解できた。,
12/28/2022 16:06:12,5,10,12,DPの遷移を端的に表しているため、本質的な部分がすべて集められているから,9,9,,4,漸化式を見ても意味が汲み取りづらかった場合に、DPテーブルの大きさで、どのような値が格納されるテーブルなのかをある程度推測できるから,14,14,,6,アルゴリズムとしてさほど重要な部分ではないが、DPの初期化として特殊な行であり、通常のDPとの差異が出ているところだから,6,6,,,まあ理解できた。,
12/30/2022 18:14:13,10,10,12,動的計画法の問題では、漸化式の部分が最も重要であると感じたため。,9,9,,6,漸化式ほど本質的ではないが、初期化も非常に重要だと思ったため。,6,6,,14,"dp[len(s1)][len(s2)]で答えを出す部分は、1,2番ができれば14行は書けると思ったので、3番目に重要であると思った。",2,14,×,,まあ理解できた。,
1/3/2023 5:44:19,11,10,12,遷移のもととなる漸化式さえたってしまえばDPはほぼ解けた気持ちになるからです．,9,9,,6,初期状態を決めている箇所だから．0文字のときはもう一つの文字列サイズに依存することを利用している．ここだけわかっても遷移できないので，2番目です．,6,6,,14,最終的に答えないといけないところはテーブルの中でどの箇所なのか把握することは大事だと思います．そもそもテーブルが作れないと意味ないので3番目です．,2,14,×,,とても理解できた。,
12/12/2022 12:04:05,1,11,9,基準値よりも小さいものと大きいものに分けるという考え方を表しているため重要だと考えた．,14,14,,19,分割した配列について操作を行うという考え方を表しているため重要だと考えた．分割した配列に対して行う操作を表している1番目よりは重要ではないと考え，2番目として選択した．,14,14,,20,分割した配列について操作を行うという考え方を表しているため重要だと考えた．2番目と同等の重要度だが，便宜上3番目とした．,14,14,,,まあ理解できた。,
12/14/2022 5:25:55,7,11,28,この問題の解法では，クイックソートと呼ばれるアルゴリズムを利用するということがこの一行で分かり，アルゴリズム名が判明すると解く方針も分かりやすくなるから．,2,2,,19,"クイックソートでは，再起的に領域を狭めながらソートを実現するアルゴリズムであることがこの一行でわかるから．(20行目も同様だと思います．)
1番でない理由は，ここだけではどのようなアルゴリズムなのか全体を把握はできないため．",5,5,,15,"pivotより小さい数を左に，大きい数を右にという操作を行うというクイックソートのそれぞれの試行で行われている操作がこの一行で分かるから．
3番目である理由は，1番目のクイックソートとアルゴリズム名の判明と2番目の再起的に行うことで高速化していることよりは重要度が低いと考えたため．",14,14,,2: 再起の終了条件を明示している部分だから．,まあ理解できた。,
12/14/2022 14:42:25,6,11,15,小さいものを左、大きいものを右に寄せるための交換操作をする行で、ソートの根幹だから。,9,9,,19,クイックソートが再帰的なアルゴリズムであることを示す行だから。ソート自体を処理しているとは言えないので 1 番ではない。,5,5,,15,クイックソートが再帰的なアルゴリズムであることを示す行だから。2 番と同様に重要。,5,5,,,とても理解できた。,
12/15/2022 19:21:13,3,11,28,クイックソートを含めてソートアルゴリズムが問題の本質だから。,13,13,,15,クイックソートは境界を決めて左右でswapを繰り返すのが本質だから。,14,14,,5,swapのための基準であるpivotを決めているところはswapほどではないが重要だと考えた。,9,9,,,とても理解できた。,
12/16/2022 19:13:54,9,11,15,左側にある、ピボットより大きい値と、右側にある、ピボットより小さい値を、スワップする箇所であり、この部分がクイックソートの処理の本質部分であるといえるから。,9,9,,19,配列の中のより小さい部分に対してクイックソートを再帰的に行っている箇所であるから。ソートの本質である「並べ替え」を表す箇所ではないと考えているため、1番ではないと考えた。,5,5,,2,クイックソートが終了する条件を表しており、ソートの本質部分ではないものの、プログラムを正しく動作させる上では重要な箇所であると考えたから。,7,7,,20行目。19行目同様に、再帰的に呼び出してクイックソートを行うことを表している箇所であるため大切である。,まあ理解できた。,
12/16/2022 21:20:26,2,11,9,ピボットを固定してピボットより左はピボットより小さく、右は大きくしたいが、そのswapを行うindexを決めている行であるから。,9,9,,11,上と同様に、swapを行うindexを決めている行である。後に出てきたので2番目。,9,9,,15,swapするindexを決めた上で、実際にそのswapをしている行であるから。indexを決める方が大事であると考えたので3番目にした。,9,9,,,まあ理解できた。,
12/17/2022 22:46:55,8,11,15,クイックソートというアルゴリズムで、pivotを基準として左右に振り分けていくという作業がもっともよく表れている一文だから。,14,14,,19,クイックソートで再帰を使うというのも、アルゴリズム上とても重要だから。1番の方がより本質的だと思ったのでこちらは2番とした。,5,5,,5,"クイックソートにおいて、pivotの選び方はいろいろあるが、ここでは1番左のものをpivot
にしているというのがここから分かるから。割と些事だと思ったので3番にした。",9,9,,,とても理解できた。,
12/21/2022 13:32:20,4,11,15,今見ているリストの左側と右側にpivotを基準に分けるというクイックソートの本質的な処理をしているため。,14,14,,9,リストの右側と左側に分けるためのカーソル位置を決める条件文だから。あくまで1番の処理を行うための条件文だから。,8,8,,19,pivotを基準に分けるというのを再起的に行う部分だから。ただ引数の与え方などは比較的単純。,5,5,,,とても理解できた。,
12/28/2022 16:44:00,5,11,19,クイックソートが再帰的な処理で、左と右にpivot以外を分けて処理しているのだということが、20行目と合わせて理解できるから。,5,5,,20,クイックソートが再帰的な処理で、左と右にpivot以外を分けて処理しているのだということが、19行目と合わせて理解できるから。(後に登場したので、2番めに大切ということにしました),5,5,,15,マーカーの移動だけではpivotより大きい/小さいものに分けることはできないが、このSwap処理が入ることで左右に振り分けられるのだということが分かるようになるから,9,14,×,8 ~ 17:クイックソートの根幹部分の実装は全体に意味があり、重要だと感じます,とても理解できた。,問題文の(配列の長さ、配列の要素の値等については特に考えなくて良い)という表現の意味があまり汲み取れなかったです
12/30/2022 20:08:27,10,11,5,pivotをarr[left]と置くことで、whileの中身がシンプルになるので重要だと思いました。,1,1,,19,再帰を使うことは1番よりも思いつきやすいので、2番目に重要であると思いました。,5,5,,15,値をスワップさせることはクイックソートで基本的なので、3番目に重要であると思いました。,9,9,,,まあ理解できた。,
1/3/2023 6:00:57,11,11,5,ある基準点をつくってその点より上か下かで整列していくというソートの初歩であるため．,14,14,,15,まさに順序が逆転している箇所を入れ替えている行だから．pivotの概念よりはこのアルゴリズムにとくゆうではないから2番目です．,9,9,,13,終了条件を正しくかかないと不具合がおこるため．アルゴリズムの本質からはなれるように感じたので3番目です．,7,7,,,とても理解できた。,
12/8/2022 23:45:30,1,12,29,区間に対する処理の際には，注目している区間を子区間に分割し再帰的に処理するというSegment木の核となる発想が表されているため最も重要だと考えた．,5,5,,21,更新の際は子区間から親区間に結果を伝えるというsegment木の重要な考え方が表されていると考えたため．実装難易度が29行目よりも低いことを考慮して2番目とした．,9,9,,20,"子区間から親区間へと注目するインデックスを移す処理が書かれているため重要だと考えた．Segment木の発想の中心である1,2番目に比べると実装の細かい部分に当たると考え3番目とした．",9,9,,,とても理解できた。,
12/14/2022 14:45:56,6,12,39,セグメントツリーで区間 min を再帰的に求める根幹の部分だから。,12,5,×,21,セグメントツリーの更新を行う部分の本体。1 番と比べると自明。,9,9,,17,忘れがちなインデックスの処理。1 番 2 番と比べると本質ではない。,3,3,,,とても理解できた。,
12/14/2022 23:45:29,7,12,37,この問題の解法はセグメントツリーと呼ばれるアルゴリズムを用いるということがこの行から読み取れるから．,2,2,,14,"この行より，どのように問題に適したセグメントツリーを構成するかが分かるから．
1番でない理由は，具体的なアルゴリズム名(セグメントツリー)が分かることよりは重要ではないと考えたから．",2,2,,29,"どのように最小値を得るのかをこの行で表されているから．
3番目である理由は，セグメントツリーの構造が分かれば，どのように得られるのかは分かる場合が多いと思うから．",12,12,,,まあ理解できた。,
12/15/2022 19:30:15,3,12,37,Segment Treeで解けることがこの問題のコアであるから。,2,2,,29,Segment Treeでどこが重要かと言われると微妙だがこの式で区間についての演算が高速にできるのはかなり本質だと思う。,4,4,,21,一点更新が対数時間で実行できるのが重要だがその本質はここの遷移式一発で更新できるからなので。,9,9,,,とても理解できた。,
12/16/2022 21:24:52,2,12,21,一点更新区間minのセグ木の問題であるが、一点更新がlogオーダーでできる本質の行だと考えたので、ここにした。,4,4,,29,区間minをlogオーダーで求めることができる本質の行であるから。更新できることが重要ポイントであると感じたので2番目にした。,4,4,,14,セグ木の処理の初期化を行なっている部分であるので、これもクエリ処理に次いで重要だと考えた。,6,6,,,まあ理解できた。,
12/17/2022 23:06:36,8,12,29,セグメント木の性質を生かして、最小値を求める再帰アルゴリズムを作成しているから。,5,5,,14,セグメント木を使うというのは、この問題を解く上での本質であり、その木の構築の主要な部分だから。答えを出すところそのものではないので、2番とした。,2,2,,21,セグメント木の性質を利用して、数字のアップデートを行った後の更新作業を行なっており、重要なところだから。1番2番に比べると基本的なことなので、3番とした。,9,9,,,まあ理解できた。,
12/20/2022 1:31:23,9,12,29,セグメント木において、区間の最小値の取得は左の区間と右の区間の最小値であることを再帰的に繰り返して求める、ということが重要であると考えており、29行目はまさしくそのことを述べているから。,5,5,,27,区間が丸ごと含まれている場合の、区間最小値の処理が述べられているから。これは左の区間と右の区間の最小値を再帰的に求めることが前提となっているため、1番ではないと考えた。,12,12,,21,セグメント木における一点更新の処理が述べられている行であるから。一点更新の処理は区間の最小値を求める処理ほどは重要でないと考えているため、1番や2番ではないと考えている。,9,9,,7行目。区間最小値を求めるセグメント木では初期値をinfにするのが大切であるから。,とても理解できた。,
12/21/2022 13:50:13,4,12,29,セグメント木の性質をつかって再起的に探索の関数を呼び出しているため。,5,5,,21,木を更新する本質的な処理をしているため。1番に比べると複雑な処理はしていない。,9,9,,14,セグメント木の性質を使って木を表すリストを埋めているため。ただ答えに直接つながる処理ではない。,9,9,,,まあ理解できた。,
12/28/2022 16:53:53,5,12,37,Q2同様、SegmentTreeを使うこと自体がもっとも重要であると考えた。,2,2,,7,SegmentTreeを使うことが最重要な前提であるとした上で、この問題のコードを書く上で気をつけるべき点として、初期化する際に演算minの単位元であるinfや最大の数である2^31-1で埋めている点がある。単にゼロ埋め、と覚えるのではなく、単位元を利用することを強調するという意味で、7行目が重要であると考えた。,6,6,,39,7行目と同様、初期化のための数が2^31-1という巨大数であることを意識する必要があると考えたから。厳密には単位元ではないため、infよりは重要性が低いと感じた。,6,6,,,まあ理解できた。,
12/30/2022 20:22:32,10,12,21,updateで親をたどりながら更新していることがとても重要だと思ったため。,9,9,,29,最小値を取得する関数を、再帰を使って実装しているのもupdateの次にするべきこととして重要だと思いました。,5,5,,44,1番や2番の次に、updateとfindを呼び出している部分が問題を解く上で重要だと思いました。,2,13,×,,あまり理解できなかった。,
1/3/2023 6:10:13,11,12,20,このデータ構造において，2で割っていくことで高速に最小値を更新できることが最大の強みだと思います．,4,4,,7,セグ木の初期状態を最小が問題になっているのに合わせてinfでつくっている.長さが2^n-1のリストという点でも大事だと思います．どう更新するかの方がこの問題に特有だと感じたから2番目です．,6,6,,29,探索の方法として，このような範囲を絞っていく再帰の関数をつくるのは重要だと感じます．2で割っていく箇所は1番目で触れたのでその要素を抜いて考えた時に3番目くらいの重要さかなとおもいました．,5,5,,,とても理解できた。,
12/8/2022 23:52:05,1,13,27,重みの小さい辺から貪欲に見るというクラスカル法の重要な部分が表現されていると考えたため．,10,10,,32,注目している辺の両端の頂点が既に連結かどうかを確認する部分であり，クラスカル法の実装において中心的な部分であると考えた．一方で重みの小さい辺から見ることが発想として重要であると考え，2番目とした．,8,8,,3,UnionFindTreeの実装する上で，自分の親頂点をメモしておくという部分が発想として最も大切だと考えた．一方でこの問題の中心となるアルゴリズムはクラスカル法なので，3番目として選択した．,9,9,,,とても理解できた。,
12/14/2022 14:58:03,6,13,27,辺の重みに関する貪欲法であることがクラスカル法の本質である。,14,14,,32,辺を採用することでループが発生しない場合のみ採用することを表す行である。1 番と比べると詳細にあたる。,8,8,,34,辺を採用することでループが発生しない場合のみ採用、を実現するために集合の併合を行う部分。2 番に対して従たる部分だと言える。,11,11,,,とても理解できた。,
12/15/2022 0:59:12,7,13,45,この問題の解法ではクラスカル法を用いるということがこの一行で分かるから．,2,2,,27,"クラスカル法では辺の重みの小さい順に取り出すことで最小全域木を求めることができるということがこの行で分かるから．
1番でない理由は，クラスカル法の解法を知っている人であれば分かることであるから．",10,10,,28,"クラスカル法の中ではUnionTreeを用いながら同じ集団に属しているかどうかを判断できるということが分かるから．
3番である理由は，最小全域木を求めることに直接関係するわけではなく，どのように取り出した辺がすでに同じ集合に属しているわけではないということを判定するかということを表しているから．",8,8,,,まあ理解できた。,
12/15/2022 19:33:39,3,13,45,この問題のコアはクラスカル法で最小全域木が構築できることなので。,2,2,,34,クラスカル法のコアはDSUを使えば最小全域木を構築できることなので。,14,14,,19,DSUのコアはここのマージテクだと減価償却で計算量が減ることなので。,4,4,,,とても理解できた。,
12/16/2022 21:32:42,2,13,27,クラスカル法は連結かどうかで辺を追加するかどうかを決めるので、その連結判定の部分が最重要であると考えた。,8,8,,32,クラスカル法は事前に辺のコストでソートしておくことで高速に求められるので、これが次に重要。,4,4,,34,上と同様に連結判定を高速に行うためにUnion-Find木のmergeを行っている部分なので、重要であると考えた。判定そのものではなく判定のための操作なので3番目。,11,11,,,とても理解できた。,
12/18/2022 0:59:07,8,13,32,クラスカル法において、UnionFind木で閉路ができているかどうかの判定をしている重要なところだから。,8,8,,17,UnionFind木において、rootが違った場合にuniteするという重要な処理をしているところだから。問題解決に直接関わるところではないので2番とした。,11,11,,8,再帰を用いて、親を辿るというUnionFind木の重要な性質を記述しているところだから。問題解決に直接関わらず、難しくもないので3番とした。,10,10,,,まあ理解できた。,
12/20/2022 1:40:29,9,13,34,最小全域木を求めるには、採用する辺を用いてグラフを連結する、という処理が最も大切であると考えているから。,11,11,,32,その辺を採用するかどうかの処理は、その2点が連結ではないということを述べている行であるから。グラフの連結を行うことが前提となっているため、1番ではないと考えた。,8,8,,27,最小全域木を求める前段階の処理として、辺の長さでソートする、ということをしないと正しい結果を返さないから。実際に木を作る部分ではないため、この部分の処理は1番や2番ではないと考えた。,14,14,,"18, 22, 23行目。Union Find 木の計算量を落とすための工夫として、木にランクをつけていることを表す行であり、ここを間違えたとしても正しく動かないことはないものの、計算量が大きく落ちてしまうから。",とても理解できた。,
12/21/2022 14:08:44,4,13,27,クラスカル法で最も重要な、辺を重みの小さい順に並べるという処理を行なっているため。,14,14,,8,Union-Find木で重要である、rootを探すという処理の大事な部分だから。ただ、答えに直接つながるわけではない。,10,10,,19,Union-Find木で重要な「親」を更新しているため。処理内容としてはかなり単純。,9,9,,,まあ理解できた。,
12/28/2022 17:13:42,5,13,27,最小全域木の問題は、貪欲法で解くことができることが本質的な部分だと考えている。したがって、コストについてグラフをソートしている27行目が最も大切だと考えた。,14,14,,32,ソートされた辺について、どのような条件で選んでいるかを知ることができるため重要だと考えた。しかし、貪欲法ということがわかればある程度推測可能であるため2番目においた。,8,8,,12,"UnionFind関数について、唯一外部から呼び出されている関数であるため重要だと考えた。
UnionFIndについての知識があまりなくても、is_sameという命名がされているため起こっていることの想像がし易いと考えた。したがって、UnionFind内部の実装よりもそれを呼び出すkruskal関数のほうが重要だと考えたため、3番目においた。",13,13,,43:27行目のG.sort()で、どのようにソートされているのか直感的には分かりづらいため、tupleのリストであることを知ることができ重要だと考えた。,とても理解できた。,
12/30/2022 20:34:53,10,13,32,閉路を作らないことを確認することがクラスカル法で、最も重要であると思ったため。,8,8,,14,二つの木構造をまとめる実装は、unionfindにおいてとても重要であるから、2番目に重要であると思った。1番の方が、クラスカル法のアルゴリズムで気にするところだと思った。,11,11,,8,木構造の根を探すことは、使われていないがunionfindにおいてとても重要であるから、3番目に重要であると思った。,10,10,,,まあ理解できた。,
1/3/2023 6:22:25,11,13,27,重さの小さい辺から取っていけば，最小全域木ができるのは重要な事実だと思います．,10,10,,32,Unionfindですでにつながっているかを判断している大事な箇所であるとおもいます．つながっているかのあくまで道具としてつかっているので2番目にしました．,8,8,,4,rankをもつことでunionfindの構造を工夫して高速な処理をできる．unionfindのさらに細かい中身の話なので3番目にしました．,4,4,,,とても理解できた。,
12/10/2022 13:26:41,1,14,5,ソートしたい配列を，2つの配列に分割してソートした結果を利用してソートすることを繰り返すというマージソートの肝となる考え方が表されている部分だと考え1番目とした．,14,14,,6,ソートしたい配列を，2つの配列に分割してソートした結果を利用してソートすることを繰り返すというマージソートの肝となる考え方が表されている部分だと考えて選択した．1番目と同等の理由だが便宜上2番目とした．,14,14,,11,ソート済の配列2つを使用し，2つの配列を左から見て各要素を比較することでソート済の大きい配列を得るという考え方が表されていると考えたため．配列をより小さな配列に分割するという考え方の方が重要と考え，3番目とした．,8,8,,,とても理解できた。,
12/14/2022 15:16:54,6,14,11,それぞれソート済みの左列と右列から、どちらの先頭を答えの列に append するかを判定するという、ソートの根幹部分である。,8,8,,5,マージソートの再帰的構造が表れている部分である。ソート自体を行うわけではないので 1 番ではない。,5,5,,6,マージソートの再帰的構造が表れている部分である。2 番と同様に重要。,5,5,,,とても理解できた。,
12/15/2022 1:55:43,7,14,29,今回の解法ではマージソートとよばれるアルゴリズムを用いるということがこの行で分かるから．,2,2,,5,"マージソートは再起関数で小さい範囲から徐々に範囲を大きくしていくことで最終的に配列全体をソートできるということが分かるから．(6行目も同様だと思います．)
1番でない理由は，マージソートというアルゴリズムを知っていればどのようにそのアルゴリズムを実現できるかはわからることだから．",5,5,,11,"マージソートにおいて，二つに分けてソートした配列をどのように1つにマージするかをこの条件分岐で見ることができるから．
3番である理由は，マージソートのアルゴリズムの一部であり，このこと自体がすごく重要であるわけではないから．",8,8,,,まあ理解できた。,
12/15/2022 19:38:56,3,14,29,この問題のコアはマージソートを含めソートアルゴリズムで解けることなので。,2,2,,5,マージソートで重要なのは分割統治と尺取り法だが、分割統治の方が本質だと思ったから。,14,13,×,10,マージソートで重要なアルゴリズムである尺取り法の実装はこの内部だから。,14,13,×,6: 5行目と同様。,とても理解できた。,
12/16/2022 21:49:32,2,14,5,配列を左右に分けてsortしてmergeするのがマージソートだが、左右に分けている部分だから。,14,14,,6,配列を左右に分けてsortしてmergeするのがマージソートだが、左右に分けている部分だから。2番目に出てきたので2番目。,14,14,,11,ソート列をマージしている部分なので、これが次に重要だと考えた。,11,11,,,とても理解できた。,
12/18/2022 1:10:39,8,14,5,2分割したものを組み合わせて行ってソートするというマージソートのやり方をよく表している一文だから。,14,14,,11,マージソートにおいて、マージしていく順番を記述した重要な一文だから。1番の方がこのアルゴリズムをよく表していると思ったので2番にした。,14,14,,2,コーナーケースを記述するのも重要だから。あくまでコーナーケースなので3番にした。,3,3,,,まあ理解できた。,
12/20/2022 1:48:11,9,14,11,左の値と右の値を比較して、小さいほうを先に配列memに格納することを表しており、この部分が配列をソートできることの本質であるから。,11,11,,5,マージソートが再帰的に左半分の要素と右半分の要素を呼び出していることを表す行であるから。配列をソートできることの本質部分ではないため、この部分は1番ではないと考えている。,5,5,,10,左右どちらかの要素がなくなったら処理を終えることを表している行であるから。実装上の問題であり、アルゴリズムの本質部分とは言いにくい部分なので、この順位と考えている。,7,7,,"6行目：5行目と同じく、再帰的に求めることを表しているので、重要だと考えている。
18～21行目：左右どちらかの要素がなくなった場合、なくなっていない方の要素の残りを入れることを表しているため、重要だと考えている。",とても理解できた。,
12/21/2022 14:21:40,4,14,10,マージソートで適切な順番に並べていくための繰り返し処理だから。,14,14,,5,マージソートの特徴である、まず半分、半分を分けていく処理を行なっているため。ただ、処理としては半分にして再起的に呼び出しているだけ。,14,14,,18,残りの部分を「答え」に加える処理をしているため。ただマージソートの本質ではない。,14,14,,,とても理解できた。,
12/28/2022 17:19:41,5,14,12,マージソートで実際にマージしている部分であり、15行目とともに最重要だと考えた。,11,11,,15,マージソートで実際にマージしている部分であり、12行目とともに最重要だと考えた。あとの方に登場していること、else節の中であるため、12行目のほうが重要ということにした。,11,11,,5,マージ処理を理解するためには、2つの配列がソート済みであることを理解している必要がある。そのため、上記2つの行の補助的な役割として5行目が重要であると考えた。,14,14,,"6: 5行目と同様の理由。
18 ~ 21:計算量を減らすための工夫であり、本質的ではないが必要。",まあ理解できた。,
12/30/2022 20:44:25,10,14,5,2つに分割して再帰でマージソートすることが大切であると思ったため。,5,5,,11,1番ができた上で、小さい方から順に入れていくことが2番目に重要であると思ったため。,11,11,,18,1番2番ができた上で、余った要素をくっつけることが大切だと思ったため。,11,11,,,まあ理解できた。,
1/3/2023 6:28:24,11,14,5,リストを分けてそれぞれでソートするという考えが表れているように感じたから．,14,14,,11,それぞれのリストを見て大小を比較していることがわかる行だから．分けて比べる再帰をしている方がより重要だとおもったので2番目です．,8,8,,18,2つのリストを比べた時にどちらかは最後まで見れてないので，その分の処理が必要だとわかる箇所．後処理的な位置付けだと思うので3番目に選びました．,8,8,,,とても理解できた。,
12/9/2022 0:03:09,1,15,5,全ての辺を用いて経路更新を行う操作を頂点の数(-1)回行うことで最短経路を求めるというベルマンフォード法の重要な考え方が表されていると考えたため．,10,10,,6,全ての辺を用いて経路更新を行う操作を頂点の数(-1)回行うことで最短経路を求めるというベルマンフォード法の重要な考え方が表されていると考えたため選択した．一方で，頂点の数-1回の更新で済むという部分は1番目で表されているため，こちらは2番目とした．,10,10,,9,"負の閉路がなければ，最短経路の更新はV-1回で終了することを用いて負の閉路を検出する箇所であり，負の閉路があるような設定では重要だと考えた．最短経路を求めるという点において1,2番目の方がより重要と考え，3番目とした．",8,8,,,とても理解できた。,
12/14/2022 15:32:16,6,15,8,最短距離の更新を実際に行っている部分であり、ベルマンフォード法の根幹。,9,9,,7,最短距離の更新条件が示されている行であり、1 番に対し従たる部分である。,8,8,,5,高々頂点数回分のループで距離の更新が完了することを示す、プログラムの停止性に関わる部分。1 番、2 番ほどは直接答えに関係しない。,7,7,,,とても理解できた。,
12/15/2022 2:01:12,7,15,23,この問題を解くために，ベルマンフォード法と呼ばれるアルゴリズムを用いれば良いということがこの行から読み取れるから．,2,2,,7,"ループの中でどのような条件を満たせば値の更新を行なっていくのかということがこの行で現れているから．
1番でない理由としては，これはベルマンフォード法の一部分であり，この部分だけからではアルゴリズム全体を把握できるわけではないから．",8,8,,9,"どのように負の経路を見つけるかということがこの条件文に書かれているから．
3番である理由は，負の経路があることは例外的なものであり，問題全体的に関係する部分ではないから．",8,8,,,まあ理解できた。,
12/15/2022 19:57:57,3,15,23,この問題のコアは、厳密にいえば単一始点でちょっと手を加えて解けることなので。,2,2,,5,ベルマンフォードの本質は探索順序だと思うが、ここの中継点でループを回すところで、扱うノードによる集合を大きくしていっているから。,10,10,,8,ベルマンフォード法で実際に遷移を行っている部分がここだから。,9,9,,,とても理解できた。,
12/16/2022 22:01:07,2,15,7,ぐるぐる回して最短距離が更新できるなら更新する、というアルゴリズムなので、距離更新できるかを見ている行が重要だと考えた。,8,8,,9,V回ぐるぐる回しても最短距離の更新が起こる場合は負のサイクルがあるという意味なので、その検出を行っている行が次に重要であると考えた。,8,8,,6,ぐるぐる回す部分でグラフの辺を全部見ている部分なので、直接的ではないが、残りの行の中では一番重要だと考えた。,10,10,,,とても理解できた。,
12/18/2022 1:29:31,8,15,8,ベルマンフォード法で距離の更新を行なっている重要な記述だから。,9,9,,9,負の値を持つ閉路ができているときに検知するという大事なところだから。必ずしも使われるところではないので2番とした。,8,8,,2,距離を十分に大きな値で初期化しておくのはベルマンフォード法を実行するにあたって重要だから。アルゴリズムの本質ではないので3番にした。,6,6,,,とても理解できた。,
12/20/2022 1:53:01,9,15,8,最短経路を更新する行であり、ここがないと最短経路が更新されず、アルゴリズムが全く動作しないから。,9,9,,7,最短経路の更新条件を表す行であり、条件を間違えると正しく動作しないから。最短経路の更新の操作を直接行う行ではないため、重要度は2番目と考えている。,8,8,,9,負閉路検出条件を表している行であるから。負閉路は検出が行われない場合もあるため、前2つに比べると重要度は下がると考えている。,8,8,,,とても理解できた。,
12/21/2022 14:35:06,4,15,8,距離を更新できれば更新するというベルマンフォード法の本質的な処理だから。,9,9,,9,NEGATIVE CYCLEの検出をこの条件で行えるのがベルマンフォード法の大事なところだから。ただ最短経路というところには関係ない。,8,8,,14,辿り着けないとき判定と処理も大事だから。ただ、処理は単純である。,8,8,,,とても理解できた。,
12/28/2022 17:29:26,5,15,5,Dijkstra法やBFSなどとベルマンフォード法との大きな差異は、V回のループを回すことだと考えているため、この部分が最も如実に現れた5行目が最重要だと考えた。,10,10,,9,この問題では、負の閉路検出のためにベルマンフォード法を採用している。したがって、「i回目のループで頂点の更新が起きた」という条件を表している9行目が2番目に重要だと考えた。最重要としなかったのは、9行目の把握のためにはV回ループを回すことを理解している必要があるため。,8,8,,7,メモの更新という基本的なテクニックであるため上2つと比較して重要性は低いが、最短距離の更新がどのように行われているのかは重要だと考えた。,9,9,,,とても理解できた。,
12/30/2022 21:03:04,10,15,9,ベルマン・フォード法において負の閉路の検知することがとても重要だと思ったため。,8,8,,8,1番に気をつけた上で、全ての辺に対してdistの更新を行う部分が、重要だと思った,9,9,,6,1番2番に気をつけた上で、ダイクストラと違い、全ての辺に対しての計算を毎回行うことが重要だと思った。,12,12,,,まあ理解できた。,
1/3/2023 6:38:04,11,15,7,その辺を選んだ時両端のノードの情報がどう変わるかという，辺の重みの更新方針がわかる一行だと思えるからです．,8,8,,5,全てのノードを出発点にして同じ操作をするということが表れている箇所だから．ノードの情報が書き変わる部分の方がなんとなく重要に感じてしまいました．,14,14,,9,負閉路がないか確認できる嬉しい箇所であるから．最短経路検出できない->負閉路という順序であり，主役は最短経路の方だと感じるので3番目です．,8,8,,,とても理解できた。,
12/12/2022 2:24:16,1,16,2,注目している要素を，既にソートされた配列のどこに入れるかを決定することを繰り返し，最終的に全ての要素をソートするというアルゴリズムの考え方を表現していると考えたため．,14,14,,5,"要素を入れ替えるための条件を定義した部分であり，ミスが起こりやすいと考え選択した．
1番目の行の方がアルゴリズムの全体像を捉えていると考えて2番目とした．",3,3,,8,注目している要素の挿入位置が決定される部分であるため選択した．ロジックとしては平易であるため3番目とした．,14,14,,,とても理解できた。,
12/14/2022 15:42:20,6,16,8,実際に配列の更新を行うことでソートを実現している部分である。,9,9,,5,tmp 以下の要素が現れない限り、という j を更新し続ける条件を表す、ソートの挙動を端的に示す部分である。1 番に対して従たる部分。,8,8,,6,要素を一つずつ右にずらしていくという、これもソートの挙動を端的に示す部分。1 番や 2 番に対して従たる部分。,9,9,,,とても理解できた。,
12/15/2022 8:41:24,7,16,15,この問題の解法では，挿入ソートとよばれるアルゴリズムを利用すれば良いということがこの一行で分かるから．,2,2,,5,"挿入ソートアルゴリズムでは，配列の要素を自分より左側の数字に自分より大きい数がないように要素を挿入していくことをこの文の条件で表しているから．
1番でない理由としては，挿入ソートアルゴリズムを知っている場合はこの操作を行う必要があることを理解できるから．",8,8,,2,"一番先頭の要素から順に見ていくことで配列全体をソートできるため，どのようにループを回すのかということは重要だと思ったから．
2番ではない理由は，挿入操作自体の方がソートにおいて重要だったと思ったから．",10,10,,,まあ理解できた。,
12/15/2022 20:17:08,3,16,15,挿入ソートが良いアルゴリズムかは置いておいてこの解き方においては挿入ソートを使っていることがコアだから。,2,2,,5,挿入ソートは要は一つずつ要素がどこに入れるのが適切なところか探すアルゴリズムなので比較探索箇所が重要だと考えた。,10,10,,8,ホントにしいて言えばだが、最後にそこのインデックスの値を確定させるところなので。,9,9,,,とても理解できた。,
12/16/2022 22:10:45,2,16,5,挿入ソートは配列を前から見ていってハマるところに挿入するアルゴリズムだが、ハマるところを探している行なので、最重要であると考えた。,10,10,,6,挿入するためにいままで完成させた部分を後ろにずらしている部分なので、ここが次に重要であると考えた。,9,9,,4,挿入する前に後ろに要素をずらしていくので、挿入する要素を覚えていかないといけないので、これも重要。サブ的な理由なので3番目。,9,9,,,とても理解できた。,
12/18/2022 1:45:33,8,16,5,挿入ソートで、選んだ一つの値を挿入する場所を探すための大事な処理だから。,10,10,,6,挿入するスペースを空けるために一つずつずらしていくというのも大事な処理だから。ループそのものの方が重要なので2番とした。,9,9,,4,動かすものをtmpとしておいておかないと書き換わって使えなくなってしまうので、プログラムを書く上では大切。アルゴリズムの本質ではないので3番とした。,1,1,,,まあ理解できた。,
12/20/2022 2:00:32,9,16,5,挿入ソートにおいて、選んだ要素をどこに挿入するべきかの条件を表す行であるから。左が右より大きい間はカーソルを左にずらすというのが、ソートアルゴリズムの本質部分であるため、一番重要と考えている。,8,8,,6,実際に数列の値をひとつずつずらしている処理を表しているから。前の条件を受けて、それに応じてずらす処理を行っているので、1番目ではないと考えている。,9,9,,8,最後に、最初に選んだ値を実際に挿入する箇所を表しており、ここが間違っていると正しく動作しないから。先ほどの2つに比べると本質ではないため、この部分は1番目や2番目ではないと考えている。,9,9,,,とても理解できた。,
12/21/2022 14:45:05,4,16,5,挿入する場所を探すという挿入ソートで最も重要な判定があるから。,8,8,,8,適切な場所に挿入するという処理をしているため。ただ代入しているだけだから。,9,9,,6,挿入場所の探索の段階で必要な、ずらす処理を行なっているため。必要な処理ではあるが、挿入ソートの本質からは少し離れている。,9,9,,,とても理解できた。,
12/28/2022 17:38:32,5,16,6,挿入ソートという名前に反し、要素の挿入をswapの連続で実装しているため、理解に時間がかかり、最重要だと考えた。,9,9,,4,6行目を含むwhile文を読解しているときに、tmpという数値が更新されないことを理解するため、定義文が6行目の次に重要だと考えた。,14,14,,3,while文の中で、1度目の処理でarr[i]がswapの対象になるようになっている。これはコードを良く読まないとわからず、この手がかりが3行目にあるため3番目に重要だと考えた。,13,13,,,とても理解できた。,
12/30/2022 21:09:26,10,16,6,tmpより大きい部分を後ろにずらすことは挿入ソートにおいて、最も重要であると思ったため。,9,9,,8,1番に気をつけた上で、止まったところで退避させた値を戻すことが、2番目に重要だと思ったため。,9,9,,4,1番や2番と比べて、容易だが、一旦別の場所に退避させることが重要であると思った。,14,14,,,まあ理解できた。,
1/3/2023 6:47:11,11,16,6,挿入することで，一つずつ横にずれていくことがわかる行であるから．,9,9,,5,一つ後ろ倒しにしていく条件が定められている箇所だから．実際に操作をしているほうが重要に感じたので2番目にしました．,8,8,,2,前から一つずつみていくことがわかる一行だと思います．どっち方向から見ていくかはあまり大事でないので，3番目にしました．,10,10,,,とても理解できた。,
12/10/2022 13:15:10,1,17,21,現在到達している頂点の中で距離が最も小さい頂点の距離を確定して良いというダイクストラ法の考え方の根本となる部分が記載されているため．,14,14,,10,全ての頂点を見ることで現在到達している頂点の中で距離が最小となるものを見つけるという考え方を最もよく表していると考え選択した．1番目のようにダイクストラ法のアルゴリズムの最重要な部分ではないと考え，2番とした．,10,10,,9,全ての頂点を見ることで現在到達している頂点の中で距離が最小となるものを見つけるという考え方を最もよく表していると考え選択した．2番目の方がこの考え方をより端的に表していると考えて3番目とした．,10,10,,,とても理解できた。,
12/14/2022 15:52:30,6,17,19,最短距離の更新を実際に行う、ダイクストラ法の根幹をなす部分。,9,9,,18,最短距離を更新する条件を示している、1 番に対して従たる部分。,8,8,,11,次に最短距離を確定させる頂点を選ぶにあたり、暫定距離が最小となるものを選べば良いことを表す部分。ダイクストラ法の詳細部分にあたる。,14,14,,,とても理解できた。,
12/15/2022 14:37:13,7,17,33,この問題の解法ではダイクストラ法を使うということが分かり，アルゴリズム名を知っている人であれば，ここからどのように解くことができるのか考えることができるから．,2,2,,10,"ダイクストラ法において，次に更新していく元となる頂点は，まだ見ていない頂点でかつコストが最小である頂点であるということがこの行で分かるから．
1番でない理由は，これはダイクストラ法の具体的な中身であり，ここからアルゴリズム全体が分かるというわけではないから．",8,8,,18,"ダイクストラ法において，見つけた最小コストを持つ頂点を起点にその周りの頂点のコストを更新していくという操作のための条件がこの行で示されているから．
3番である理由は，2番での頂点を見つける操作を経た上でこの操作を行うから．",8,8,,,まあ理解できた。,
12/15/2022 20:23:38,3,17,33,この問題のコアはダイクストラ法を使えば解くことが出来る、ということなので。,2,2,,19,優先度つきQueも使っていないので大分苦しい実装だがしいて言えばここの比較後の遷移は大事かもしれない。,14,14,,14,このダイクストラだと終了条件がないと止まらないため、ここの式は実は大事かもしれない。,7,7,,,とても理解できた。,
12/16/2022 22:16:41,2,17,11,ダイクストラ法のキモは、最短距離が順々に確定させるところなので、その確定した部分を見つけ出す部分が最重要であると考えた。,10,10,,18,最短距離が更新できるところがあれば更新していくのはダイクストラ法でもあいかわらず重要な位置を占めていると思う。キモは上のやつだと思うので、これは2番目。,9,9,,21,使用済みの距離が確定した頂点はマーキングしておかないとtmp_min_distを決める際に困るので、アルゴリズムの中心部分ではないが、これが3番目であると考えた。,9,9,,,とても理解できた。,
12/18/2022 2:22:32,8,17,17,ダイクストラ法の処理の手順がよく表れているwhileループだから。,13,13,,21,一度巡回したところには戻ってこないというアルゴリズムの特徴がよく出ているから。最重要の処理ではないので2番にした。,10,10,,2,距離を十分に大きな値で初期化しておくのはダイクストラ法の実行において重要だと思ったから。あくまで初期化なので3番にした。,6,6,,,とても理解できた。,
12/20/2022 2:07:20,9,17,19,最短経路の更新を行っている行であるから。ここが動かないと正しく動作しないため、最短経路を求めるアルゴリズムではここが最も重要と考えている。,9,9,,12,次に選ぶ頂点を決めている行であり、ここが動作していないと次に選ぶ頂点がわからないから。直接最短経路の更新をする行ではないため、あくまで1番ではないと考えている。,9,9,,10,次に選ぶ頂点を決める際の条件を決めている行であり、ここが動作していないと次に選ぶ頂点がわからないまま処理が終わらないことになりかねないから。実際に頂点を決めているわけではないので、あくまで2番目よりは重要度は落ちると考えている。,8,8,,"2行目。初期値を設定している行であり、ここを間違えると正しく動作しないから。
4行目。既に見たかどうかの配列を確保している行であり、これを行わないとプログラムが終わらないから。",とても理解できた。,
12/21/2022 14:57:48,4,17,18,あるノードまでの距離をこの条件文を使って更新する。この方法がダイクストラ法の本質だから。,9,9,,10,1番の処理で使うcurを更新するのに必要な条件文だから。あくまで1番の処理のための道具。,8,8,,4,更新を終えたノードを保存するリストは必要だから。ただここではリストを用意しているだけ。,6,6,,,まあ理解できた。,
12/28/2022 19:33:24,5,17,10,結果的にdone[i]がFalseでありdist[i]が最小であるものをtmp_min_distとcurに代入していることが、この行をよく読まないと分からないと感じたから。,9,9,,17,Djikstra法の本質である、もっとも距離の近い頂点から行ける頂点を全走査する考え方が表現されているから。1番ではないと判断した理由は、Djikstra法の概要を知っていれば読解の必要がなく内容を想像できる点。,10,10,,31,特殊な入力方法を受け取るための実装であり、上位2つの行と違って直接解法には関わらないが、読解の必要があると考えたから。,1,1,,,あまり理解できなかった。,
12/30/2022 21:28:35,10,17,19,距離を短く出来る場合は更新することが最も重要だと思いました。,9,9,,10,1番に気をつけた上で、現在までで最短距離を持つ未確定のノードを取り出すことが重要だと思ったため。,11,11,,21,1番2番に気をつけた上で、done[cur]をTrueにし忘れないようにすることが重要だと思った。,3,3,,,まあ理解できた。,
1/3/2023 6:57:03,11,17,10,次に確定させるノードを決める時に，未確定かつ最短でいけるところを選ぶという方針がアルゴリズムにおいて大事な点だと感じました．,10,10,,19,辺の重みを更新している箇所なので重要に感じました．ダイクストラならでは操作というわけではないので2番目にしました．,9,9,,21,距離が確定したところを保持しておかないと次のノードが決められないから．アルゴリズムの探索手法に付随する処理感が強いため3番目です．,9,9,,,とても理解できた。,
12/12/2022 12:12:55,1,18,11,特定の間隔で配列を見ることを表しており，シェルソートの考え方の重要な部分だと考えたため．,10,10,,14,挿入ソートを行うことを端的に表しており，1番目と合わせてシェルソートの考え方を表していると考えたため．配列を特定の間隔で飛ばしながら見るという考え方の方が重要だと考えて2番目に選択した．,14,14,,18,"間隔を狭めていくことを表しているおり，1,2番目と合わせてシェルソートの考え方を表していると考えて選択した．挿入ソートを間隔を開けて行うという考え方に比べれば重要度は低いと考えて3番目とした．",14,14,,,とても理解できた。,
12/14/2022 16:15:51,6,18,18,シェルソートにおける、列全体の分割数 h を徐々に減らしていくという特徴を端的に表している。,14,14,,10,h 個に分割された列の何番目を対象とするか、というイテレーションであり、h の変化に影響を受ける部分。,10,10,,11,列の分割方法が、index mod h ごとであることがわかる部分。2 番目と同等程度に重要。,14,14,,,とても理解できた。,
12/15/2022 14:57:09,7,18,26,この問題の解法では，シェルソートと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,2,2,,18,"シェルソートでは，間隔hを徐々に小さくしながらソートを行なっていくことで可能なアルゴリズムであり，そこが一番特徴的な部分であると思ったから．
1番ではない理由としては，この部分だけではシェルソートでどのようにソートを行うのかの全体は把握できないから．",14,14,,14,"間隔hごとに自分より左側に自分より小さい数がないようにソートしていくことでソートが可能であることについて，この条件式で行っているから．
3番である理由は，この部分は挿入ソートなど他のアルゴリズムでも行うものであり，シェルソート特有のものというわけではないから．",8,8,,,まあ理解できた。,
12/15/2022 20:29:01,3,18,26,このとき方のコアはシェルソートをソートアルゴリズムとして採用していることなので。,2,2,,5,シェルソートはソート間隔を変える、挿入ソートの改良版だが、ここのソート間隔の取り方が一番重要なので。,14,14,,18,シェルソートは間隔を変えながら行うのが重要なアルゴリズムであるから。,14,14,,,とても理解できた。,
12/16/2022 22:23:22,2,18,18,シェルソートは挿入ソートの間隔をちょっとずつ狭めていくものなので、その間隔を狭めていっている部分が最重要であると考えた。,14,14,,9,シェルソートは挿入ソートの幅が1になるまでやるので、その終了条件を書いている場所が狭める行に次いで重要であると考えた。,7,7,,4,最初の挿入ソートの幅はなるべく広くとりたいので、これが甘くてもアルゴリズムは動くので重要度は下がるが、3番目には重要であると考えた。,14,14,,,とても理解できた。,
12/18/2022 2:35:18,8,18,11,間隔hで配列を分割し、ソートしていくというシェルソートの方法がよく表れた一文だから。,14,14,,5,hの決め方がいろいろある中で、どれを採用したのかを表しているから。アルゴリズムそのものではないので2番にした。,14,13,×,17,ソートするための値の入れ替えを行なっていて、ソートのアルゴリズムをよく表しているから。シェルソート特有のものではないので3番にした。,9,9,,,まあ理解できた。,
12/20/2022 12:23:19,9,18,5,シェルソートにおける、hを決めている箇所であり、ソートの間隔を設定するというシェルソート特有の処理を決めている箇所であるから。,14,14,,18,シェルソートにおいて、間隔を狭めている箇所であるから。間隔を決めた上でその後で狭めているため、間隔を決めている行ほどは大事ではないと考えている。,14,14,,14,シェルソートにおいて、挿入ソートと同じようにデータの大小に応じて入れ替えを行っている箇所であるから。挿入ソートと同じ箇所ではあるため、1番重要というわけではないと考えている。,9,9,,,まあ理解できた。,
12/21/2022 15:05:21,4,18,11,hおきにリストを見て、並べ替えるという繰り返しがシェルソートの本質だから。,14,14,,18,hを更新しながらソートしていくというのがシェルソートでは重要だから。ただ処理としては単純。,14,14,,5,適切なhを決める部分。これはソートの効率に関わるため。ただある程度適当でもソートはできる。,14,4,×,,まあ理解できた。,
12/28/2022 19:54:47,5,18,15,14行目とあわせ、シェルソートが挿入ソートと類似であるという点を確認できるという意味で重要だと考えた。また、差分がhであることも理解できるためもっとも重要とした。,14,14,,14,15行目と同様にシェルソートとの類似性がわかるが、hについての言及がなくシェルソートと全く同じ実装であるため2番めに重要だと考えた。,14,14,,18,シェルソートの本質である、間隔を狭めながらソートしていくという部分を表現していて、重要だと考えた。ただし、読解というより見れば分かる部分であるため、3番めに重要とした。,14,14,,,まあ理解できた。,
12/30/2022 21:59:08,10,18,16,16行目により前に戻って比較するようにして、間隔ごとに挿入ソートをしていて、重要であると感じた。,14,14,,5,シェルソートは、間隔の決め方も重要であるので、2番目に重要であると思った。,14,14,,18,基本的だが、h//3を忘れないことが大切なので、3番に重要であると思った。,3,3,,,まあ理解できた。,
1/3/2023 7:06:31,11,18,16,シェルソートで，間隔がhでソートしていることがわかる一行だから．,14,14,,14,挿入ソートと同じようにソートをやっているのがわかるから．シェルソートの特色は間隔をあけることなので2番目です．,14,14,,5,hの幅を決めている箇所だから．hの幅の決めかたは様々にあるので，3番目の重要度にしました．,14,14,,,とても理解できた。,
12/12/2022 2:31:28,1,19,21,ハッシュの更新式を表しており，このように前のハッシュを利用して簡単に次のハッシュを計算できることがこのアルゴリズムを成り立たせていると考えたため．,9,9,,22,ハッシュ値の一致を用いて文字列を照合するという発想を表しており重要だと考え選択した．ハッシュの計算が高速に行えるという点の方が重要だと考え，2番目とした．,8,8,,16,今後ハッシュの計算に利用する変数をあらかじめ計算しており実装の工夫として大切だと考えたため．アルゴリズムの核というよりは実装の工夫にあたると考え3番目に選択した．,1,1,,,とても理解できた。,
12/15/2022 15:04:29,7,19,31,この問題ではラビンカープ文字列探索アルゴリズムを用いるということがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,2,2,,22,"文字列をハッシュにして，それが等しいかどうかを比較することで文字列の探索を行うということがこの行から分かるから．
1番でない理由は，この行だけではどのようにハッシュを形成するかなど全体的なアルゴリズムを把握することができないため．",8,8,,15,"ハッシュをどのように計算するのか，ハッシュの定義がここで分かるから．
3番目である理由は，2番目で挙げた，ハッシュを比較するという考え方の前提があった上でどのようにハッシュを計算するのかという考えの流れになると思ったから．",12,12,,21: どのように効率的に部分文字列のハッシュを計算するのかがこの行から分かるから．,まあ理解できた。,
12/15/2022 20:35:18,3,19,31,この問題のコアはラビン-カープ法、を使えば文字列の照合そのものがO(1)かつ前計算も（この問題では前計算そのものをループ憎んでいるが）線形に出来ることなので。,2,2,,14,15行目と合わせて、ラビン-カープ、というかローリングハッシュにも共通でハッシュ値をMODで求めて照合に使えることが重要だから。,8,8,,21,本来文字列の長さ分だけ計算が必要なハッシュ値計算をこのDPを使うことで計算量を圧縮できているから。,4,4,,15,とても理解できた。,
12/16/2022 14:47:14,6,19,21,T の部分文字列の Rolling Hash の値が、前の値からの差分でどのように得られるかを示している。,12,12,,14,t のハッシュ値の初期値を定義に従って計算する部分だから。1 番ほど非自明ではない。,12,12,,15,p のハッシュ値を定義に従って計算する部分だから。2 番のように初期値計算の意味合いがない。,12,12,,,とても理解できた。,
12/16/2022 22:37:59,2,19,22,ローリングハッシュは、それぞれの文字列に対してハッシュ値を計算してそれが一致していれば文字列が一致していると判定するアルゴリズムなので、一致判定をしている行が最重要だと考えた。,8,8,,21,文字列tのスタート地点をずらしたときのハッシュ値が高速に計算できることはアルゴリズムが高速に動くことにとてもよく貢献していると考える。ハッシュが文字列の一致判定に使えるというアイデアの方が中心であると感じたので、こっちが2番目。,4,4,,7,細かい部分なので3番目にしたが、文字列の長さで場合分けをしておかないと、13行目のハッシュの計算で配列概算症を起こして困ってしまうと思うので、これも重要。,8,8,,,とても理解できた。,
12/19/2022 4:41:55,8,19,14,ラビンカープ法で、ローリングハッシュを使うというのは肝の部分だから。,13,13,,22,ハッシュが一致していたら文字列が一致しているとみなす、というのは問題を解く上で大切だから。ハッシュの定義の方が大事なので2番とした。,2,2,,21,1番と同じく、ローリングハッシュの計算をしているところだから。内容的に重複しているので3番とした。,12,12,,,まあ理解できた。,
12/20/2022 12:26:30,9,19,21,ハッシュの更新を行う箇所であり、ここの更新がローリングハッシュで計算量を落とせる本質の箇所であるから。,4,9,×,14,ハッシュの値の初期値を設定する箇所であるから。計算量を落とす核心の部分ではないため、1番ではないと考えている。,6,6,,22,文字列の照合条件を、ハッシュの照合条件とみなして判定する箇所であるから。ハッシュの計算箇所ではないため、重要度は下がると考えている。,8,8,,,とても理解できた。,
12/21/2022 15:18:35,4,19,21,文字列のハッシュ値を効率的に更新するという複雑な処理を行なっているから。,9,9,,22,文字列の一致をハッシュ値によって確認するというのはラビンカープ法の本質だから。ただ、処理としては一致を確認しているだけ。,8,8,,14,ハッシュ値を求めることはラビンカープ法において重要だから。最初のハッシュ値を単純な方法で求めているだけだから。,12,12,,,まあ理解できた。,
12/28/2022 20:39:25,5,19,21,ローリングハッシュの基本的な式であり、最も本質的だと考えた。,13,13,,14,15行目とともに、ハッシュの具体的な計算方法がわかりやすく重要だと考えた。ただし、21行目とほぼ同じ処理であるため、1番ではないと考えた 。,12,12,,7,コーナーケースの処理であり、重要だと考えた。ただしローリングハッシュとは関係ない部分なので3番めに重要だとした。ｌ,3,3,,,とても理解できた。,
12/30/2022 22:35:13,10,19,21,しゃくとり法的な考えを用いており、最も重要であると考えたため。,14,14,,14,1番ほどの工夫ではないが、t_hashとp_hashを計算することが2番目に重要であると思った。,12,12,,16,1番2番に気をつけた上で、base_l_powerも剰余を取りながら、更新することが3番目に重要であると思った。,9,9,,,まあ理解できた。,
1/3/2023 7:19:06,11,19,14,文字列のハッシュをとることで同じ文字列かを比べるアルゴリズムの核だと感じたから．,8,8,,21,見る文字列をスライドしていくたびに，ハッシュの更新をしている箇所だから．,9,9,,1,基底を変数で持つと見やすくなるから．絶対に必要な工夫ではないので3番目にしました．,1,1,,,まあ理解できた。,
12/12/2022 12:33:28,1,20,12,最後にスワップが行われたところから，逆向きに走査を行うというシェーカーソートの考え方を最もよく表していると考えて選択した．,10,10,,18,最後にスワップが行われたところから，逆向きに走査を行うというシェーカーソートの考え方をよく表していると考えて選択した．1番目と同等の重要さだが，便宜上2番目とした．,10,10,,5,"最後に更新が行われた場所に着目するというシェーカーソートの考え方をよく表している行だと考えて選択した．1,2番目が表している考え方の方がより本質的と考えて3番目とした．",14,14,,,まあ理解できた。,
12/15/2022 15:14:06,7,20,25,この問題の解法では，シェーカーソートと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,2,2,,4,"シェーカーソートでは，右から，左からの2通りの方向からのソートを行い，徐々に左右の範囲を狭めていくことでより効率的にソートを行うものであり，この行で「左右の範囲を絞りながらソートと行っている」ということが読み取れると思うから．
1番でない理由としては，この行だけでは具体的にどのようにそれぞれをソートしているのかといった，アルゴリズム全体を把握するのに不十分であるから．",14,14,,9,"一回一回のソートアルゴリズムはバブルソートと同様に隣同士の要素を入れ替えていくということであるということがこの行で分かるから．(15行目も同様)
3番である理由は，この行の操作はシェーカーソート特有ではなく，バブルソートなどでも行うことであるから．",9,9,,,まあ理解できた。,
12/15/2022 20:38:26,3,20,25,このとき方のコアはソートアルゴリズムとしてシェーカーソートを使って解いていることだから。,2,2,,7,13行目と合わせて、ほとんどバブルソートと変わらない実装でも多少効率が良くなるのはここの探索順序を変更しているおかげだから。,10,10,,13,7行目と合わせて、ほとんどバブルソートと変わらない実装でも多少効率が良くなるのはここの探索順序を変更しているおかげだから。,10,10,,,とても理解できた。,
12/16/2022 14:58:27,6,20,4,左右それぞれにソート済みの範囲を持ち、これらが重ならない限り続けるという、シェーカーソートの特徴を表している。,14,14,,12,大きい要素を右に寄せる走査が一巡して、最後に交換が起こった箇所より右はソート済みであるという事実を使うことを示している。1 番よりは細かい性質に言及している。,14,14,,18,小さい要素を左に寄せる走査が一巡して、最後に交換が起こった箇所より左はソート済みであるという事実を使うことを示している。2 番と同様に重要。,14,14,,,とても理解できた。,
12/16/2022 22:26:32,2,20,7,シェーカーソートは左右にバブルソートをやるアルゴリズムで、幅が左右からどんどん狭まっていくのが特徴なので、右端をきちんと限定している行が最重要だと考えた。,14,14,,13,シェーカーソートは左右にバブルソートをやるアルゴリズムで、幅が左右からどんどん狭まっていくのが特徴なので、左端をきちんと限定している行が最重要だと考えた。こちらの方が後に出てきているので2番目。,14,14,,4,シェーカーソートの終了条件を表しており、上二つと比べると細かい部分だが、これを正確に指定しないと無限ループや微妙にソートされないなどがおこるので、3番目に重要だと感じた。,7,7,,,とても理解できた。,
12/19/2022 4:46:07,8,20,17,右から左に進むという、シェーカーソートがバブルソートと最も違う点が如実に表れている部分だから。,10,10,,12,ソート済みのところを再び通らなくていいようにするという、計算量を減らすための重要な記述だから。無かったとしても成立するので2番とした。,4,4,,9,順番を並び替えるための記述で、ソートには必要不可欠だから。基本的なところなので3番とした。,14,14,,,とても理解できた。,
12/20/2022 19:22:39,9,20,8,合っていない部分を入れ替えるために、大きさを比較する部分であり、ソートの本質部分であるから。,8,8,,12,カーソルを左から右に切り替える場面であり、なおかつカーソルの右端を左に動かすことでアルゴリズムの流れに大きく関わってくる場面であるから。実際に入れ替えを行う箇所ではないため、1番ではないと考えている。,14,14,,11,スワップする位置を1ずつずらしている箇所であるから。バブルソートでも行われ、シェーカーソート特有の処理ではないため、3番目と考えている。,9,9,,,まあ理解できた。,
12/21/2022 15:34:17,4,20,12,次にどこから見ていくかを決めるiにlastを使うというのがシェーカーソートの本質だから。,14,14,,10,1番の行で使うlastを決める行だから。ただ、lastを決めるだけでこの行自体が重要な処理をしているわけではない。,14,14,,8,lastの決定においても並べ替えにおいてもこの条件が重要だから。ただどんなソートでもこのような比較条件は現れるため。,8,8,,,とても理解できた。,
12/28/2022 20:48:53,5,20,9,ソートの中での本質的なSwapであるため、もっとも重要であると考えた。,9,9,,15,同じくSwapであるため重要だが、9のほうが先に出ているため2番めに重要だと考えた。,9,9,,12,"特殊な代入演算子を利用しているため、1,2番に置くほど重要ではないがある程度の重要性はあると考えた。",1,1,,,まあ理解できた。,
12/30/2022 22:49:02,10,20,13,シェーカーソートでは、両方向からバブルソートをすることが大切だと思ったため。,14,14,,14,1番方針に基づいて、後ろから比較するときは、大きい方が後ろに来るようにするのが重要だから。,8,8,,3,1、2番に気をつけて、rightを一番後ろで初期化することが重要だから。,6,6,,,まあ理解できた。,
1/3/2023 7:28:16,11,20,17,逆方向に走査していることがわかるから．バブルソートとの違いが大事だと考えました．,10,10,,14,大小を連続する2つの要素間で比べていることがわかるから．バブルソートでも同じことをしているので2番目にしました．,8,8,,12,調べる範囲を狭めていることがわかるから．ここは本質というよりは工夫に近いと思ったから3番目です．,1,1,,,まあ理解できた。,
12/10/2022 13:20:43,1,21,22,この問題をスタックを用いて解くことができるということを初めて知り，発想としても簡単ではないと感じたため1番目に選択した．,2,2,,18,スタックの実装において，要素を取り出す際に，self.headという変数が次に要素を配置するインデックスであることに注意して1減らしてから要素を取り出す必要があり，スタックの実装の中心部分であるとともに注意も必要であるため選択した．スタックを利用するという発想の方がこの問題においては重要と考え，2番目とした．,3,3,,13,スタックの実装の中心部分であると考えて選択した．2番目ほど注意を必要としないと考え，3番目とした．,13,13,,,とても理解できた。,
12/15/2022 16:52:37,7,21,22,問題を解くためにstackのデータ構造を用いるということがこの行から分かり，問題を解くための大きなヒントとなる部分であるから．,2,2,,27,"演算子が入力であった時は，直前の二つの入力を取り出して計算し，それを再びstackに挿入することで計算が可能であることがこの行で分かるから．(29,31行目も同様)
一番目ではない理由は，stackを利用するということ自体を思いつけないとこの処理を行うことはできないから．",11,11,,19,"stackでは直前に入れた要素を取り出すようなデータ構造であることがこの行から分かり，この構造を用いることで正答を導き出すことができるから．
3番目である理由は，stackがどのようなデータ構造かをわかっている場合は，既知のことだから．",2,2,,,まあ理解できた。,
12/15/2022 20:43:48,3,21,22,ループ部分と迷ったが、この問題で重要なのは逆ポーランド記法は左端からstackに突っ込んでいって計算すればそのまま計算することが出来る、ということなので。,2,2,,25,ここのループで左端からstackに突っ込んで行く過程を実装しているので。,11,11,,6,stackというデータ構造の何が重要かと言われると難しいが、単純なリストと先頭のインデックスを管理するだけで実装が出来るというのは重要かもしれない。,14,14,,,とても理解できた。,
12/16/2022 15:03:42,6,21,27,逆ポーランド記法の数式をスタックで処理するにあたっての、スタックから取り出し、演算し、挿入すという根幹の処理を示している。,11,11,,29,逆ポーランド記法の数式をスタックで処理するにあたっての、スタックから取り出し、演算し、挿入すという根幹の処理を示している。1 番と同様に重要。,11,11,,31,"逆ポーランド記法の数式をスタックで処理するにあたっての、スタックから取り出し、演算し、挿入すという根幹の処理を示している。1, 2 番と同様に重要。",11,11,,,とても理解できた。,
12/16/2022 23:54:55,2,21,27,逆ポーランド記法の処理はそれほど自明ではないので、その処理の部分を書いたここがこの問題の最重要ポイントだと感じた。,14,14,,29,逆ポーランド記法の処理はそれほど自明ではないので、その処理の部分を書いたここがこの問題の最重要ポイントだと感じた。2回目の登場なので、2番目。,14,14,,31,逆ポーランド記法の処理はそれほど自明ではないので、その処理の部分を書いたここがこの問題の最重要ポイントだと感じた。3回目の登場なので、3番目。,13,13,,,まあ理解できた。,
12/19/2022 12:12:50,8,21,27,スタックを用いながら、逆ポーランド記法に沿った計算を行っている、アルゴリズムの肝の部分だから。,12,12,,29,1番と同様の理由で、逆ポーランド記法特有の計算方法を実現しているところだから。重要度は1番と同じ,12,12,,31,1番・2番と同様で、逆ポーランド記法特有の計算方法を実現しているところだから。重要度は上の二つと同じ。,12,12,,,とても理解できた。,
12/21/2022 2:13:03,9,21,27,逆ポーランド記法における足し算の計算を、スタックから値を取り出すことで行っている箇所であるから。,11,11,,32,逆ポーランド記法において、数字が出てきたらスタックにその値をそのまま格納すればよいことが表されているから。実際に計算する処理を行う箇所のほうが大事だと考えているので、1番にはしなかった。,11,11,,35,"最後に答えの値を取り出す処理が書かれているから。これは処理の核心の部分ではないため、1,2番目とはしなかった。",11,11,,29・31行目。逆ポーランド記法における引き算、掛け算の計算結果の求め方が書かれているので、足し算同様に重要と考えている。,とても理解できた。,
12/21/2022 15:44:53,4,21,27,逆ポーランド記法での演算をする際にスタックをこのように利用するという処理が書かれているから。,14,14,,33,数字が得られればスタックに入れるというスタックの性質を利用しているから。ただ処理としては単純。,11,11,,13,pushしたときにはheadを+1するというのはスタックの実装において本質的であるから。ただ逆ポーランド記法の計算には直接的に関係しない。,9,9,,,とても理解できた。,
12/28/2022 20:57:42,5,21,29,この問題はStackを使用できるという部分が非自明であるため、Stackそのものの実装よりもStackを利用している部分のほうが重要であると考えた。その中で3種類の演算子はほぼ同様の処理で実現できるが、唯一符号が逆になっており注意が必要な29が最も重要であると考えた。,2,2,,33,+ や × の演算子よりも、数値がpushされたときのStackの扱い(ただpushすればよい)という点が重要だと考え、2番目に重要であるとした。,11,11,,27,+ や ×の演算子の扱いについても上2つについで重要であると考え、先に登場した27行目が3番めに重要であるとした。,12,12,,"31行目：*についての処理が書かれており、重要
12行目,18行目: push,popについてlistで実装する際のhead変数の扱いが書かれており、重要",とても理解できた。,
12/30/2022 23:52:20,10,21,13,pushしたときに、headをずらすことがstackにおいて重要だと思ったため。,9,9,,18,1番と同じように、popするときは、headを-1することで戻すことが重要だと思ったため。,9,9,,27,1番2番などに注意して、実装したstackを用いて、逆ポーランド記法の計算をしていて重要だと思ったため。,12,12,,,まあ理解できた。,
1/3/2023 7:33:13,11,21,22,逆ポーランド記法をstackで処理しようと発想したところが大事だと思います．そこが反映されている箇所を選びました．,2,2,,12,頭から入れる構造になっているのがqueueと違うところなので選びました．stackの実装というより細かい話になるので2番目にしました．,1,1,,25,逆ポーランド記法をstackを使いながらうまく処理している箇所の冒頭をえらびました．stackを作ることにより重点があると考えたので3番目にしました．,14,14,,,とても理解できた。,
12/10/2022 13:08:34,1,22,2,最大公約数を再帰に求めることを表しており，発想として最も重要かつ難しいところだと考え選択した．,5,5,,6,2数の最小公倍数が最大公約数を使って求められるという考え方や，問題の考察部分を表していることから選択した．計算量に関係するアルゴリズムの部分を含んでいないため2番目とした．,2,2,,1,あまり重要とは考えていないが，最大公約数を求める関数を定義しているため，他の行よりは比較的重要と考え，3番目に選択した．,1,1,,,とても理解できた。,
12/15/2022 16:59:44,7,22,6,6行目のような式で最大公約数から最小公倍数を算出することで答えを求められるということが分かるから．,12,12,,2,"最大公約数はユークリッドのの互除法を再帰関数の形で実装することによって効率的に求められるということがこの行から分かるから．
1番でない理由としては，この問題はそもそも最小公倍数を求めるものであるのにも関わらず，この行では最大公約数の求め方となってしまうため，なぜ最大公約数を求める必要があるのかの方が重要だと思ったから．",5,5,,5,"すでに選択していない行のうち，関数の定義より入力を受け取る方が重要だと思ったから．
3番目である理由は，この行では入力を受け取っているだけであり，問題の解法には関係ないから．",1,1,,,まあ理解できた。,
12/15/2022 20:46:26,3,22,6,この問題のコアは最大公約数を使えば計算できることに気付くことなので。,2,2,,2,最大公約数の求値アルゴリズムそのものがここで式として記述されてるから。,12,12,,5,他に選ぶところがないので、まあ入力をとることもプログラミングには大事なことかもしれない。,1,1,,,とても理解できた。,
12/16/2022 15:11:22,6,22,2,ユークリッドの互除法を再帰的に処理するにあたっての本体となる行である。,5,5,,6,問題の答えである最小公倍数は、積を最大公約数で割ったものであることを示している。1 番ほど非自明ではない。,2,2,,1,最大公約数が二引数の演算であることを示している。1 番や 2 番ではないのは、まあ流石に……,1,1,,,とても理解できた。,
12/16/2022 22:41:43,2,22,6,"この問題の答えが最小公倍数であるという考察、および最小公倍数がA * B / GCD(A, B)でもとまるという知識が両方含まれており、ぶっちぎりで重要な行。",2,2,,2,最小公倍数を求めるために最大公約数を求める必要があり、それを再帰的に高速に求めている行なので、次に重要。,14,4,×,5,アルゴリズムのほうが重要だが、問題の数値の入力ができないと問題は解けないので、残った2行の中ではこっちの方が大切。,1,1,,,とても理解できた。,
12/19/2022 12:19:42,8,22,6,AとBの最小公倍数が問題の答えであり、それを求めるために最大公約数を用いるという考え方は重要だから。,2,2,,2,再帰を用いて最大公約数を求めるというのもアルゴリズム的に大事だから。答えの求め方の方が重要だと思ったので、こちらは2番にした。,5,5,,5,特に重要だとは思わなかったが、コードが短いので消去法的に選んだ。,13,13,,,とても理解できた。,
12/21/2022 2:49:07,9,22,2,最大公約数をユークリッドの互除法を用いて求めている行であるから。最小公倍数を求めるには最大公約数を求める必要があるため、最大公約数を求めることがこのコード内で最も重要だと考えている。,12,12,,6,最大公約数を用いて最小公倍数を求めている行であるから。最小公倍数の求め方は最大公約数が求まっていれば簡単な式で求められるため、1番ではないと考えた。,12,12,,1,gcd関数の定義について述べている行であるから。実装上のちょっとしたポイントであるため、1番や2番ではないと考えた。,1,1,,,とても理解できた。,
12/21/2022 16:15:12,4,22,6,最大公約数を使って答えを求めるという、計算を行なっている部分だから。,12,12,,2,1番の処理を行うために最大公約数を求める処理を行なっているから。あくまで1番を行うための準備の処理だから。,12,12,,1,最大公約数を求めるというのを決定している行だから。具体的な処理については書いていないから。,14,14,,,まあ理解できた。,
12/28/2022 21:00:34,5,22,2,GCDを再帰を利用して求めるというのは、現実的な計算量で回答を実装するにあたって重要だと考えた。,5,5,,6,"LCMを求めるにあたって、a * b / GCD(a,b) を計算するという部分であり、この問題の本質的なところだと感じたため。ただし、問題からGCDを計算するという考え方に至るまでさほど遠くないと考え、2番めに重要だと考えた。",12,12,,5,mapを用いて入力を受け取るための手法が書かれており、3番めに重要だと考えた。,1,1,,,とても理解できた。,
12/31/2022 0:00:07,10,22,2,このプログラムの中で、最大公約数を求める部分が一番重要であると思ったため。,12,12,,6,1番で実装したgcdを用いて、最小公倍数をgcdを用いて、求めることが2番目に重要であるため。,12,12,,5,入力を分割して、intにすることは重要であるが、本質的ではないため、3番目に重要であると思った。,1,1,,,とても理解できた。,
1/3/2023 7:37:16,11,22,2,最大公約数がこのように再帰を使って求められることは重要な事実だと思います．,5,5,,6,最大公倍数が積を最大公約数でわると求められることは大事だと思います．gcdを求めるよりも簡単な知識だと感じたので2番目にしました．,12,12,,5,短いコードなので仕方なく選びました．そんなに重要だとは思っていないです．,13,13,,,とても理解できた。,
12/12/2022 2:41:27,1,23,13,ある素数の倍数(自身を除く)は合成数であるという事実を利用するアルゴリズムの考え方を最も端的に表していると考えたため．,14,14,,12,ある素数の倍数(自身を除く)は合成数であるという事実を利用するアルゴリズムの考え方をよく表していると考えたため．1番目に選択した行の方がより端的に表していると考え，2番目に選択した．,14,14,,21,累積和を用いて複数のクエリに対応するという考え方を表していると考えたため．一方でエラトステネスのふるいを用いることの方が発想として難易度が高いと考えこちらは3番目とした．,14,14,,,とても理解できた。,
12/15/2022 17:11:06,7,23,28,この行から，あらかじめ求めておいた各値までの「2017に似た数字」の数の総数の配列を用意しておき，それを利用することで各クエリに対してより効率的に答えを返すことができるということが分かるから．,4,4,,18,"エラトステネスの櫛のアルゴリズムを用いることで，あらかじめ出現する全ての数の素数判定を用意しておくことで素数判定をあとから簡単に行うことができるということがこの行から読み取れるから．
1番でない理由としては，素数判定を簡単に行うだけでは正解を導くということに直結しないから．",14,14,,11,"このwhile文の中で一度素数だと分かった数の倍数を省いていくことでより効率的に素数判定を行えるようになったことがエラトステネスの櫛のアルゴリズムの一番の利点だと思うから．
3番目である理由としては，これはエラトステネスの櫛のアルゴリズムの一部であり，問題の答えには直結しないから．",4,4,,8: 条件分をi<=Nではなく，iの二乗がNを超えないところまでと範囲を絞ることでより計算量を抑えているから．,まあ理解できた。,
12/16/2022 8:28:50,3,23,18,この問題のコアは複数の数の素数判定はエラトステネスの篩で前計算すれば高速に処理できることだから。,4,4,,21,この問題でもう一つの大事なアルゴリズムとして、累積和による区間和高速計算が挙げられるが、それを実現してるのはここのDP遷移式だから。,9,9,,13,エラトステネスの篩で一番重要なのはこの特殊な全探索の更新処理だと考えるから。,9,9,,,とても理解できた。,
12/16/2022 15:22:36,6,23,22,累積和配列への加算を条件を示した行で、問題を解くのに必要な前計算の根幹部分である。,8,8,,13,既に見つかっている素数の倍数を合成数として記録していくという、エラトステネスのふるいの根幹をなす部分である。問題固有の考察が含まれないので、1 番ほど重要でない。,9,9,,9,エラトステネスの篩では、この条件付けによって合成数でない場合は処理をスキップできるため、漸近計算量が最大値 N に対し O(N log N) でなく O(N log log N) となる。計算量の (軽微な) 変化に関わるだけなので、1 番や 2 番ではない。,4,4,,,とても理解できた。,
12/16/2022 22:51:02,2,23,21,L ~ Rで条件を満たすものの個数、というタイプのクエリに答える問題は累積和で考えると効率的に解けるので、そのアイデアを用いた部分を最重要だと評価した。,4,4,,8,1 ~ 10^5の全部の数を素数判定する必要があるが、全部判定していると間に合わない。(10^5) ^ (1/2)までの数で試し割りすればいいという知見が出ている行なので、クエリの高速化に次いで重要だと考えた。,4,4,,11,エラトステネスの篩のアイデアで、xが素数ならxの倍数は素数ではない、という操作をしている部分なので、重要。割と自明なアイデアだと感じたので3番目にしました。,8,8,,,とても理解できた。,
12/19/2022 12:28:58,8,23,12,素数の倍数を候補から消していくという、エラトステネスのふるいというアルゴリズムを最もよく表した一文だから。,14,14,,28,累積和を用いて、素数の個数を計算量少なく求めようとしており、アルゴリズム的に重要だから。この方法は必ずしも必須ではないので2番とした。,4,4,,6,0と1は素数ではないという記述は、当たり前だが忘れてしまうと、すべて素数でないと判断されてしまうので重要。アルゴリズムというよりはコーナーケースの処理なので3番とした。,3,3,,,とても理解できた。,
12/21/2022 3:02:49,9,23,18,エラトステネスの篩で素数判定を行い、それをテーブルに持つ処理を行う行であるから。今回の問題では10^5以下の素数の値が全て求まっている必要があるので、素数判定を行った結果を配列に格納する箇所が、最も重要であると考える。,9,9,,22,その数が2017に似た数であるかどうかを判定する箇所であるから。素数判定の結果を用いて2017に似た数かどうかの判定を行うため、素数判定の結果が前提と考え、1番とはしなかった。,8,8,,22,累積和配列を構築するパートであるから。これは素数判定と2017に似た数の判定が前提となっているため、重要度は1番目、2番目に比べると下がると考えた。,14,14,,4～15行目：実際にエラトステネスの篩を用いた素数判定を行っている箇所であるため、ここの行も重要だと考えている。,とても理解できた。,
12/21/2022 16:25:08,4,23,28,答えを求めるときにcumulative_sum[]の性質を利用して効率的に計算しているから。,4,4,,22,答えを求めるために必要なcumulative_sum[]を作るために重要な条件文だから。重要だが、問題文の条件をそのまま書いているだけであるため。,8,8,,12,素数判定を効率的に行なっている部分だから。ただ素数判定はこの問題において道具でしかない。,4,4,,,とても理解できた。,
12/28/2022 21:06:31,5,23,28,この問題は、概ね「累積和リストを利用した区間和」と「エラトステネスの篩を利用した素数の列挙」の2つの要素がある。そのうち、累積和リストを利用した実装のほうが思いつきづらく、より問題を解くのに本質的だと考えたため、累積和をどのように使えばよいかが書かれている28行目がもっとも重要だと考えた。,2,2,,22,エラトステネスの篩の関数内部については、どの行もひとしく重要であると考え、特定の行を選ぶことはできないと感じた。したがって、この問題の「2017に似た数」という部分を条件式に起こした22行目が、累積和ほど非自明な実装でないにせよ、２番目に重要だと思った。,8,8,,23,累積和リストの実装の中の一部であり、上２行と違い１行で大きな意味を持っているわけではないため３番めに重要だと考えた。,13,13,,"4 ~ 15行:典型的だが、エラトステネスの篩の実装であり重要
21: 累積和の更新部分であり、重要",とても理解できた。,
12/31/2022 0:23:40,10,23,12,素数の倍数をFalseにしていて、エラトステネスの篩において重要だと思ったため。,9,9,,8,1番の上で、i * i <= Nとすることで計算量をこの部分の計算量をO(√N)に抑えることができて、重要であると思った。,4,4,,21,1番2番に注意して実装した関数を用いて、累積和により、区間の中の条件を満たす数の個数を出していて重要だと感じたため。,12,12,,,とても理解できた。,
1/3/2023 7:41:36,11,23,12,倍数に対して素数でないことをメモしている箇所が要だと思ったため．,9,9,,6,"0,1は素数ではないので，初期条件として自分で入れてあげる必要がある．前処理のような意味合いが強く感じるため2番目にしました．",6,6,,28,累積和を使ってある区間の和を求めている箇所．素数判定の方が重要だと考えたので，3番目にしました．,12,12,,,とても理解できた。,
12/10/2022 13:04:29,1,24,24,入次数が0になった頂点を先入先出のキューに入れることによって，トポロジカル順に頂点を取り出すことができるという考えを表しているため，最も重要だと考えた．,11,11,,22,入次数が0の頂点を起点に考えることでトポロジカル順序にソートできるという考え方を表していると考えたため選択した．1の方がより考え方を端的に表していると考え2番目とした．,14,14,,14,入次数が0の頂点を起点に考えることでトポロジカル順序にソートできるという考え方を表していると考えたため．2と同様の理由であり同等の重要度だと考え，便宜上3番目とした．,14,14,,,とても理解できた。,
12/15/2022 17:22:16,7,24,21,すでにソート配列の中に組み込んだ頂点から出る矢印を取り除いていくことで次の「自分を指す矢印がなくなった頂点」が現れ，次にソート配列に挿入されるべき頂点が分かるという，トポロジカルソートの基本的な操作の一つだから．,11,11,,22,"自分を指す矢印がなくなった頂点から順にソート配列に入れていくことでトポロジカルソートを実現でき，この条件文がその条件を示しているから．
1番でない理由としては，1番に選んだ21行目の操作を行ったおかげで「自分を指す矢印がなくなった頂点」が順番に生まれていき，これが次にソート配列に組み込まれる頂点となるという論理の流れがあるため．",8,8,,12,"トポロジカルソートはqueueのデータ構造を使うことでより簡単に実現できるということを示しているから．
3番である理由としては，特にqueueを用いなくてもstackなど別のデータ構造でも実現可能であるから．",14,14,,,まあ理解できた。,
12/16/2022 8:43:03,3,24,22,トポロジカルソートはこの入次数が0になったノードからQueに突っ込んでくことで実現できるのが重要で、その実装をしているのがこことここの内部だから。,11,11,,18,Queを用いた全探索及びDPには大体言えるが、探索順序の決定をQueに依存できるのは重要である。,10,10,,7,しいて言えば最初に入次数とグラフを構築するのは大事かもしれない。,6,6,,,とても理解できた。,
12/16/2022 15:42:15,6,24,14,入次数 0 の頂点はトポロジカルソートにおいて先頭としてよいという、Khan のトポロジカルソートの根幹をなす部分である。,14,14,,22,入次数 0 の頂点はトポロジカルソートにおいて先頭としてよいという、Khan のトポロジカルソートの根幹をなす部分である。1 番と同様に重要。,14,14,,21,"トポロジカルソートの先頭にした頂点から辺が伸びている頂点について、入次数を減算するという状態の差分計算を行なっている。 1, 2 番に対して従たる部分。",12,12,,,とても理解できた。,
12/16/2022 23:18:07,2,24,22,入次数が0である頂点を現在1番前の頂点としてsort済みの配列に入れていくというアルゴリズムなので、入次数が0という判定をしている部分が最重要だと考えた。,8,8,,20,ソート済みの頂点から出ている辺を消していく操作なので、アルゴリズムのメインアイデアではないが、入次数を減らしていく部分なのでこれが2番目に重要だと考えた。,9,9,,9,上で書いたソート済みの頂点から辺を消すための操作には、辺の情報を頂点に持たせておかないといけないので、ここが次に重要であると感じた。,14,14,,,とても理解できた。,
12/19/2022 12:45:22,8,24,20,キューに入ったものを１つずつ取り出してソートしていくのが、トポロジカルソートのやり方をよく表していると思ったから。,14,14,,21,調べたところから繋がっている先の入次数を減らしていくというのもトポロジカルソートの重要な点だから。1番と同じくらい重要だと思う。,9,9,,12,キューというデータ構造を使うというのもトポロジカルソートで重要だから。コードの記述としては平易なので3番にした。,14,14,,,まあ理解できた。,
12/21/2022 3:11:57,9,24,14,入次数が0の頂点を、ソート済み配列とキューに入れる箇所であるから。トポロジカルソートでまず最初にやるべき要点を記述してある行であると考えており、一番重要だと考えている。,11,11,,21,見た頂点の入次数を1減らす処理を行っているから。入次数が0の頂点を入れる次に行うべき処理の要点を記述してある行と考えており、2番目に重要と考えている。,9,9,,19,"一度見た頂点をキューから取り除いているから。これは実装上の注意点であるため、1,2番目ほどは重要ではないと考えている。",11,11,,,とても理解できた。,
12/21/2022 22:30:07,4,24,22,入次数が0のノードをソート済みにするというのがこのソートの本質であるため。,14,14,,24,キューを使って次に見るノードを管理するのが重要だから。ただこれはソートに必要な道具にすぎないため。,14,10,×,19,queueからどのように取り出すのかを決める行だから。取り出し方を決めているだけなので2番よりは弱い。,14,14,,,とても理解できた。,
12/28/2022 21:36:26,5,24,8,プログラム内で何度も使用されるin_degreeという配列がどのようなものなのかについて、入次数という概念を知らなくても8行目を読めば理解できるため。逆に、これがわからなければ理解が難しいと考え、もっとも重要だとした。,14,14,,22,8行目でin_degreeについて理解した事が前提ではあるが、queueにどのようなものが追加されているのかを理解できるため重要だと考えた。,11,11,,18,上2つとは違い、プログラミングのテクニックとして重要な部分ではあるが、queueの中身がある間実行する というpython特有の書き方なので重要だと考えた。,1,1,,,まあ理解できた。,
12/31/2022 0:44:38,10,24,21,まず入次数0につながるノードの入次数を1減らすことが重要であるから。,9,9,,23,1番で入次数を1減らした後、0になったものをsortedに追加することが重要であるから。,11,11,,24,1番で入次数を1減らした後、2番と同じように0になったものをqueueに追加することが重要であるから。,11,11,,,とても理解できた。,
1/3/2023 7:47:35,11,24,14,トポロジカルソートにおいて，入字数が0のものから処理していくことが大事であると感じたから．,14,14,,21,ノードを見ていくごとに，入次数は減少させる必要があり，その操作を表しているから．1番目の0のものを見ていくという強い意思があっての入次数管理なので2番目にしました．,9,9,,8,あらかじめ入次数を数えておくことは大事です．前処理のような雰囲気を感じたので3番目にしました．,12,12,,,とても理解できた。,
12/10/2022 12:59:15,1,25,15,見つけた未訪問の頂点をキューに入れることで，BFSの順序で頂点を探索できるという考え方を表しているため．,10,10,,11,訪問済みの頂点をキューから取り出すことでBFS順で探索を行えることを表している行であるため重要と考えて選択した．1番目の方がこの考え方をより端的に表していると考えて，2番目に選択した．,10,10,,13,未訪問の頂点であるかどうかを確認する操作であり，ミスが起こりやすい部分だと考えて選択した．アルゴリズムの根幹となる部分ではないと考え3番目とした．,3,3,,,とても理解できた。,
12/15/2022 18:00:18,7,25,26,問題で問われている最短距離を求めるためには幅優先探索を行えばよいということがこの行から分かるから．,2,2,,7,"queueのデータ構造を用いることは幅優先探索を行うために重要であることだと思うから．
1番でない理由としては，この部分は幅優先探索のアルゴリズムの一部であり，問題を解くことには直結していないから．",14,14,,11,"次に見る頂点候補(queue)のうち，古いものから順に取り出していくことで幅優先探索を実現できるということが分かるから．
3番である理由としては，古いもの順に取り出すということはqueueの基本的な使い方と合致しており，2番目があれば分かる操作であるから．",11,11,,,まあ理解できた。,
12/16/2022 8:47:18,3,25,26,この問題のコアは幅優先探索を使えば解ける、ということなので。,2,2,,14,幅優先探索で重要なのはここの配るDP遷移式で状態をまとめて探索できることだから。,10,10,,10,Queを用いるDPや全探索すべてに言えることだが、探索順序をQueを用いれば効率的に決定できるのは重要である。,4,4,,,とても理解できた。,
12/16/2022 23:38:34,2,25,11,BFSは距離を近い順に確定させていくが、queueの先頭の要素がいまのところ一番近い頂点なので、その知見がふくまれたこの行が最重要。,14,14,,14,まだ訪れていない頂点があったら、距離を確定させる操作がいるので、距離の確定をさせるこの行は重要。,9,9,,23,隣接リストで表現しないと計算量が増えてしまうので、アルゴリズムの根幹ではないがこれはこれで重要だと考える。,4,4,,,とても理解できた。,
12/17/2022 23:26:23,6,25,11,幅優先探索の、訪問済みかつ未処理の頂点の中で最も昔に訪問した頂点を処理するという特徴が示されている。,14,14,,15,Deque を Queue として使う以上入れ方にも選択肢があるが、後ろから入れるということが示されている。Deque を使わなければさして気にするところでもないので 2 番。,1,1,,13,"この条件分岐は忘れがちだが忘れると痛い目を見る。1, 2 番に比べると細かい注意点に当たる。",3,3,,,とても理解できた。,
12/19/2022 17:58:45,8,25,15,発見したノードをキューに入れていくというのはBFSの1番の特徴だから。,11,11,,13,まだ見ていないところについて見るという記述で、これもbfsにおいては大切だと思った。1番の方が本質的だと思ったので、こちらは2番にした。,10,10,,5,距離を最初に-1で初期化しておくことで、たどり着けないところは-1で出力せよ、という問題の指示に答えられるようにしているから。bfsのアルゴリズムに本質的に関わることではないので3番にした。,6,6,,,まあ理解できた。,
12/21/2022 3:18:19,9,25,14,今見ている頂点から直接たどり着ける頂点に対して最短距離の更新を行っている行であるから。最短距離の更新を直接行っている行であるため、ここが一番大事と考えている。,9,9,,13,一度見た頂点を二度と見ないような処理をしている行であるから。最短距離の更新を本質的に行う行ではないため1番大事というわけではないが、これがないと無限ループが起こってしまうため、2番目に大事と考えている。,14,14,,8,最初に訪れる頂点をキューに入れる行であるから。少しの実装上の注意点なので1番や2番というわけではないものの、これがないと全く探索が行われないので、3番目に重要だと考えた。,6,6,,,とても理解できた。,
12/21/2022 22:36:59,4,25,11,幅優先探索はノードをキューとして管理することが重要で、この行はそれを表しているから。,14,14,,15,キューにどのように値を追加しているのかを表す行だから。ただ次のノードを入れるというだけなので2番にした。,11,11,,14,答えを表すリストを更新している部分だから。ただ探索の本質にはあまり関係ない。,9,9,,,とても理解できた。,
12/28/2022 21:45:56,5,25,15,BFSの本質的な部分であると同時に、この部分をappendleftにするとDFSという別のアルゴリズムになってしまうため、絶対に間違えてはいけない重要な部分だと考えた。,3,3,,11,15行目をappendleftにしていても、11行目がpopだとDFSになる。appendのほうが本質的に感じたが、15行目と同様にこの部分も非常に大切だと考えた。,14,14,,13,BFSの更新処理について、実際にdist配列を変更する部分であり、BFS/DFS共通の部分なので上2つより優先度は下がるが重要だと考えた。,9,9,,6: 初期化しないとBFSを開始できないから,まあ理解できた。,
12/31/2022 0:55:15,10,25,11,bfsにおいて、queueのデータ構造を使うことが重要であるため。,14,14,,13,1番のデータ構造を用いた上で、訪問したノードは訪ねないようにすることが重要であるため。,8,8,,6,1番や2番より基本的だが、start地点のdistの値を0で初期化することを忘れないことが重要であるため。,6,6,,,まあ理解できた。,
1/3/2023 7:51:49,11,25,11,入った方早い順序から出していくのがbfsの大事なところだと考えました．,11,11,,13,まだ見ていないところに絞って探索しないと時間が無限にかかってしまいます．本質からちょっとだけ離れている気がするので2番目にしました．,4,4,,14,次に見るノードは今見ているノードよりも距離を1増やしてい口方針が大事だとおもいます．距離は1じゃなくなったりするので，3番目にしました．,9,9,,,とても理解できた。,
12/12/2022 2:57:41,1,26,5,"i, jの距離をkを経由する場合としない場合に分けて計算するというワーシャルフロイド法の重要な考え方を表しているため．",8,8,,2,経由頂点のループを一番外側にしなければ計算順序が間違ってしまい，ミスが起こりやすいと考えたため選択した．1番目で選択した箇所ほどアルゴリズムの本質を表している訳ではないので2番目とした．,3,3,,8,"負閉路検出のための条件を表している箇所であるため選択した．1,2番目ほどアルゴリズムの核心部分ではないと考え3番目とした．",8,8,,,まあ理解できた。,
12/15/2022 18:06:30,7,26,25,ワーシャル・フロイドアルゴリズムを用いることでこの問題を解くことができることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,2,2,,5,"各頂点間の距離をこの行の式で更新していくことで徐々に最小距離を求めていくことができるから．
1番でない理由としては，これはワーシャル・フロイド法の具体的な方法であり．アルゴリズムについて知っている人にとっては既知のこととなってしまうから．",9,9,,8,"負の経路の検出の方法がこの行で表されているから．
3番目である理由は，負の経路があることは例外的なパターンであり，全ての問題に共通するものではないから．",8,8,,"2,3,4: どの順番にfor文ループを回すのかということは重要だから．",まあ理解できた。,
12/16/2022 22:57:39,2,26,5,ぐるぐる回しながら最短距離が更新できるなら更新する、というのがワーシャルフロイド法なので、その更新している行が最重要だと考えた。,9,9,,21,行列Gの初期値は基本的にinfだが、辺があるところは辺のコストにしておかないといけないので、アルゴリズムの直接的な部分ではないが、これも重要だと考えた。,6,6,,23,同じくある頂点から同じ頂点までの最短距離は自明に0なので、これも例外的に初期化しておかないといけない。2番目の行より後ろの行なので、3番目にした。,6,6,,,とても理解できた。,
12/17/2022 23:11:40,3,26,25,ワーシャルフロイド法で解けることに気付くことがこの問題のコアだから。,2,2,,2,ワーシャルフロイド法の肝は中継点から回してノード集合を増やしていくDPの探索順序だと考えているから。,10,10,,5,ワーシャルフロイド法に使っているDPの遷移式そのものはここだから。,9,9,,,とても理解できた。,
12/17/2022 23:37:50,6,26,5,Warshall-Floyd 法は DP の一種であり、遷移式が最も重要。,9,9,,2,k のループを外側にしないと酷い目に遭う。1 番に比べれば細かい注意点。,3,3,,7,負閉路の存在条件を示している。1 番や 2 番と比べると最短路計算の文脈からは外れる。,8,8,,,とても理解できた。,
12/19/2022 18:09:55,8,26,5,三重ループを使いながら、最短経路を計算していくというのがワーシャルフロイド法の肝だから。,12,12,,8,負の閉路ができていたときにそれを検知するというのも重要だから。最短経路の探索の方が重要だと思ったので2番にした。,8,8,,18,十分に大きな値で初期化しておくことも、問題を正しく解くためには大事だから。アルゴリズムそのものではないので3番にした。,6,6,,,まあ理解できた。,
12/21/2022 3:23:32,9,26,5,最短経路の更新を行っている行であるから。ここがなかったり、間違ったりしていると正しく動作しないため、ここが一番大事と考えている。,9,9,,2,最初にkに関してループを回すことを表している行であるから。直接最短経路の更新を行う行ではないものの、ここの順番を間違えていると正しく動作しないため、この順番でやることが大切だと考えている。,10,10,,8,負閉路検出の条件を表している行であるから。負閉路検出は必ず毎回登場するとは限らないため、ワーシャルフロイドで常時注意する必要がある1番目や2番目よりは重要ではないと考えている。,8,8,,,とても理解できた。,
12/21/2022 22:44:52,4,26,5,kを経由したほうが良いのかどうかを順番に見ていくというのがこのアルゴリズムの本質だから。,10,10,,9,NEGATIVE CYCLEがあったかどうかを判定している部分だから。ただ判定方法は簡単だから。,8,8,,12,経路があるのかどうかを判定している部分だから。ただこれは更新も一瞬だから。,8,8,,,とても理解できた。,
12/28/2022 21:51:44,5,26,2,"自分がワーシャルフロイド法のコードを書く際に、i,j,kの順番を誤る事が多く、とくに中点であるkについて先に走査するという部分が間違えやすいと感じたので、この部分が最重要だと感じた。",3,3,,5,一度覚えれば忘れづらいため一番大切ではないと思ったが、ワーシャルフロイド法の本質的な部分であり、2番目に重要だと考えた。,13,13,,8,ワーシャルフロイド法を調べると2~6行目の部分の情報を得られることが多いが、その他でマイナーな負の閉路検出を行う手法について知ることができる手法が書かれている8行目が3番めに重要だと考えた。,13,13,,,とても理解できた。,
12/31/2022 1:18:21,10,26,2,三つのfor文の順番に気をつけることが重要であると思ったため。,3,3,,5,1番に基づいて、5行目の式で更新することが重要であると思ったため。,9,9,,8,1番2番と別に、負の閉路の検出をすることも得られた最短距離が正しいかに関わり、本質ではないが重要であるため。,8,8,,,まあ理解できた。,
1/3/2023 7:56:21,11,26,5,i->jの距離を間の中間地点kを確実に通った時に短くなるかどうかを見ていくのは大事な考え方だと思います．,8,8,,2,kが一番外側に来ることが大事だと思います．実際に更新してる箇所の方がより本質に感じたので2番目にしました．,13,13,,18,初期値をINFにしているところが大事だと感じました．前処理感がつよいので3番目にしました．,6,6,,,とても理解できた。,
12/10/2022 12:54:40,1,27,18,求めたい要素を変換した先に他の要素が存在しなければ，その要素が記録されていないというハッシュの性質を活かしている部分だと考えたため.,14,14,,20,注目したインデックスに目的の要素がない場合に次に探すインデックスを決定する処理を記載しているため．1番ほどハッシュの性質の根幹にはかかわらないと考え，2番目に選択した．,9,9,,8,要素を配置したいインデックスに他要素が既にある場合の処理を記載しているため．2番目と処理としては同等であるため，同じくらい重要だが，便宜上3番目とした.,14,14,,,とても理解できた。,
12/15/2022 18:17:50,7,27,6,問題を解くために，ハッシュを用いることで効率的に探索を可能にしようとしていることがこの行で分かるから．,2,2,,2,"ハッシュテーブルとして配列を用意し，そこにどのハッシュの数字が存在していたかを格納していくことで探索を効率的にしようとしていることが，このハッシュテーブルの宣言で読み取れるから．
1番でない理由としては，ハッシュテーブルよりどのようなハッシュを用いて計算していくのを表す6行目の方が重要であると考えたから．",6,6,,8,"ハッシュの重複があった場合，次に空いているハッシュ値まで値をずらしていく，オープンアドレス法を用いる工夫がこの行から読み取れるから．
3番である理由としては，これは1,2番で挙げた行のハッシュテーブルを利用することに付随するものであり，より重要度は低いと思ったから．",9,9,,,まあ理解できた。,
12/16/2022 23:47:39,2,27,8,探したい数のハッシュ値を計算して、ハッシュ値が存在していれば探したい数も存在する、と考えるアルゴリズムなので、ハッシュ値を計算しているここが重要だと感じた。,12,12,,17,探したい数のハッシュ値を計算して、ハッシュ値が存在していれば探したい数も存在する、と考えるアルゴリズムなので、ハッシュ値を計算しているここが重要だと感じた。2回目にでてきたところなので2番目。,12,12,,20,ハッシュ値の一致を持って「見つかった」と判定するアルゴリズムなので、一致かどうかを判定している行がハッシュの計算に次いで重要だと感じた。,8,8,,,まあ理解できた。,
12/17/2022 23:15:45,3,27,2,ハッシュテーブルを使って探索を効率化しているのがこの問題のコアであり、ハッシュテーブルを作っているのはここだから。,6,6,,8,15行目と合わせてハッシュ値の生成を行っているのはここだから。,12,12,,15,8行目と合わせてハッシュ値の生成を行っているのはここだから。,12,12,,,とても理解できた。,
12/17/2022 23:54:53,6,27,9,挿入時に空いているアドレスを探して記録するというオープンアドレス法の特徴を示している。,9,9,,18,検索時に空のアドレスにぶつかればその key は入っていないと判断するというオープンアドレス法の特徴を示している。1 番の挿入方法から導かれる検索方法だといえる。,14,14,,22,全アドレスを見尽くしても key が見つからない場合もその key 入っていないと判断する。2 番と比べてより自明。,7,7,,,とても理解できた。,
12/19/2022 18:20:10,8,27,8,その数字をどのindexに入れるかというハッシュを定義している、ハッシュ探索の肝の部分だから。,12,12,,20,ハッシュを計算して、実際に挿入されている値と一致すれば「見つかった」ということになり、探索において重要な部分だから。ハッシュ計算の方が本質的だと思ったのでこちらは2番とした。,8,8,,18,2番と同様だが、もしハッシュを計算してそこに値がなければ、その値は「見つからない」ということになるので、これもまた探索で重要だから。重要度は2番と同じ,8,8,,,とても理解できた。,
12/21/2022 3:30:25,9,27,6,ハッシュ化されたxを求める行であるため。今回のハッシュ探索ではxをある値で割った余りをハッシュの値として用いることを示しているため、全ての前提となっていると考え、一番大事と考えている。,12,12,,8,ハッシュ化されたxに対して、どこに値を挿入するかを表す行であるため。ハッシュ化されたxが前提となっているため、ハッシュ化されたxを求めることの次に重要であると考えた。,9,9,,7,ハッシュ化されたxに対して、空きが見つかるまで1を足し続けることで格納する場所を見つけようとしていることを表す行であるから。1を足し続けることは本質ではないため、1番や2番ではないと考えた。,10,10,,15～17行目：値を格納するだけでなく、検索するときも格納するときと同じ処理を行うことを表しており、格納するとき同様に重要と考えている。,とても理解できた。,
12/21/2022 23:00:43,4,27,17,探索の時に見つかるまでindexを変えながら調べるというのがこのアルゴリズムの本質だから。,10,10,,8,挿入の時にもすでに入っていたらindexをずらすということが大事だから。ただメインは探索の方にあるため。,9,9,,20,探索が成功したかどうかを判断する部分だから。ただ処理としてはすごく単純のため。,8,8,,,とても理解できた。,
12/28/2022 22:03:24,5,27,8,insert関数を見ると、10^9までの数を10^4の配列におさめていることがわかり、その手法として8行目の操作をしていることがわかるため、もっとも重要だと考えた。,14,13,×,18,insertではすべてのiについてハッシュを試しており、どのような条件で探索を行うのか想像がつきづらいが、18行目を読むことでhash[index]=-1となるまで探索を進めていることがわかり、どのように数値が格納されているかわかりやすく成るため2番目に重要だと考えた。,14,14,,9,"8,18行目で行われた処理についての補足として、探索と同様に挿入の際にもhash[i]=-1となるまで右に探索を進めていくということがわかるから。",10,10,,,あまり理解できなかった。,
12/31/2022 1:34:47,10,27,8,hashが空いてるところまでindexを更新して、xを入れることが重要であると思ったため。,9,9,,18,hash[index] == -1の時は、その後も調べる必要がないので、return Falseする工夫が重要だと思いました。,1,1,,6,1番2番より基本的かもしれないが、x % MAXの値をハッシュ値とすることも重要だと思いました。,12,12,,,まあ理解できた。,
1/3/2023 8:10:56,11,27,10,ハッシュテーブルに登場した要素を持っておくことで高速に調べられるので重要だと思います．,4,4,,8,ハッシュが埋まっていた場合に隣に移動するという考え方が大事だと思いました．必ずしも隣である必要はないので2番目にしました．,10,10,,20,hashで調べた上で合致していたら同一とみなす手法は高速に調べられるので大事だと思います．ハッシュテーブルを検索するよりも，構築する方法がより大事に感じたので，3番目にしました．,4,4,,,とても理解できた。,
12/12/2022 12:25:47,1,28,22,距離が更新された頂点だけをキューに入れることにより，無駄な距離更新の確認を省くという考え方を表しているため選択した．,4,4,,18,距離が更新された頂点に隣接する頂点に関しては距離の更新の確認を行うというSPFAの考え方を表している行であるため，選択した．1番の方が同じ考え方を端的に表している部分だと考え，こちらは2番目とした．,8,8,,25,"負閉路が検出できる条件を表しており重要だと考えた．SPFAの中心的な考え方は1,2番目であると考えて3番目とした．",8,8,,,まあ理解できた。,
12/15/2022 18:33:17,7,28,39,この問題の解法では，SPFAと呼ばれるアルゴリズムを用いていることがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,2,2,,6,"SPFAではqueueを用いることでより効率的に頂点の最短距離を更新していくことができるため，queueを用いるということを表す行は重要であると思ったから．
1番でない理由は，SPDAのアルゴリズム全体をこの行だけで把握できるわけではなく，アルゴリズムの一部にすぎないから．",9,9,,20,"最短距離を更新できそうなら更新していくという操作を順序に行うことで最終的に全体の最短距離を求めることに繋がるから．
3番である理由は，SPFAにおいてqueueを用いていることの方が重要ではないかと考えたから．",14,14,,"21: すでにqueueに挿入されている頂点はこの行の条件文で除くことで，重複しないようにでき，queueを用いても探索を実現することにつながっているから．
25: 負の経路の存在を判定するのに必要な条件だから．",まあ理解できた。,
12/17/2022 20:19:57,2,28,22,SPFAはベルマンフォード法で最短距離が更新された頂点しか回さないことで高速化を達成しているので、queueを使っているこの行が大事だと考えた。,4,4,,20,一応最短経路を求めるアルゴリズムなので、最短距離が更新できれば更新する、という操作を入れる部分も大事だと感じる。高速化ベルマンフォードの高速化の部分の方が大事だと感じたので2番目。,9,9,,25,回りすぎたら負のサイクルがあるという判定も重要だと考える。上二つの方が最短距離を求める部分でより本質的だと感じたので、これは3番目。,8,8,,,まあ理解できた。,
12/17/2022 23:24:28,3,28,39,このとき方においてはspfaで解けることに気付いていることが肝だから。,2,2,,15,queueに更新されたノードを積んでいき更新できる限り更新するのがSPFAで重要だと思うから。,9,9,,20,SPFAをDPとして見たときに、更新式はここで行われているから。,9,9,,,とても理解できた。,
12/18/2022 0:21:41,6,28,19,最短距離を更新する条件が示されている。最短路問題を解くにあたり根幹となる操作である。,8,8,,22,最短路が更新された頂点を今後の処理対象とすることが示されている。SPFA が高速に動作する原理である。処理時間改善に過ぎないので 1 番ではない。,4,4,,25,"負閉路の存在条件が示されている。1, 2 番と比べると最短路問題の文脈からは外れている。",8,8,,,とても理解できた。,
12/19/2022 18:33:40,8,28,16,キューというデータ構造を用いて、順に経路を探索していくというのはspfaのアルゴリズムで最も大事なことだから。,10,10,,19,最短経路を更新していくための書き方で、重要だと思った。しかしspfa特有の書き方ではないので、2番とした。,9,9,,25,閉路を検出するのも、最短経路の探索においては重要だから。経路探索そのものの方が大切だと思ったので3番とした。,8,8,,,とても理解できた。,
12/21/2022 3:42:18,9,28,23,暫定的に、「まだ最短経路の更新がなされる可能性があるか」を「ある」に変えることを表す行であるから。ここで最短経路の更新可能性を更新することが、正しく最短経路の更新を行う上では重要と考えている。,9,9,,17,暫定的に、「まだ最短経路の更新がなされる可能性があるか」を「ない」に変えることを表す行であるから。ここを更新することで、無駄な頂点を見ないようにすることが可能となり、速くアルゴリズムを作動させるためには重要と考えている。プログラムの速さに関する箇所であるため、1番重要というわけではないと考えている。,9,9,,25,負閉路検出を行う行であるから。負閉路検出は必ずしも必要ではないため、1番や2番ではないと考えている。,8,8,,,まあ理解できた。,
12/21/2022 23:11:35,4,28,22,SPFAではキューをこのように使うということが表れている行だから。,13,13,,20,答えとなるdistを更新する行だから。ただ処理はcostをたすだけで単純だから。,9,9,,25,NEGATIVE CYCLEを判定している部分だから。ただこの判定はSPFAの本質からは離れている。,8,8,,,とても理解できた。,
12/28/2022 22:13:45,5,28,25,Dijkstra法について知っている前提で考えると、DijkstraでなくSPFAを使う最大の理由であろう負の閉路検出について書かれている25行目がもっとも大切だと考えた。,8,8,,21,"dijkstra法との違いのない部分なので重要度は落ちるが、queueにappendするかどうかの判断基準の部分なので重要だと考えた。
",8,8,,23,21行目を理解するにあたって、queue_flagとはどのようなフラグなのかを知るのに必要であるため23行目が3番目に大切だと考えた。,14,14,,,まあ理解できた。,私の勘違いである可能性もありますが、このコードならqueueの命名はstackが適切なように思えます。
12/31/2022 1:52:33,10,28,25,spfaにおいて、負の経路の検出をして、whie文を抜けることは重要であると思ったため。,8,8,,21,1番の次に、すでに調べたノードは飛ばすことが重要であると思ったため。,10,10,,20,1番2番の次に、ベルマンフォードと同じようにdistを更新することが重要だと思ったため。,9,9,,,まあ理解できた。,
1/3/2023 8:21:00,11,28,20,最短経路を求める時の更新の仕方が表れている一行であると考えたから．,9,9,,21,まだ訪れていない箇所に対して探索を進める方針が大事だから．下支えのような工夫だと感じたので2番目にしました．,10,10,,25,負閉路を検出できるのは嬉しいポイントであるから．副次的な印象をうけるので3番目にしました．,8,8,,,まあ理解できた。,
12/10/2022 12:48:46,1,29,7,本問題ではDPテーブルを作成する際に価値を軸に作成する工夫が必要であり，この問題を解く上でそこが最も重要だと考えるため．,2,2,,13,DPの更新式が書かれているため選択した．本問題ではDPテーブルの構築の部分の方が発想としてより工夫が必要だと考え，こちらは2番目とした．,9,9,,16,"本問題ではdpテーブルを利用し,値が特定の条件を満たすようなインデックスを返すという若干の工夫が必要であるため選択した．DPテーブルの構築，更新ほど重要ではないと考え，3番目とした．",1,1,,,とても理解できた。,
12/15/2022 18:42:29,7,29,13,DPでこの行の条件式で値の更新を行っていくことで，最終的に問題で問われている回答を導き出すことが可能だから．,9,9,,7,"必要なdpテーブルが，何番目の要素で幾つの価値までというdpテーブルであり，その宣言がこの行に書かれているから．特に，価値の総和の最大値が問題文より10000であることを踏まえてdpテーブルの大きさを定義している点が重要であると考えたから．
1番でない理由は，7行目の宣言だけでは，dpテーブルの要素が何を示しているのか分からず，13行目の式を直接見た方がわかりやすいから．",6,6,,16,"最終的に求めたい答えがどのように得られるのかがこの条件文から分かるから．
三番目である理由は，dpテーブルの定義・更新の方法が分かれば答えの取得方法も分かるから．",8,8,,,まあ理解できた。,
12/16/2022 23:09:41,2,29,13,動的計画法の漸化式部分であり、この式が建てられれば解けたも同然なので、一番重要。,9,9,,16,DP[i][j]はi番目までの品物を見たときに、価値jを達成するために必要な重みのminなので、dp[N][i]がW以下の最大のiが答えなので、その答えを求めている部分は重要。さすがに漸化式のほうが重要なので2番目。,13,13,,9,漸化式にしたがって配列を埋めていくが、適切な初期化をしておかないと面倒なことになるので、若干薄い部分ではあるが、3番目に重要だと考えた。,6,6,,,とても理解できた。,
12/17/2022 23:28:48,3,29,13,このナップサック問題の肝はDPで解けることに気付くことで、その遷移式がここだから。,2,2,,7,10001をハードコーディングしちゃっているが、普通のナップサックと違い、価値を横軸に取ったほうが計算量が少なくなることが重要だから。,4,4,,16,求めたいのは価値なので、軸の方で適切なものを探索しているのはこの問題において重要かもしれない。,2,2,,,とても理解できた。,
12/18/2022 0:25:08,6,29,13,ナップサック DP の遷移式であり、解法そのものと言ってもよい。,9,9,,9,ナップサック DP の境界条件であり、遷移式ほど広範囲には影響しないものの必要な部分である。,8,8,,16,作成した DP テーブルから答えをどのように判断するかを示している。今回の場合は比較的自明度が高い。,8,8,,,とても理解できた。,
12/19/2022 18:39:21,8,29,13,動的計画法において、テーブルを埋めていく計算は最も重要なところだから。,12,12,,7,dpテーブルを大きな値で初期化しておくというのは、この問題を解く上で注意しなければならない点だから。テーブルを埋める方が本質的だと思ったのでこちらは2番にした。,6,6,,16,この問題は必ずしも右下に答えがあるわけではない、というのは注意点で、その答えの探し方をしめしているところだから。テーブルを埋められて初めてここに辿り着くので、3番とした。,10,10,,,まあ理解できた。,
12/21/2022 3:45:34,9,29,13,DP遷移を表す行であるから。ここが全ての計算の核心の部分であるため、ここが最も大事と考えている。,12,12,,9,DPの初期値を表す行であるから。初期値は遷移に比べると核心の部分ではないが、ここが間違っていると正しく動作しないため、ここは2番目に重要と考えている。10,6,6,,17,答えがDPテーブルのどこに現れるかを表す行であるから。直接計算に関わる箇所ではないため、1番目や2番目ではないと考えている。,2,14,×,,とても理解できた。,
12/21/2022 23:20:09,4,29,13,DPテーブルを更新するというのがこの問題を解く本質となるから。,9,9,,7,DPテーブルをどのような構造にするのかを決める部分だから。ただ構造を決めているだけ。,6,6,,9,DPテーブルの自明な部分を埋めているため。自明な部分なので、処理が単純だから。,9,9,,,まあ理解できた。,
12/28/2022 22:29:52,5,29,7,制約により、実際のvの上限が10000を超えないことがこの問題の最大のポイントであると感じた。したがって、この部分がコードに現れている7行目がもっとも大切だと考えた。食わてinfで初期化していることもわかり、とても多くの情報量を得られる行だと思う。,6,6,,13,"DPテーブルのi,jの意味が7行目だけでは掴みづらいときに、漸化式を見て何が起こっているのか知ることができるので重要だと考えた。ただし、漸化式の理解の前にvがたかだか1万であることを把握しておく必要があると考えたので2番目に重要だとした。",14,14,,15,条件を満たす最大のvを出力するため、reversed関数を使用しており、シンプルな実装の鍵になっているため重要だと考えた。ただし問題を解く部分に関連しないため3番目においた。,1,1,,,とても理解できた。,
12/31/2022 2:07:54,10,29,13,動的計画法において、dpテーブルの値の更新が最も重要だと思ったため。,9,9,,7,1番の値の更新ができるように、dpテーブルを初期化することが重要だと思ったため。,6,6,,9,1番2番に加え、最初の状態を0で初期化しておくことが重要だと思ったため。,6,6,,,まあ理解できた。,
1/3/2023 8:34:43,11,29,13,DP問題で遷移式がかければほぼ解けたような感覚があるので大事だと思います．,9,9,,12,価値の合計値が10000を超えないことを利用して問題を解いているため．DPテーブルを埋めるの方が重要だと感じたので2番目にしました．,2,2,,7,できるだけ小さい方が嬉しいパラメータの重さをINFで初期化していることが大事だと感じた．あくまで前処理の域を出ないと思うので3番目にしました．,6,6,,,とても理解できた。,
12/10/2022 11:43:29,1,30,12,これまで見た頂点の中で最も距離が小さい点は距離を確定して良いというダイクストラ法の考え方が表されていると考えたため．,9,9,,16,候補となる頂点を優先度付きキューに入れることで，短い順に取り出すことができるという実装上の最も重要な工夫であると考えたため．一方で，アルゴリズムの発想を表現している1番目ほどは重要でないと考えた．,11,11,,8,"優先度付きキューを使うという実装の工夫を表しているため選択した．アルゴリズムのロジックの部分ではないため1,2番目よりも重要度は下がると考えた．",1,1,,,とても理解できた。,
12/15/2022 18:53:11,7,30,28,この問題はダイクストラ法を用いることで解決できるということがこの行から分かり，アルゴリズム名を知っている人はどのように解くのかを把握することができるから．,2,2,,8,"ダイクストラ法では優先度付きqueueで最小経路を持つ頂点から順に取り出すことで実現できるアルゴリズムであり，それを用いることが表れているこの行が重要ではないかと考えたから．
1番ではない理由としては，これはダイクストラ法の一部であり，これだけではアルゴリズム全体を把握することはできないため．",11,11,,14,"この行の条件式で，現在一番最短距離の頂点からの距離を更新していくことで，最終的に最短距離を求めることが可能であるから．
3番である理由としては，ダイクストラ法の中で8行目の優先度付きqueueを用いて常に一番最短の距離の頂点を取り出してこの行の操作を行っていくことで最短距離を求めることが可能であり，8行目の方が重要だと思ったから．",9,9,,,まあ理解できた。,
12/16/2022 23:27:41,2,30,12,距離が確定した頂点見つける部分を、priority_queueを用いることにより高速化しているので、これが最重要。,4,4,,15,最短距離が更新できるなら最短距離を更新するのは相変わらず重要アイデアなので、2番目に選んだ。,9,9,,26,隣接リスト形式でグラフを表現することによりダイクストラ法は早く動くので、高速化のメイン箇所ではないが、残りの中ではここが重要であると考えた。,4,4,,,とても理解できた。,
12/17/2022 23:32:32,3,30,28,この問題のコアはダイクストラ法で解けることに気付くことだから。,2,2,,8,ダイクストラ法で重要なのはコストが小さいものから探索すれば効率よく探索できることだが、優先度つきQueを使うことでこれを少ない計算量で実装できているから。,4,4,,15,ダイクストラ法にとってのコアではないが、最短経路探索法としてDPを使っていることは重要で、個々がその遷移式だから。,9,9,,,とても理解できた。,
12/18/2022 0:29:21,6,30,14,最短距離の更新条件を示している。最短路問題を解くアルゴリズムでは一般にこのような処理が必要。,8,8,,12,次に調べる頂点は、現在調査済みの頂点を用いて行ける最も近い頂点であるという、ダイクストラ法の特徴を示している。,10,10,,16,2 番で述べたことを実現するためにここで push を行っている。,11,11,,,とても理解できた。,
12/19/2022 19:04:15,8,30,9,ヒープを使って最短経路を探索するというのはダイクストラ法の肝であるから。,10,10,,16,最短経路が更新されたものはヒープにいれていくというのも、ダイクストラ法を実行する上で重要だから。ヒープを使うという事実の方が本質的だと思ったのでこちらは2番にした。,11,11,,5,十分に大きな値で初期化しておくというのは、ダイクストラ法の実行において大切だから。アルゴリズムそのものではないので3番とした。,6,6,,,まあ理解できた。,
12/21/2022 4:09:44,9,30,14,最短経路の更新を行う条件を表す行であるから。最短距離の更新を行う条件を指定するため、一番重要と考えている。,8,8,,16,距離の情報と、頂点の情報を、（距離、頂点）の順に優先度付キューに入れることで、常に最短距離が最も小さい頂点のデータが取り出されるようになるから。更新を行う部分ではないため、1番ではないと考えている。,11,11,,9,最初に始まりの頂点と、距離0のデータを優先度付キューに入れている行であるから。細かい実装上の注意ではあるため、1番や2番ではないと考えているものの、ここを行わないと全く最短経路が更新されないため、重要と考えている。,6,6,,,とても理解できた。,このソースコードにあるダイクストラ法だと、途中（12行目と13行目の間）で枝刈りがなされておらず、最短経路でない古いデータに対しても続く箇所での処理を行ってしまっているため、最悪ケースで計算量が二乗オーダーになってしまいます。（もし仮に枝刈りの処理がソースコード内にあった場合、「ここがなくても正しく動作はするものの、最悪ケースでの計算量が悪くなってしまうから」という理由で、2番目に重要な行に選択していました。）
12/21/2022 23:36:01,4,30,12,現在までで最短距離を持つノードをヒープによって取り出すというのがダイクストラ法の本質だから。,11,11,,16,1番の行で重要な役割を果たすヒープを更新する処理だから。あくまで処理としては更新のみのため。,9,9,,15,答えとなるdistを更新する行だから。ただダイクストラ法の本質ではないため。,9,9,,,とても理解できた。,
12/28/2022 22:32:46,5,30,1,このコードだけでは、Dijkstra法で利用しているheapqが内部でソートが保たれていることが分からない。そこで、heapqについて調べておくことが理解に不可欠であると考え、import文のある1行目を最も大切だと考えた。,14,14,,16,heapqの挙動(heappushの引数)について理解したのち、queueに何がpushされているのかを理解することができるため、16行目が2番目に大切だと考えた。,11,11,,15,距離の更新を実際に行っているため、重要だと考えた。ただし、基礎的なものであるため3番目においた。,9,9,,,とても理解できた。,
12/31/2022 2:20:25,10,30,16,ヒープを用いて、更新した後、一番小さいものが上に来るようにすることが重要だと思ったため。,14,14,,15,1番の工夫に加え、ダイクストラ法のアルゴリズムに基づいた値の更新も重要だと思ったため。,9,9,,8,1番2番の次に、ヒープの構造を利用して計算量を下げることが重要だと思ったため。,4,4,,,まあ理解できた。,
1/3/2023 8:39:22,11,30,12,最短距離が最も短い頂点を取り出すことがダイクストラにとって大事だと感じました．,11,11,,23,距離が小さくなっていたら更新する箇所を選びました．どの探索候補を選ぶかの方が自明度が低いと思ったので，比較して2番目にしました．,9,9,,16,確定済みかを把握しておくのは大事なので選びました．どちらかというと工夫に近いのかなと感じたので，3番目にしました．,1,1,,,とても理解できた。,
